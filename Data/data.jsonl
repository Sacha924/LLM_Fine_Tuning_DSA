{"prompt": "Write an optimized Python function to solve the following problem: You are given an integer n representing the length of an unknown array that you are trying to recover. You are also given an array sums containing the values of all 2n subset sums of the unknown array (in no particular order). Return the array ans of length n representing the unknown array. If multiple answers exist, return any of them. An array sub is a subset of an array arr if sub can be obtained from arr by deleting some (possibly zero or all) elements of arr. The sum of the elements in sub is one possible subset sum of arr. The sum of an empty array is considered to be 0. Note: Test cases are generated such that there will always be at least one correct answer. Example 1: Input: n = 3, sums = [-3,-2,-1,0,0,1,2,3] Output: [1,2,-3] Explanation: [1,2,-3] is able to achieve the given subset sums: - []: sum is 0 - [1]: sum is 1 - [2]: sum is 2 - [1,2]: sum is 3 - [-3]: sum is -3 - [1,-3]: sum is -2 - [2,-3]: sum is -1 - [1,2,-3]: sum is 0 Note that any permutation of [1,2,-3] and also any permutation of [-1,-2,3] will also be accepted. Example 2: Input: n = 2, sums = [0,0,0,0] Output: [0,0] Explanation: The only correct answer is [0,0]. Example 3: Input: n = 4, sums = [0,0,5,5,4,-1,4,9,9,-1,4,3,4,8,3,8] Output: [0,-1,4,5] Explanation: [0,-1,4,5] is able to achieve the given subset sums. Constraints: 1 <= n <= 15 sums.length == 2n -104 <= sums[i] <= 104", "completion": "class Solution:\\n    def recoverArray(self, n: int, sums: List[int]) -> List[int]:\\n        res = []  # Result set\\n        sums.sort()\\n        \\n        while len(sums) > 1:\\n            num = sums[-1] - sums[-2] # max - secondMax\\n            countMap = Counter(sums) # Get count of each elements\\n            excluding = [] # Subset sums that do NOT contain num\\n            including = [] # Subset sums that contain num\\n            \\n            for x in sums:\\n                if countMap.get(x) > 0:\\n                    excluding.append(x)\\n                    including.append(x+num)\\n                    countMap[x] -= 1\\n                    countMap[x+num] -= 1\\n                    \\n\\t\\t\\t# Check validity of excluding set\\t\\n            if 0 in excluding:\\n                sums = excluding\\n                res.append(num)\\n            else:\\n                sums = including\\n                res.append(-1*num)\\n        \\n        return res\\n"}
{"prompt": "Write an optimized Python function to solve the following problem: You are given a binary string binary. A subsequence of binary is considered good if it is not empty and has no leading zeros (with the exception of \"0\"). Find the number of unique good subsequences of binary. For example, if binary = \"001\", then all the good subsequences are [\"0\", \"0\", \"1\"], so the unique good subsequences are \"0\" and \"1\". Note that subsequences \"00\", \"01\", and \"001\" are not good because they have leading zeros. Return the number of unique good subsequences of binary. Since the answer may be very large, return it modulo 109 + 7. A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements. Example 1: Input: binary = \"001\" Output: 2 Explanation: The good subsequences of binary are [\"0\", \"0\", \"1\"]. The unique good subsequences are \"0\" and \"1\". Example 2: Input: binary = \"11\" Output: 2 Explanation: The good subsequences of binary are [\"1\", \"1\", \"11\"]. The unique good subsequences are \"1\" and \"11\". Example 3: Input: binary = \"101\" Output: 5 Explanation: The good subsequences of binary are [\"1\", \"0\", \"1\", \"10\", \"11\", \"101\"]. The unique good subsequences are \"0\", \"1\", \"10\", \"11\", and \"101\". Constraints: 1 <= binary.length <= 105 binary consists of only '0's and '1's.", "completion": "class Solution:\\n    def numberOfUniqueGoodSubsequences(self, binary: str) -> int:\\n        mod = 10**9 + 7\\n        dp = [[0, 0] for _ in range(2)]  # dp[i][j] represents count of subsequences ending at index i with last element j (0 or 1)\\n        n = len(binary)\\n        \\n        for ch in binary:\\n            if ch == \\'0\\':\\n                # For a \\'0\\', we have two cases:\\n                # 1. Extend the subsequences ending with \\'0\\' by one more \\'0\\'.\\n                # 2. Extend the subsequences ending with \\'1\\' by appending this \\'0\\' to form new subsequences.\\n                dp[0][0] = 1\\n                dp[1][0] = (dp[1][0] + dp[1][1]) % mod\\n            else:\\n                # For a \\'1\\', we have one case:\\n                # Extend the subsequences ending with \\'0\\' or \\'1\\' by appending this \\'1\\' to form new subsequences.\\n                dp[1][1] = (dp[1][0] + dp[1][1] + 1) % mod\\n        \\n        # The answer is the sum of counts of subsequences ending with \\'0\\' and \\'1\\',\\n        # considering all the possibilities.\\n        result = (dp[0][0] + dp[0][1] + dp[1][0] + dp[1][1]) % mod\\n        return result\\n\\n# Create an instance of the Solution class\\nsol = Solution()\\n\\n# Test cases\\nprint(sol.numberOfUniqueGoodSubsequences(\"001\"))  # Output: 2\\nprint(sol.numberOfUniqueGoodSubsequences(\"11\"))   # Output: 2\\nprint(sol.numberOfUniqueGoodSubsequences(\"101\"))  # Output: 5\\n"}
{"prompt": "Write an optimized Python function to solve the following problem: You are given an integer array nums. We call a subset of nums good if its product can be represented as a product of one or more distinct prime numbers. For example, if nums = [1, 2, 3, 4]: [2, 3], [1, 2, 3], and [1, 3] are good subsets with products 6 = 2*3, 6 = 2*3, and 3 = 3 respectively. [1, 4] and [4] are not good subsets with products 4 = 2*2 and 4 = 2*2 respectively. Return the number of different good subsets in nums modulo 109 + 7. A subset of nums is any array that can be obtained by deleting some (possibly none or all) elements from nums. Two subsets are different if and only if the chosen indices to delete are different. Example 1: Input: nums = [1,2,3,4] Output: 6 Explanation: The good subsets are: - [1,2]: product is 2, which is the product of distinct prime 2. - [1,2,3]: product is 6, which is the product of distinct primes 2 and 3. - [1,3]: product is 3, which is the product of distinct prime 3. - [2]: product is 2, which is the product of distinct prime 2. - [2,3]: product is 6, which is the product of distinct primes 2 and 3. - [3]: product is 3, which is the product of distinct prime 3. Example 2: Input: nums = [4,2,3,15] Output: 5 Explanation: The good subsets are: - [2]: product is 2, which is the product of distinct prime 2. - [2,3]: product is 6, which is the product of distinct primes 2 and 3. - [2,15]: product is 30, which is the product of distinct primes 2, 3, and 5. - [3]: product is 3, which is the product of distinct prime 3. - [15]: product is 15, which is the product of distinct primes 3 and 5. Constraints: 1 <= nums.length <= 105 1 <= nums[i] <= 30", "completion": "class Solution:\\n    def numberOfGoodSubsets(self, nums: List[int]) -> int:\\n        freq = [0] * 31\\n        for x in nums: freq[x] += 1\\n        \\n        masks = [0] * 31\\n        for x in range(1, 31): \\n            if x == 1: masks[x] = 0b10\\n            else: \\n                bits = 0\\n                xx = x\\n                for k in (2, 3, 5, 7, 11, 13, 17, 19, 23, 29): \\n                    while xx % k == 0: \\n                        if (bits >> k) & 1: break # repeated factors \\n                        bits ^= 1 << k\\n                        xx //= k\\n                    else: continue \\n                    break \\n                else: masks[x] = bits\\n                    \\n        @cache\\n        def fn(x, m): \\n            \"\"\"Return number of good subsets.\"\"\"\\n            if x == 31: return int(m > 2)\\n            ans = fn(x+1, m)\\n            if freq[x] and masks[x]: \\n                if x == 1: ans *= 2**freq[x]\\n                elif not m & masks[x]: ans += freq[x] * fn(x+1, m | masks[x])\\n            return ans % 1_000_000_007\\n        \\n        return fn(1, 0)\\n"}
{"prompt": "Write an optimized Python function to solve the following problem: You are given an integer array nums, and you can perform the following operation any number of times on nums: Swap the positions of two elements nums[i] and nums[j] if gcd(nums[i], nums[j]) > 1 where gcd(nums[i], nums[j]) is the greatest common divisor of nums[i] and nums[j]. Return true if it is possible to sort nums in non-decreasing order using the above swap method, or false otherwise. Example 1: Input: nums = [7,21,3] Output: true Explanation: We can sort [7,21,3] by performing the following operations: - Swap 7 and 21 because gcd(7,21) = 7. nums = [21,7,3] - Swap 21 and 3 because gcd(21,3) = 3. nums = [3,7,21] Example 2: Input: nums = [5,2,6,2] Output: false Explanation: It is impossible to sort the array because 5 cannot be swapped with any other element. Example 3: Input: nums = [10,5,9,3,15] Output: true We can sort [10,5,9,3,15] by performing the following operations: - Swap 10 and 15 because gcd(10,15) = 5. nums = [15,5,9,3,10] - Swap 15 and 3 because gcd(15,3) = 3. nums = [3,5,9,15,10] - Swap 10 and 15 because gcd(10,15) = 5. nums = [3,5,9,10,15] Constraints: 1 <= nums.length <= 3 * 104 2 <= nums[i] <= 105", "completion": "class Solution:\\n    def gcdSort(self, nums: List[int]) -> bool:\\n        m = max(nums)\\n        uf = UnionFind(m+1)\\n        \\n        seen = set(nums)\\n        \\n        # modified sieve of eratosthenes\\n        sieve = [1]*(m+1)\\n        sieve[0] = sieve[1] = 0\\n        for k in range(m//2 + 1): \\n            if sieve[k]: \\n                for x in range(2*k, m+1, k): \\n                    sieve[x] = 0\\n                    if x in seen: uf.union(k, x)\\n        return all(uf.find(x) == uf.find(y) for x, y in zip(nums, sorted(nums)))\\n"}
{"prompt": "Write an optimized Python function to solve the following problem: There is a family tree rooted at 0 consisting of n nodes numbered 0 to n - 1. You are given a 0-indexed integer array parents, where parents[i] is the parent for node i. Since node 0 is the root, parents[0] == -1. There are 105 genetic values, each represented by an integer in the inclusive range [1, 105]. You are given a 0-indexed integer array nums, where nums[i] is a distinct genetic value for node i. Return an array ans of length n where ans[i] is the smallest genetic value that is missing from the subtree rooted at node i. The subtree rooted at a node x contains node x and all of its descendant nodes. Example 1: Input: parents = [-1,0,0,2], nums = [1,2,3,4] Output: [5,1,1,1] Explanation: The answer for each subtree is calculated as follows: - 0: The subtree contains nodes [0,1,2,3] with values [1,2,3,4]. 5 is the smallest missing value. - 1: The subtree contains only node 1 with value 2. 1 is the smallest missing value. - 2: The subtree contains nodes [2,3] with values [3,4]. 1 is the smallest missing value. - 3: The subtree contains only node 3 with value 4. 1 is the smallest missing value. Example 2: Input: parents = [-1,0,1,0,3,3], nums = [5,4,6,2,1,3] Output: [7,1,1,4,2,1] Explanation: The answer for each subtree is calculated as follows: - 0: The subtree contains nodes [0,1,2,3,4,5] with values [5,4,6,2,1,3]. 7 is the smallest missing value. - 1: The subtree contains nodes [1,2] with values [4,6]. 1 is the smallest missing value. - 2: The subtree contains only node 2 with value 6. 1 is the smallest missing value. - 3: The subtree contains nodes [3,4,5] with values [2,1,3]. 4 is the smallest missing value. - 4: The subtree contains only node 4 with value 1. 2 is the smallest missing value. - 5: The subtree contains only node 5 with value 3. 1 is the smallest missing value. Example 3: Input: parents = [-1,2,3,0,2,4,1], nums = [2,3,4,5,6,7,8] Output: [1,1,1,1,1,1,1] Explanation: The value 1 is missing from all the subtrees. Constraints: n == parents.length == nums.length 2 <= n <= 105 0 <= parents[i] <= n - 1 for i != 0 parents[0] == -1 parents represents a valid tree. 1 <= nums[i] <= 105 Each nums[i] is distinct.", "completion": "class Solution:\\n    def smallestMissingValueSubtree(self, parents: List[int], nums: List[int]) -> List[int]:\\n        ans = [1] * len(parents)\\n        if 1 in nums: \\n            tree = {}\\n            for i, x in enumerate(parents): \\n                tree.setdefault(x, []).append(i)\\n                \\n            k = nums.index(1)\\n            val = 1\\n            seen = set()\\n            \\n            while k != -1: \\n                stack = [k]\\n                while stack: \\n                    x = stack.pop()\\n                    seen.add(nums[x])\\n                    for xx in tree.get(x, []): \\n                        if nums[xx] not in seen: \\n                            stack.append(xx)\\n                            seen.add(nums[xx])\\n                while val in seen: val += 1\\n                ans[k] = val\\n                k = parents[k]\\n        return ans \\n"}
{"prompt": "Write an optimized Python function to solve the following problem: You are given an integer array nums. In one operation, you can replace any element in nums with any integer. nums is considered continuous if both of the following conditions are fulfilled: All elements in nums are unique. The difference between the maximum element and the minimum element in nums equals nums.length - 1. For example, nums = [4, 2, 5, 3] is continuous, but nums = [1, 2, 3, 5, 6] is not continuous. Return the minimum number of operations to make nums continuous. Example 1: Input: nums = [4,2,5,3] Output: 0 Explanation: nums is already continuous. Example 2: Input: nums = [1,2,3,5,6] Output: 1 Explanation: One possible solution is to change the last element to 4. The resulting array is [1,2,3,5,4], which is continuous. Example 3: Input: nums = [1,10,100,1000] Output: 3 Explanation: One possible solution is to: - Change the second element to 2. - Change the third element to 3. - Change the fourth element to 4. The resulting array is [1,2,3,4], which is continuous. Constraints: 1 <= nums.length <= 105 1 <= nums[i] <= 109", "completion": "class Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        length = len(nums)\\n        min_operations = length\\n        unique_nums = sorted(set(nums))\\n        right = 0\\n        \\n        for left in range(len(unique_nums)):\\n            while right < len(unique_nums) and unique_nums[right] < unique_nums[left] + length:\\n                right += 1\\n            \\n            min_operations = min(min_operations, length - (right - left))\\n\\n        return min_operations\\n"}
{"prompt": "Write an optimized Python function to solve the following problem: You are given a string s of length n, and an integer k. You are tasked to find the longest subsequence repeated k times in string s. A subsequence is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters. A subsequence seq is repeated k times in the string s if seq * k is a subsequence of s, where seq * k represents a string constructed by concatenating seq k times. For example, \"bba\" is repeated 2 times in the string \"bababcba\", because the string \"bbabba\", constructed by concatenating \"bba\" 2 times, is a subsequence of the string \"bababcba\". Return the longest subsequence repeated k times in string s. If multiple such subsequences are found, return the lexicographically largest one. If there is no such subsequence, return an empty string. Example 1: Input: s = \"letsleetcode\", k = 2 Output: \"let\" Explanation: There are two longest subsequences repeated 2 times: \"let\" and \"ete\". \"let\" is the lexicographically largest one. Example 2: Input: s = \"bb\", k = 2 Output: \"b\" Explanation: The longest subsequence repeated 2 times is \"b\". Example 3: Input: s = \"ab\", k = 2 Output: \"\" Explanation: There is no subsequence repeated 2 times. Empty string is returned. Constraints: n == s.length 2 <= n, k <= 2000 2 <= n < k * 8 s consists of lowercase English letters.", "completion": "class Solution:\\n    def longestSubsequenceRepeatedK(self, s: str, k: int) -> str:\\n        freq = [0] * 26\\n        for ch in s: freq[ord(ch)-97] += 1\\n        \\n        cand = [chr(i+97) for i, x in enumerate(freq) if x >= k] # valid candidates \\n        \\n        def fn(ss): \\n            \"\"\"Return True if ss is a k-repeated sub-sequence of s.\"\"\"\\n            i = cnt = 0\\n            for ch in s: \\n                if ss[i] == ch: \\n                    i += 1\\n                    if i == len(ss): \\n                        if (cnt := cnt + 1) == k: return True  \\n                        i = 0\\n            return False \\n        \\n        ans = \"\"\\n        queue = deque([\"\"])\\n        while queue: \\n            x = queue.popleft()\\n            for ch in cand:  \\n                xx = x + ch\\n                if fn(xx): \\n                    ans = xx\\n                    queue.append(xx)\\n        return ans\\n"}
{"prompt": "Write an optimized Python function to solve the following problem: You are given a string s that contains digits 0-9, addition symbols '+', and multiplication symbols '*' only, representing a valid math expression of single digit numbers (e.g., 3+5*2). This expression was given to n elementary school students. The students were instructed to get the answer of the expression by following this order of operations: Compute multiplication, reading from left to right; Then, Compute addition, reading from left to right. You are given an integer array answers of length n, which are the submitted answers of the students in no particular order. You are asked to grade the answers, by following these rules: If an answer equals the correct answer of the expression, this student will be rewarded 5 points; Otherwise, if the answer could be interpreted as if the student applied the operators in the wrong order but had correct arithmetic, this student will be rewarded 2 points; Otherwise, this student will be rewarded 0 points. Return the sum of the points of the students. Example 1: Input: s = \"7+3*1*2\", answers = [20,13,42] Output: 7 Explanation: As illustrated above, the correct answer of the expression is 13, therefore one student is rewarded 5 points: [20,13,42] A student might have applied the operators in this wrong order: ((7+3)*1)*2 = 20. Therefore one student is rewarded 2 points: [20,13,42] The points for the students are: [2,5,0]. The sum of the points is 2+5+0=7. Example 2: Input: s = \"3+5*2\", answers = [13,0,10,13,13,16,16] Output: 19 Explanation: The correct answer of the expression is 13, therefore three students are rewarded 5 points each: [13,0,10,13,13,16,16] A student might have applied the operators in this wrong order: ((3+5)*2 = 16. Therefore two students are rewarded 2 points: [13,0,10,13,13,16,16] The points for the students are: [5,0,0,5,5,2,2]. The sum of the points is 5+0+0+5+5+2+2=19. Example 3: Input: s = \"6+0*1\", answers = [12,9,6,4,8,6] Output: 10 Explanation: The correct answer of the expression is 6. If a student had incorrectly done (6+0)*1, the answer would also be 6. By the rules of grading, the students will still be rewarded 5 points (as they got the correct answer), not 2 points. The points for the students are: [0,0,5,0,0,5]. The sum of the points is 10. Constraints: 3 <= s.length <= 31 s represents a valid expression that contains only digits 0-9, '+', and '*' only. All the integer operands in the expression are in the inclusive range [0, 9]. 1 <= The count of all operators ('+' and '*') in the math expression <= 15 Test data are generated such that the correct answer of the expression is in the range of [0, 1000]. n == answers.length 1 <= n <= 104 0 <= answers[i] <= 1000", "completion": "class Solution:\\n    def scoreOfStudents(self, s: str, answers: List[int]) -> int:\\n        \\n        @cache\\n        def fn(lo, hi): \\n            \"\"\"Return possible answers of s[lo:hi].\"\"\"\\n            if lo+1 == hi: return {int(s[lo])}\\n            ans = set()\\n            for mid in range(lo+1, hi, 2): \\n                for x in fn(lo, mid): \\n                    for y in fn(mid+1, hi): \\n                        if s[mid] == \"+\" and x + y <= 1000: ans.add(x + y)\\n                        elif s[mid] == \"*\" and x * y <= 1000: ans.add(x * y)\\n            return ans \\n                \\n        target = eval(s)\\n        cand = fn(0, len(s))\\n        ans = 0 \\n        for x in answers: \\n            if x == target: ans += 5\\n            elif x in cand: ans += 2\\n        return ans \\n"}
{"prompt": "Write an optimized Python function to solve the following problem: You are given a string s, an integer k, a letter letter, and an integer repetition. Return the lexicographically smallest subsequence of s of length k that has the letter letter appear at least repetition times. The test cases are generated so that the letter appears in s at least repetition times. A subsequence is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters. A string a is lexicographically smaller than a string b if in the first position where a and b differ, string a has a letter that appears earlier in the alphabet than the corresponding letter in b. Example 1: Input: s = \"leet\", k = 3, letter = \"e\", repetition = 1 Output: \"eet\" Explanation: There are four subsequences of length 3 that have the letter 'e' appear at least 1 time: - \"lee\" (from \"leet\") - \"let\" (from \"leet\") - \"let\" (from \"leet\") - \"eet\" (from \"leet\") The lexicographically smallest subsequence among them is \"eet\". Example 2: Input: s = \"leetcode\", k = 4, letter = \"e\", repetition = 2 Output: \"ecde\" Explanation: \"ecde\" is the lexicographically smallest subsequence of length 4 that has the letter \"e\" appear at least 2 times. Example 3: Input: s = \"bb\", k = 2, letter = \"b\", repetition = 2 Output: \"bb\" Explanation: \"bb\" is the only subsequence of length 2 that has the letter \"b\" appear at least 2 times. Constraints: 1 <= repetition <= k <= s.length <= 5 * 104 s consists of lowercase English letters. letter is a lowercase English letter, and appears in s at least repetition times.", "completion": "class Solution:\\n    def smallestSubsequence(self, s: str, k: int, letter: str, repetition: int) -> str:\\n        counts,total = 0, 0\\n        n = len(s)\\n        for ch in s:\\n            if ch==letter:\\n                total +=1\\n        stack = []\\n        occ = 0\\n        for idx,ch in enumerate(s):\\n            if ch==letter:\\n                counts +=1\\n            while stack and stack[-1]>ch and  len(stack)+ (n-1-idx)>=k and (occ+total-counts-(stack[-1]==letter)+(ch==letter)>=repetition ): \\n                occ -= stack.pop()==letter\\n            if ch!=letter  and len(stack)< k-max(0,(repetition-occ)):\\n                stack.append(ch)\\n            elif ch==letter and len(stack)+(total-counts)<k:\\n                stack.append(ch)\\n                occ +=1\\n        return \\'\\'.join(stack)\\n"}
{"prompt": "Write an optimized Python function to solve the following problem: You are given an integer array nums of 2 * n integers. You need to partition nums into two arrays of length n to minimize the absolute difference of the sums of the arrays. To partition nums, put each element of nums into one of the two arrays. Return the minimum possible absolute difference. Example 1: Input: nums = [3,9,7,3] Output: 2 Explanation: One optimal partition is: [3,9] and [7,3]. The absolute difference between the sums of the arrays is abs((3 + 9) - (7 + 3)) = 2. Example 2: Input: nums = [-36,36] Output: 72 Explanation: One optimal partition is: [-36] and [36]. The absolute difference between the sums of the arrays is abs((-36) - (36)) = 72. Example 3: Input: nums = [2,-1,0,4,-2,-9] Output: 0 Explanation: One optimal partition is: [2,4,-9] and [-1,0,-2]. The absolute difference between the sums of the arrays is abs((2 + 4 + -9) - (-1 + 0 + -2)) = 0. Constraints: 1 <= n <= 15 nums.length == 2 * n -107 <= nums[i] <= 107", "completion": "class Solution:\\n    def minimumDifference(self, nums: List[int]) -> int:\\n        N = len(nums) // 2 # Note this is N/2, ie no. of elements required in each.\\n        \\n        def get_sums(nums): # generate all combinations sum of k elements\\n            ans = {}\\n            N = len(nums)\\n            for k in range(1, N+1): # takes k element for nums\\n                sums = []\\n                for comb in combinations(nums, k):\\n                    s = sum(comb)\\n                    sums.append(s)\\n                ans[k] = sums\\n            return ans\\n        \\n        left_part, right_part = nums[:N], nums[N:]\\n        left_sums, right_sums = get_sums(left_part), get_sums(right_part)\\n        ans = abs(sum(left_part) - sum(right_part)) # the case when taking all N from left_part for left_ans, and vice versa\\n        total = sum(nums) \\n        half = total // 2 # the best sum required for each, we have to find sum nearest to this\\n        for k in range(1, N):\\n            left = left_sums[k] # if taking k no. from left_sums\\n            right = right_sums[N-k] # then we have to take remaining N-k from right_sums.\\n            right.sort() # sorting, so that we can binary search the required value\\n            for x in left:\\n                r = half - x # required, how much we need to add in x to bring it closer to half.\\n                p = bisect.bisect_left(right, r) # we are finding index of value closest to r, present in right, using binary search\\n                for q in [p, p-1]:\\n                    if 0 <= q < len(right):\\n                        left_ans_sum = x + right[q]\\n                        right_ans_sum = total - left_ans_sum\\n                        diff = abs(left_ans_sum - right_ans_sum)\\n                        ans = min(ans, diff) \\n        return ans\\n"}
{"prompt": "Write an optimized Python function to solve the following problem: Given two sorted 0-indexed integer arrays nums1 and nums2 as well as an integer k, return the kth (1-based) smallest product of nums1[i] * nums2[j] where 0 <= i < nums1.length and 0 <= j < nums2.length. Example 1: Input: nums1 = [2,5], nums2 = [3,4], k = 2 Output: 8 Explanation: The 2 smallest products are: - nums1[0] * nums2[0] = 2 * 3 = 6 - nums1[0] * nums2[1] = 2 * 4 = 8 The 2nd smallest product is 8. Example 2: Input: nums1 = [-4,-2,0,3], nums2 = [2,4], k = 6 Output: 0 Explanation: The 6 smallest products are: - nums1[0] * nums2[1] = (-4) * 4 = -16 - nums1[0] * nums2[0] = (-4) * 2 = -8 - nums1[1] * nums2[1] = (-2) * 4 = -8 - nums1[1] * nums2[0] = (-2) * 2 = -4 - nums1[2] * nums2[0] = 0 * 2 = 0 - nums1[2] * nums2[1] = 0 * 4 = 0 The 6th smallest product is 0. Example 3: Input: nums1 = [-2,-1,0,1,2], nums2 = [-3,-1,2,4,5], k = 3 Output: -6 Explanation: The 3 smallest products are: - nums1[0] * nums2[4] = (-2) * 5 = -10 - nums1[0] * nums2[3] = (-2) * 4 = -8 - nums1[4] * nums2[0] = 2 * (-3) = -6 The 3rd smallest product is -6. Constraints: 1 <= nums1.length, nums2.length <= 5 * 104 -105 <= nums1[i], nums2[j] <= 105 1 <= k <= nums1.length * nums2.length nums1 and nums2 are sorted.", "completion": "class Solution:\\n    def kthSmallestProduct(self, nums1: List[int], nums2: List[int], k: int) -> int:\\n        \\n        def fn(val):\\n            \"\"\"Return count of products <= val.\"\"\"\\n            ans = 0\\n            for x in nums1: \\n                if x < 0: ans += len(nums2) - bisect_left(nums2, ceil(val/x))\\n                elif x == 0: \\n                    if 0 <= val: ans += len(nums2)\\n                else: ans += bisect_right(nums2, floor(val/x))\\n            return ans \\n            \\n        lo, hi = -10**10, 10**10 + 1\\n        while lo < hi: \\n            mid = lo + hi >> 1\\n            if fn(mid) < k: lo = mid + 1\\n            else: hi = mid\\n        return lo \\n"}
{"prompt": "Write an optimized Python function to solve the following problem: A city is represented as a bi-directional connected graph with n vertices where each vertex is labeled from 1 to n (inclusive). The edges in the graph are represented as a 2D integer array edges, where each edges[i] = [ui, vi] denotes a bi-directional edge between vertex ui and vertex vi. Every vertex pair is connected by at most one edge, and no vertex has an edge to itself. The time taken to traverse any edge is time minutes. Each vertex has a traffic signal which changes its color from green to red and vice versa every change minutes. All signals change at the same time. You can enter a vertex at any time, but can leave a vertex only when the signal is green. You cannot wait at a vertex if the signal is green. The second minimum value is defined as the smallest value strictly larger than the minimum value. For example the second minimum value of [2, 3, 4] is 3, and the second minimum value of [2, 2, 4] is 4. Given n, edges, time, and change, return the second minimum time it will take to go from vertex 1 to vertex n. Notes: You can go through any vertex any number of times, including 1 and n. You can assume that when the journey starts, all signals have just turned green. Example 1: Input: n = 5, edges = [[1,2],[1,3],[1,4],[3,4],[4,5]], time = 3, change = 5 Output: 13 Explanation: The figure on the left shows the given graph. The blue path in the figure on the right is the minimum time path. The time taken is: - Start at 1, time elapsed=0 - 1 -> 4: 3 minutes, time elapsed=3 - 4 -> 5: 3 minutes, time elapsed=6 Hence the minimum time needed is 6 minutes. The red path shows the path to get the second minimum time. - Start at 1, time elapsed=0 - 1 -> 3: 3 minutes, time elapsed=3 - 3 -> 4: 3 minutes, time elapsed=6 - Wait at 4 for 4 minutes, time elapsed=10 - 4 -> 5: 3 minutes, time elapsed=13 Hence the second minimum time is 13 minutes. Example 2: Input: n = 2, edges = [[1,2]], time = 3, change = 2 Output: 11 Explanation: The minimum time path is 1 -> 2 with time = 3 minutes. The second minimum time path is 1 -> 2 -> 1 -> 2 with time = 11 minutes. Constraints: 2 <= n <= 104 n - 1 <= edges.length <= min(2 * 104, n * (n - 1) / 2) edges[i].length == 2 1 <= ui, vi <= n ui != vi There are no duplicate edges. Each vertex can be reached directly or indirectly from every other vertex. 1 <= time, change <= 103", "completion": "class Solution:\\n    def secondMinimum(self, n: int, edges: List[List[int]], time: int, change: int) -> int:\\n        graph = [[] for _ in range(n)]\\n        for u, v in edges: \\n            graph[u-1].append(v-1)\\n            graph[v-1].append(u-1)\\n        pq = [(0, 0)]\\n        seen = [[] for _ in range(n)]\\n        least = None\\n        while pq: \\n            t, u = heappop(pq)\\n            if u == n-1: \\n                if least is None: least = t\\n                elif least < t: return t \\n            if (t//change) & 1: t = (t//change+1)*change # waiting for green\\n            t += time\\n            for v in graph[u]: \\n                if not seen[v] or len(seen[v]) == 1 and seen[v][0] != t: \\n                    seen[v].append(t)\\n                    heappush(pq, (t, v))\\n"}
{"prompt": "Write an optimized Python function to solve the following problem: You are given an integer n, which indicates that there are n courses labeled from 1 to n. You are also given a 2D integer array relations where relations[j] = [prevCoursej, nextCoursej] denotes that course prevCoursej has to be completed before course nextCoursej (prerequisite relationship). Furthermore, you are given a 0-indexed integer array time where time[i] denotes how many months it takes to complete the (i+1)th course. You must find the minimum number of months needed to complete all the courses following these rules: You may start taking a course at any time if the prerequisites are met. Any number of courses can be taken at the same time. Return the minimum number of months needed to complete all the courses. Note: The test cases are generated such that it is possible to complete every course (i.e., the graph is a directed acyclic graph). Example 1: Input: n = 3, relations = [[1,3],[2,3]], time = [3,2,5] Output: 8 Explanation: The figure above represents the given graph and the time required to complete each course. We start course 1 and course 2 simultaneously at month 0. Course 1 takes 3 months and course 2 takes 2 months to complete respectively. Thus, the earliest time we can start course 3 is at month 3, and the total time required is 3 + 5 = 8 months. Example 2: Input: n = 5, relations = [[1,5],[2,5],[3,5],[3,4],[4,5]], time = [1,2,3,4,5] Output: 12 Explanation: The figure above represents the given graph and the time required to complete each course. You can start courses 1, 2, and 3 at month 0. You can complete them after 1, 2, and 3 months respectively. Course 4 can be taken only after course 3 is completed, i.e., after 3 months. It is completed after 3 + 4 = 7 months. Course 5 can be taken only after courses 1, 2, 3, and 4 have been completed, i.e., after max(1,2,3,7) = 7 months. Thus, the minimum time needed to complete all the courses is 7 + 5 = 12 months. Constraints: 1 <= n <= 5 * 104 0 <= relations.length <= min(n * (n - 1) / 2, 5 * 104) relations[j].length == 2 1 <= prevCoursej, nextCoursej <= n prevCoursej != nextCoursej All the pairs [prevCoursej, nextCoursej] are unique. time.length == n 1 <= time[i] <= 104 The given graph is a directed acyclic graph.", "completion": "class Solution:\\n    def minimumTime(self, n: int, relations: List[List[int]], time: List[int]) -> int:\\n        graph = [[] for _ in range(n)]\\n\\n        for prev, next in relations:\\n            graph[prev - 1].append(next - 1)\\n\\n        memo = [-1] * n\\n\\n        def calculateTime(course):\\n            if memo[course] != -1:\\n                return memo[course]\\n\\n            if not graph[course]:\\n                memo[course] = time[course]\\n                return memo[course]\\n\\n            max_prerequisite_time = 0\\n            for prereq in graph[course]:\\n                max_prerequisite_time = max(max_prerequisite_time, calculateTime(prereq))\\n\\n            memo[course] = max_prerequisite_time + time[course]\\n            return memo[course]\\n\\n        overall_min_time = 0\\n        for course in range(n):\\n            overall_min_time = max(overall_min_time, calculateTime(course))\\n\\n        return overall_min_time\\n\\n"}
{"prompt": "Write an optimized Python function to solve the following problem: There is an 8 x 8 chessboard containing n pieces (rooks, queens, or bishops). You are given a string array pieces of length n, where pieces[i] describes the type (rook, queen, or bishop) of the ith piece. In addition, you are given a 2D integer array positions also of length n, where positions[i] = [ri, ci] indicates that the ith piece is currently at the 1-based coordinate (ri, ci) on the chessboard. When making a move for a piece, you choose a destination square that the piece will travel toward and stop on. A rook can only travel horizontally or vertically from (r, c) to the direction of (r+1, c), (r-1, c), (r, c+1), or (r, c-1). A queen can only travel horizontally, vertically, or diagonally from (r, c) to the direction of (r+1, c), (r-1, c), (r, c+1), (r, c-1), (r+1, c+1), (r+1, c-1), (r-1, c+1), (r-1, c-1). A bishop can only travel diagonally from (r, c) to the direction of (r+1, c+1), (r+1, c-1), (r-1, c+1), (r-1, c-1). You must make a move for every piece on the board simultaneously. A move combination consists of all the moves performed on all the given pieces. Every second, each piece will instantaneously travel one square towards their destination if they are not already at it. All pieces start traveling at the 0th second. A move combination is invalid if, at a given time, two or more pieces occupy the same square. Return the number of valid move combinations\u200b\u200b\u200b\u200b\u200b. Notes: No two pieces will start in the same square. You may choose the square a piece is already on as its destination. If two pieces are directly adjacent to each other, it is valid for them to move past each other and swap positions in one second. Example 1: Input: pieces = [\"rook\"], positions = [[1,1]] Output: 15 Explanation: The image above shows the possible squares the piece can move to. Example 2: Input: pieces = [\"queen\"], positions = [[1,1]] Output: 22 Explanation: The image above shows the possible squares the piece can move to. Example 3: Input: pieces = [\"bishop\"], positions = [[4,3]] Output: 12 Explanation: The image above shows the possible squares the piece can move to. Constraints: n == pieces.length n == positions.length 1 <= n <= 4 pieces only contains the strings \"rook\", \"queen\", and \"bishop\". There will be at most one queen on the chessboard. 1 <= xi, yi <= 8 Each positions[i] is distinct.", "completion": "class Solution:\\n    BOARD_SIZE = 8\\n    \\n    def diag(self, r, c):\\n        # Return all diagonal indices except (r, c)\\n        # Diagonal indices has the same r - c\\n        inv = r - c\\n        result = []\\n        for ri in range(self.BOARD_SIZE):\\n            ci = ri - inv\\n            if 0 <= ci < self.BOARD_SIZE and ri != r:\\n                result.append((ri, ci))\\n\\n        return result\\n    \\n    def reverseDiag(self, r, c):\\n        # Return all reverse diagonal indices except (r, c)\\n        # Reverse diagonal indices has the same r + c\\n        inv = r + c\\n        result = []\\n        for ri in range(self.BOARD_SIZE):\\n            ci = inv - ri\\n            if 0 <= ci < self.BOARD_SIZE and ri != r:\\n                result.append((ri, ci))\\n\\n        return result\\n    \\n    def generatePossiblePositions(self, piece, start):\\n        # Generate list of possible positions for every figure\\n        rs, cs = start[0] - 1, start[1] - 1\\n\\n        # Start position\\n        result = [(rs, cs)]\\n\\n        # Straight\\n        if piece == \"rook\" or piece == \"queen\":\\n            result.extend([(r, cs) for r in range(self.BOARD_SIZE) if r != rs])\\n            result.extend([(rs, c) for c in range(self.BOARD_SIZE) if c != cs])\\n\\n        # Diagonal\\n        if piece == \"bishop\" or piece == \"queen\":\\n            result.extend(self.diag(rs, cs))\\n            result.extend(self.reverseDiag(rs, cs))\\n\\n        return result\\n    \\n    def collide(self, start1, end1, start2, end2):\\n        # Check if two figures will collide\\n        # Collision occures if: \\n        #  - two figures have the same end points\\n        #  - one figure stands on the way of second one\\n        #\\n        # For this purpose let\\'s model each step of two pieces \\n        # and compare their positions at every time step.\\n        \\n        def steps(start, end):\\n            # Total steps that should be done\\n            return abs(end - start)\\n\\n        def step(start, end):\\n            # Step direction -1, 0, 1\\n            if steps(start, end) == 0:\\n                return 0\\n            return (end - start) / steps(start, end)\\n\\n        (rstart1, cstart1), (rend1, cend1) = start1, end1\\n        (rstart2, cstart2), (rend2, cend2) = start2, end2\\n\\n        # Find step direction for each piece\\n        rstep1, cstep1 = step(rstart1, rend1), step(cstart1, cend1)\\n        rstep2, cstep2 = step(rstart2, rend2), step(cstart2, cend2)\\n\\n        # Find maximum number of steps for each piece\\n        max_step1 = max(steps(rstart1, rend1), steps(cstart1, cend1))\\n        max_step2 = max(steps(rstart2, rend2), steps(cstart2, cend2))\\n\\n        # Move pieces step by step and compare their positions\\n        for step_i in range(max(max_step1, max_step2) + 1):\\n            step_i1 = min(step_i, max_step1)\\n            r1 = rstart1 + step_i1 * rstep1\\n            c1 = cstart1 + step_i1 * cstep1\\n\\n            step_i2 = min(step_i, max_step2)\\n            r2 = rstart2 + step_i2 * rstep2\\n            c2 = cstart2 + step_i2 * cstep2\\n\\n            # If positions are the same then collision occures\\n            if r1 == r2 and c1 == c2:\\n                return True\\n\\n        return False\\n    \\n    def countCombinations(self, pieces: List[str], positions: List[List[int]]) -> int:\\n        if len(pieces) == 0:\\n            return 0\\n\\n        n = len(pieces)\\n        \\n        # Make zero-indexed\\n        start_positions = [[r - 1, c - 1] for r, c in positions]\\n        \\n        # All possible positions\\n        possible_positions = [\\n            self.generatePossiblePositions(piece, start) \\n            for piece, start in zip(pieces, positions)\\n        ]\\n        \\n        # Let\\'s use DFS with backtracking\\n        # For that we will keep set of already occupied coordinates\\n        # and current positions of pieces\\n        occupied = set()\\n        current_positions = [None] * n  # None means that we didn\\'t placed the piece\\n        \\n        def collision(start, end):\\n            # Helper to check if moving from start to end position will collide with someone\\n            for start2, end2 in zip(start_positions, current_positions):\\n                if end2 is not None and self.collide(start, end, start2, end2):\\n                    return True\\n            return False\\n\\n        def dfs(piece_i=0):\\n            # All pieces are placed\\n            if piece_i == n:\\n                return 1\\n\\n            result = 0\\n            for position in possible_positions[piece_i]:\\n                # If position already occupied of collides with other pieces then skip it\\n                if position in occupied or collision(start_positions[piece_i], position):\\n                    continue\\n                \\n                # Occupy the position\\n                occupied.add(position)\\n                current_positions[piece_i] = position\\n                \\n                # Run DFS for next piece\\n                result += dfs(piece_i + 1)\\n                \\n                # Release the position\\n                occupied.remove(position)\\n                current_positions[piece_i] = None\\n                \\n            return result\\n\\n        return dfs()\\n"}
{"prompt": "Write an optimized Python function to solve the following problem: An original string, consisting of lowercase English letters, can be encoded by the following steps: Arbitrarily split it into a sequence of some number of non-empty substrings. Arbitrarily choose some elements (possibly none) of the sequence, and replace each with its length (as a numeric string). Concatenate the sequence as the encoded string. For example, one way to encode an original string \"abcdefghijklmnop\" might be: Split it as a sequence: [\"ab\", \"cdefghijklmn\", \"o\", \"p\"]. Choose the second and third elements to be replaced by their lengths, respectively. The sequence becomes [\"ab\", \"12\", \"1\", \"p\"]. Concatenate the elements of the sequence to get the encoded string: \"ab121p\". Given two encoded strings s1 and s2, consisting of lowercase English letters and digits 1-9 (inclusive), return true if there exists an original string that could be encoded as both s1 and s2. Otherwise, return false. Note: The test cases are generated such that the number of consecutive digits in s1 and s2 does not exceed 3. Example 1: Input: s1 = \"internationalization\", s2 = \"i18n\" Output: true Explanation: It is possible that \"internationalization\" was the original string. - \"internationalization\" -> Split: [\"internationalization\"] -> Do not replace any element -> Concatenate: \"internationalization\", which is s1. - \"internationalization\" -> Split: [\"i\", \"nternationalizatio\", \"n\"] -> Replace: [\"i\", \"18\", \"n\"] -> Concatenate: \"i18n\", which is s2 Example 2: Input: s1 = \"l123e\", s2 = \"44\" Output: true Explanation: It is possible that \"leetcode\" was the original string. - \"leetcode\" -> Split: [\"l\", \"e\", \"et\", \"cod\", \"e\"] -> Replace: [\"l\", \"1\", \"2\", \"3\", \"e\"] -> Concatenate: \"l123e\", which is s1. - \"leetcode\" -> Split: [\"leet\", \"code\"] -> Replace: [\"4\", \"4\"] -> Concatenate: \"44\", which is s2. Example 3: Input: s1 = \"a5b\", s2 = \"c5b\" Output: false Explanation: It is impossible. - The original string encoded as s1 must start with the letter 'a'. - The original string encoded as s2 must start with the letter 'c'. Constraints: 1 <= s1.length, s2.length <= 40 s1 and s2 consist of digits 1-9 (inclusive), and lowercase English letters only. The number of consecutive digits in s1 and s2 does not exceed 3.", "completion": "class Solution:\\n    def possiblyEquals(self, s1: str, s2: str) -> bool:\\n        \\n        def gg(s): \\n            \"\"\"Return possible length\"\"\"\\n            ans = [int(s)]\\n            if len(s) == 2: \\n                if s[1] != \\'0\\': ans.append(int(s[0]) + int(s[1]))\\n                return ans\\n            elif len(s) == 3: \\n                if s[1] != \\'0\\': ans.append(int(s[:1]) + int(s[1:]))\\n                if s[2] != \\'0\\': ans.append(int(s[:2]) + int(s[2:]))\\n                if s[1] != \\'0\\' and s[2] != \\'0\\': ans.append(int(s[0]) + int(s[1]) + int(s[2]))\\n            return ans \\n        \\n        @cache\\n        def fn(i, j, diff): \\n            \"\"\"Return True if s1[i:] matches s2[j:] with given differences.\"\"\"\\n            if i == len(s1) and j == len(s2): return diff == 0\\n            if i < len(s1) and s1[i].isdigit(): \\n                ii = i\\n                while ii < len(s1) and s1[ii].isdigit(): ii += 1\\n                for x in gg(s1[i:ii]): \\n                    if fn(ii, j, diff-x): return True \\n            elif j < len(s2) and s2[j].isdigit(): \\n                jj = j \\n                while jj < len(s2) and s2[jj].isdigit(): jj += 1\\n                for x in gg(s2[j:jj]): \\n                    if fn(i, jj, diff+x): return True \\n            elif diff == 0: \\n                if i == len(s1) or j == len(s2) or s1[i] != s2[j]: return False \\n                return fn(i+1, j+1, 0)\\n            elif diff > 0: \\n                if i == len(s1): return False \\n                return fn(i+1, j, diff-1)\\n            else: \\n                if j == len(s2): return False \\n                return fn(i, j+1, diff+1)\\n            \\n        return fn(0, 0, 0)\\n"}
{"prompt": "Write an optimized Python function to solve the following problem: There is an undirected graph with n nodes numbered from 0 to n - 1 (inclusive). You are given a 0-indexed integer array values where values[i] is the value of the ith node. You are also given a 0-indexed 2D integer array edges, where each edges[j] = [uj, vj, timej] indicates that there is an undirected edge between the nodes uj and vj, and it takes timej seconds to travel between the two nodes. Finally, you are given an integer maxTime. A valid path in the graph is any path that starts at node 0, ends at node 0, and takes at most maxTime seconds to complete. You may visit the same node multiple times. The quality of a valid path is the sum of the values of the unique nodes visited in the path (each node's value is added at most once to the sum). Return the maximum quality of a valid path. Note: There are at most four edges connected to each node. Example 1: Input: values = [0,32,10,43], edges = [[0,1,10],[1,2,15],[0,3,10]], maxTime = 49 Output: 75 Explanation: One possible path is 0 -> 1 -> 0 -> 3 -> 0. The total time taken is 10 + 10 + 10 + 10 = 40 <= 49. The nodes visited are 0, 1, and 3, giving a maximal path quality of 0 + 32 + 43 = 75. Example 2: Input: values = [5,10,15,20], edges = [[0,1,10],[1,2,10],[0,3,10]], maxTime = 30 Output: 25 Explanation: One possible path is 0 -> 3 -> 0. The total time taken is 10 + 10 = 20 <= 30. The nodes visited are 0 and 3, giving a maximal path quality of 5 + 20 = 25. Example 3: Input: values = [1,2,3,4], edges = [[0,1,10],[1,2,11],[2,3,12],[1,3,13]], maxTime = 50 Output: 7 Explanation: One possible path is 0 -> 1 -> 3 -> 1 -> 0. The total time taken is 10 + 13 + 13 + 10 = 46 <= 50. The nodes visited are 0, 1, and 3, giving a maximal path quality of 1 + 2 + 4 = 7. Constraints: n == values.length 1 <= n <= 1000 0 <= values[i] <= 108 0 <= edges.length <= 2000 edges[j].length == 3 0 <= uj < vj <= n - 1 10 <= timej, maxTime <= 100 All the pairs [uj, vj] are unique. There are at most four edges connected to each node. The graph may not be connected.", "completion": "class Solution:\\n    def maximalPathQuality(self, values: List[int], edges: List[List[int]], maxTime: int) -> int:\\n        ans = 0\\n        graph = collections.defaultdict(dict)\\n        for u, v, t in edges:\\n            graph[u][v] = t\\n            graph[v][u] = t\\n        \\n        def dfs(curr, visited, score, cost):\\n            if curr == 0:\\n                nonlocal ans\\n                ans = max(ans, score)\\n            \\n            for nxt, time in graph[curr].items():\\n                if time <= cost:\\n                    dfs(nxt, visited|set([nxt]), score+values[nxt]*(nxt not in visited), cost-time)\\n        \\n        dfs(0, set([0]), values[0], maxTime)\\n        return ans\\n"}
{"prompt": "Write an optimized Python function to solve the following problem: You have n tasks and m workers. Each task has a strength requirement stored in a 0-indexed integer array tasks, with the ith task requiring tasks[i] strength to complete. The strength of each worker is stored in a 0-indexed integer array workers, with the jth worker having workers[j] strength. Each worker can only be assigned to a single task and must have a strength greater than or equal to the task's strength requirement (i.e., workers[j] >= tasks[i]). Additionally, you have pills magical pills that will increase a worker's strength by strength. You can decide which workers receive the magical pills, however, you may only give each worker at most one magical pill. Given the 0-indexed integer arrays tasks and workers and the integers pills and strength, return the maximum number of tasks that can be completed. Example 1: Input: tasks = [3,2,1], workers = [0,3,3], pills = 1, strength = 1 Output: 3 Explanation: We can assign the magical pill and tasks as follows: - Give the magical pill to worker 0. - Assign worker 0 to task 2 (0 + 1 >= 1) - Assign worker 1 to task 1 (3 >= 2) - Assign worker 2 to task 0 (3 >= 3) Example 2: Input: tasks = [5,4], workers = [0,0,0], pills = 1, strength = 5 Output: 1 Explanation: We can assign the magical pill and tasks as follows: - Give the magical pill to worker 0. - Assign worker 0 to task 0 (0 + 5 >= 5) Example 3: Input: tasks = [10,15,30], workers = [0,10,10,10,10], pills = 3, strength = 10 Output: 2 Explanation: We can assign the magical pills and tasks as follows: - Give the magical pill to worker 0 and worker 1. - Assign worker 0 to task 0 (0 + 10 >= 10) - Assign worker 1 to task 1 (10 + 10 >= 15) The last pill is not given because it will not make any worker strong enough for the last task. Constraints: n == tasks.length m == workers.length 1 <= n, m <= 5 * 104 0 <= pills <= m 0 <= tasks[i], workers[j], strength <= 109", "completion": "class Solution:\\n    def maxTaskAssign(self, tasks: List[int], workers: List[int], pills: int, strength: int) -> int:\\n        # workers sorted in reverse order, tasks sorted in normal order\\n        def can_assign(n):\\n            task_i = 0\\n            task_temp = deque()\\n            n_pills = pills\\n            for i in range(n-1,-1,-1):\\n                while task_i < n and tasks[task_i] <= workers[i]+strength:\\n                    task_temp.append(tasks[task_i])\\n                    task_i += 1\\n                \\n                if len(task_temp) == 0:\\n                    return False\\n                if workers[i] >= task_temp[0]:\\n                    task_temp.popleft()\\n                elif n_pills > 0:\\n                    task_temp.pop()\\n                    n_pills -= 1\\n                else:\\n                    return False\\n            return True\\n        \\n        tasks.sort()\\n        workers.sort(reverse = True)\\n        \\n        l = 0\\n        r = min(len(tasks), len(workers))\\n        res = -1\\n        while l <= r:\\n            m = (l+r)//2\\n            if can_assign(m):\\n                res = m\\n                l = m+1\\n            else:\\n                r = m-1\\n        return res\\n"}
{"prompt": "Write an optimized Python function to solve the following problem: You are given an integer n indicating the number of people in a network. Each person is labeled from 0 to n - 1. You are also given a 0-indexed 2D integer array restrictions, where restrictions[i] = [xi, yi] means that person xi and person yi cannot become friends, either directly or indirectly through other people. Initially, no one is friends with each other. You are given a list of friend requests as a 0-indexed 2D integer array requests, where requests[j] = [uj, vj] is a friend request between person uj and person vj. A friend request is successful if uj and vj can be friends. Each friend request is processed in the given order (i.e., requests[j] occurs before requests[j + 1]), and upon a successful request, uj and vj become direct friends for all future friend requests. Return a boolean array result, where each result[j] is true if the jth friend request is successful or false if it is not. Note: If uj and vj are already direct friends, the request is still successful. Example 1: Input: n = 3, restrictions = [[0,1]], requests = [[0,2],[2,1]] Output: [true,false] Explanation: Request 0: Person 0 and person 2 can be friends, so they become direct friends. Request 1: Person 2 and person 1 cannot be friends since person 0 and person 1 would be indirect friends (1--2--0). Example 2: Input: n = 3, restrictions = [[0,1]], requests = [[1,2],[0,2]] Output: [true,false] Explanation: Request 0: Person 1 and person 2 can be friends, so they become direct friends. Request 1: Person 0 and person 2 cannot be friends since person 0 and person 1 would be indirect friends (0--2--1). Example 3: Input: n = 5, restrictions = [[0,1],[1,2],[2,3]], requests = [[0,4],[1,2],[3,1],[3,4]] Output: [true,false,true,false] Explanation: Request 0: Person 0 and person 4 can be friends, so they become direct friends. Request 1: Person 1 and person 2 cannot be friends since they are directly restricted. Request 2: Person 3 and person 1 can be friends, so they become direct friends. Request 3: Person 3 and person 4 cannot be friends since person 0 and person 1 would be indirect friends (0--4--3--1). Constraints: 2 <= n <= 1000 0 <= restrictions.length <= 1000 restrictions[i].length == 2 0 <= xi, yi <= n - 1 xi != yi 1 <= requests.length <= 1000 requests[j].length == 2 0 <= uj, vj <= n - 1 uj != vj", "completion": "class Solution:\\n    def friendRequests(self, n: int, restrictions: List[List[int]], requests: List[List[int]]) -> List[bool]:        \\n        result = [False for _ in requests]\\n        \\n        connected_components = [{i} for i in range(n)]\\n        \\n        connected_comp_dict = {}\\n        for i in range(n):\\n            connected_comp_dict[i] = i\\n        \\n        banned_by_comps = [set() for i in range(n)]\\n        for res in restrictions:\\n            banned_by_comps[res[0]].add(res[1])\\n            banned_by_comps[res[1]].add(res[0])\\n        for i,r in enumerate(requests):\\n            n1, n2 = r[0], r[1]\\n            c1, c2 = connected_comp_dict[n1], connected_comp_dict[n2]\\n            if c1 == c2:\\n                result[i] = True\\n            else:\\n                if not (connected_components[c1].intersection(banned_by_comps[c2]) or connected_components[c2].intersection(banned_by_comps[c1])):\\n                    connected_components[c1].update(connected_components[c2])\\n                    banned_by_comps[c1].update(banned_by_comps[c2])\\n                    for node in connected_components[c2]:\\n                        connected_comp_dict[node] = c1\\n                    result[i] = True\\n                \\n        return result\\n\\n"}
{"prompt": "Write an optimized Python function to solve the following problem: A k-mirror number is a positive integer without leading zeros that reads the same both forward and backward in base-10 as well as in base-k. For example, 9 is a 2-mirror number. The representation of 9 in base-10 and base-2 are 9 and 1001 respectively, which read the same both forward and backward. On the contrary, 4 is not a 2-mirror number. The representation of 4 in base-2 is 100, which does not read the same both forward and backward. Given the base k and the number n, return the sum of the n smallest k-mirror numbers. Example 1: Input: k = 2, n = 5 Output: 25 Explanation: The 5 smallest 2-mirror numbers and their representations in base-2 are listed as follows: base-10 base-2 1 1 3 11 5 101 7 111 9 1001 Their sum = 1 + 3 + 5 + 7 + 9 = 25. Example 2: Input: k = 3, n = 7 Output: 499 Explanation: The 7 smallest 3-mirror numbers are and their representations in base-3 are listed as follows: base-10 base-3 1 1 2 2 4 11 8 22 121 11111 151 12121 212 21212 Their sum = 1 + 2 + 4 + 8 + 121 + 151 + 212 = 499. Example 3: Input: k = 7, n = 17 Output: 20379000 Explanation: The 17 smallest 7-mirror numbers are: 1, 2, 3, 4, 5, 6, 8, 121, 171, 242, 292, 16561, 65656, 2137312, 4602064, 6597956, 6958596 Constraints: 2 <= k <= 9 1 <= n <= 30", "completion": "class Solution:\\n    def kMirror(self, k: int, n: int) -> int:\\n        \\n        def fn(x):\\n            \"\"\"Return next k-symmetric number.\"\"\"\\n            n = len(x)//2\\n            for i in range(n, len(x)): \\n                if int(x[i])+1 < k: \\n                    x[i] = x[~i] = str(int(x[i])+1)\\n                    for ii in range(n, i): x[ii] = x[~ii] = \\'0\\'\\n                    return x\\n            return [\"1\"] + [\"0\"]*(len(x)-1) + [\"1\"]\\n                \\n        x = [\"0\"]\\n        ans = 0\\n        for _ in range(n): \\n            while True: \\n                x = fn(x)\\n                val = int(\"\".join(x), k)\\n                if str(val)[::-1] == str(val): break\\n            ans += val\\n        return ans \\n"}
{"prompt": "Write an optimized Python function to solve the following problem: A farmer has a rectangular grid of land with m rows and n columns that can be divided into unit cells. Each cell is either fertile (represented by a 1) or barren (represented by a 0). All cells outside the grid are considered barren. A pyramidal plot of land can be defined as a set of cells with the following criteria: The number of cells in the set has to be greater than 1 and all cells must be fertile. The apex of a pyramid is the topmost cell of the pyramid. The height of a pyramid is the number of rows it covers. Let (r, c) be the apex of the pyramid, and its height be h. Then, the plot comprises of cells (i, j) where r <= i <= r + h - 1 and c - (i - r) <= j <= c + (i - r). An inverse pyramidal plot of land can be defined as a set of cells with similar criteria: The number of cells in the set has to be greater than 1 and all cells must be fertile. The apex of an inverse pyramid is the bottommost cell of the inverse pyramid. The height of an inverse pyramid is the number of rows it covers. Let (r, c) be the apex of the pyramid, and its height be h. Then, the plot comprises of cells (i, j) where r - h + 1 <= i <= r and c - (r - i) <= j <= c + (r - i). Some examples of valid and invalid pyramidal (and inverse pyramidal) plots are shown below. Black cells indicate fertile cells. Given a 0-indexed m x n binary matrix grid representing the farmland, return the total number of pyramidal and inverse pyramidal plots that can be found in grid. Example 1: Input: grid = [[0,1,1,0],[1,1,1,1]] Output: 2 Explanation: The 2 possible pyramidal plots are shown in blue and red respectively. There are no inverse pyramidal plots in this grid. Hence total number of pyramidal and inverse pyramidal plots is 2 + 0 = 2. Example 2: Input: grid = [[1,1,1],[1,1,1]] Output: 2 Explanation: The pyramidal plot is shown in blue, and the inverse pyramidal plot is shown in red. Hence the total number of plots is 1 + 1 = 2. Example 3: Input: grid = [[1,1,1,1,0],[1,1,1,1,1],[1,1,1,1,1],[0,1,0,0,1]] Output: 13 Explanation: There are 7 pyramidal plots, 3 of which are shown in the 2nd and 3rd figures. There are 6 inverse pyramidal plots, 2 of which are shown in the last figure. The total number of plots is 7 + 6 = 13. Constraints: m == grid.length n == grid[i].length 1 <= m, n <= 1000 1 <= m * n <= 105 grid[i][j] is either 0 or 1.", "completion": "class Solution:\\n    def countPyramids(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        vals = [[inf]*n for _ in range(m)]\\n        for i in range(m):\\n            for j in range(n): \\n                if grid[i][j] == 0: vals[i][j] = 0\\n                elif j == 0: vals[i][j] = 1\\n                else: vals[i][j] = min(vals[i][j], 1 + vals[i][j-1])\\n                if grid[i][~j] == 0: vals[i][~j] = 0\\n                elif j == 0: vals[i][~j] = 1\\n                else: vals[i][~j] = min(vals[i][~j], 1 + vals[i][~j+1])\\n        \\n        def fn(vals): \\n            \"\"\"Return count of pyramid in given grid.\"\"\"\\n            ans = 0 \\n            for j in range(n):\\n                width = 0\\n                for i in range(m): \\n                    if vals[i][j]: width = min(width+1, vals[i][j])\\n                    else: width = 0\\n                    ans += max(0, width-1)\\n            return ans \\n        \\n        return fn(vals) + fn(vals[::-1])\\n"}
{"prompt": "Write an optimized Python function to solve the following problem: You are given an integer n indicating there are n people numbered from 0 to n - 1. You are also given a 0-indexed 2D integer array meetings where meetings[i] = [xi, yi, timei] indicates that person xi and person yi have a meeting at timei. A person may attend multiple meetings at the same time. Finally, you are given an integer firstPerson. Person 0 has a secret and initially shares the secret with a person firstPerson at time 0. This secret is then shared every time a meeting takes place with a person that has the secret. More formally, for every meeting, if a person xi has the secret at timei, then they will share the secret with person yi, and vice versa. The secrets are shared instantaneously. That is, a person may receive the secret and share it with people in other meetings within the same time frame. Return a list of all the people that have the secret after all the meetings have taken place. You may return the answer in any order. Example 1: Input: n = 6, meetings = [[1,2,5],[2,3,8],[1,5,10]], firstPerson = 1 Output: [0,1,2,3,5] Explanation: At time 0, person 0 shares the secret with person 1. At time 5, person 1 shares the secret with person 2. At time 8, person 2 shares the secret with person 3. At time 10, person 1 shares the secret with person 5.\u200b\u200b\u200b\u200b Thus, people 0, 1, 2, 3, and 5 know the secret after all the meetings. Example 2: Input: n = 4, meetings = [[3,1,3],[1,2,2],[0,3,3]], firstPerson = 3 Output: [0,1,3] Explanation: At time 0, person 0 shares the secret with person 3. At time 2, neither person 1 nor person 2 know the secret. At time 3, person 3 shares the secret with person 0 and person 1. Thus, people 0, 1, and 3 know the secret after all the meetings. Example 3: Input: n = 5, meetings = [[3,4,2],[1,2,1],[2,3,1]], firstPerson = 1 Output: [0,1,2,3,4] Explanation: At time 0, person 0 shares the secret with person 1. At time 1, person 1 shares the secret with person 2, and person 2 shares the secret with person 3. Note that person 2 can share the secret at the same time as receiving it. At time 2, person 3 shares the secret with person 4. Thus, people 0, 1, 2, 3, and 4 know the secret after all the meetings. Constraints: 2 <= n <= 105 1 <= meetings.length <= 105 meetings[i].length == 3 0 <= xi, yi <= n - 1 xi != yi 1 <= timei <= 105 1 <= firstPerson <= n - 1", "completion": "class Solution:\\n    def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:\\n        can = {0, firstPerson}\\n        for _, grp in groupby(sorted(meetings, key=lambda x: x[2]), key=lambda x: x[2]): \\n            queue = set()\\n            graph = defaultdict(list)\\n            for x, y, _ in grp: \\n                graph[x].append(y)\\n                graph[y].append(x)\\n                if x in can: queue.add(x)\\n                if y in can: queue.add(y)\\n                    \\n            queue = deque(queue)\\n            while queue: \\n                x = queue.popleft()\\n                for y in graph[x]: \\n                    if y not in can: \\n                        can.add(y)\\n                        queue.append(y)\\n        return can\\n"}
{"prompt": "Write an optimized Python function to solve the following problem: You are given a 0-indexed 2D integer array pairs where pairs[i] = [starti, endi]. An arrangement of pairs is valid if for every index i where 1 <= i < pairs.length, we have endi-1 == starti. Return any valid arrangement of pairs. Note: The inputs will be generated such that there exists a valid arrangement of pairs. Example 1: Input: pairs = [[5,1],[4,5],[11,9],[9,4]] Output: [[11,9],[9,4],[4,5],[5,1]] Explanation: This is a valid arrangement since endi-1 always equals starti. end0 = 9 == 9 = start1 end1 = 4 == 4 = start2 end2 = 5 == 5 = start3 Example 2: Input: pairs = [[1,3],[3,2],[2,1]] Output: [[1,3],[3,2],[2,1]] Explanation: This is a valid arrangement since endi-1 always equals starti. end0 = 3 == 3 = start1 end1 = 2 == 2 = start2 The arrangements [[2,1],[1,3],[3,2]] and [[3,2],[2,1],[1,3]] are also valid. Example 3: Input: pairs = [[1,2],[1,3],[2,1]] Output: [[1,2],[2,1],[1,3]] Explanation: This is a valid arrangement since endi-1 always equals starti. end0 = 2 == 2 = start1 end1 = 1 == 1 = start2 Constraints: 1 <= pairs.length <= 105 pairs[i].length == 2 0 <= starti, endi <= 109 starti != endi No two pairs are exactly the same. There exists a valid arrangement of pairs.", "completion": "class Solution:\\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\\n        graph = defaultdict(list)\\n        degree = defaultdict(int) # net out degree \\n        for x, y in pairs: \\n            graph[x].append(y)\\n            degree[x] += 1\\n            degree[y] -= 1\\n                \\n        for k in degree: \\n            if degree[k] == 1: \\n                x = k\\n                break \\n                \\n        ans = []\\n\\n        def fn(x): \\n            \"\"\"Return Eulerian path via dfs.\"\"\"\\n            while graph[x]: fn(graph[x].pop()) \\n            ans.append(x)\\n        \\n        fn(x)\\n        ans.reverse()\\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]\\n"}
{"prompt": "Write an optimized Python function to solve the following problem: Fruits are available at some positions on an infinite x-axis. You are given a 2D integer array fruits where fruits[i] = [positioni, amounti] depicts amounti fruits at the position positioni. fruits is already sorted by positioni in ascending order, and each positioni is unique. You are also given an integer startPos and an integer k. Initially, you are at the position startPos. From any position, you can either walk to the left or right. It takes one step to move one unit on the x-axis, and you can walk at most k steps in total. For every position you reach, you harvest all the fruits at that position, and the fruits will disappear from that position. Return the maximum total number of fruits you can harvest. Example 1: Input: fruits = [[2,8],[6,3],[8,6]], startPos = 5, k = 4 Output: 9 Explanation: The optimal way is to: - Move right to position 6 and harvest 3 fruits - Move right to position 8 and harvest 6 fruits You moved 3 steps and harvested 3 + 6 = 9 fruits in total. Example 2: Input: fruits = [[0,9],[4,1],[5,7],[6,2],[7,4],[10,9]], startPos = 5, k = 4 Output: 14 Explanation: You can move at most k = 4 steps, so you cannot reach position 0 nor 10. The optimal way is to: - Harvest the 7 fruits at the starting position 5 - Move left to position 4 and harvest 1 fruit - Move right to position 6 and harvest 2 fruits - Move right to position 7 and harvest 4 fruits You moved 1 + 3 = 4 steps and harvested 7 + 1 + 2 + 4 = 14 fruits in total. Example 3: Input: fruits = [[0,3],[6,4],[8,5]], startPos = 3, k = 2 Output: 0 Explanation: You can move at most k = 2 steps and cannot reach any position with fruits. Constraints: 1 <= fruits.length <= 105 fruits[i].length == 2 0 <= startPos, positioni <= 2 * 105 positioni-1 < positioni for any i > 0 (0-indexed) 1 <= amounti <= 104 0 <= k <= 2 * 105", "completion": "class Solution:\\n    def maxTotalFruits(self, fruits: List[List[int]], startPos: int, k: int) -> int:\\n    \\n        fruitMap = defaultdict(int)\\n        \\n        for position, amount in fruits:\\n            fruitMap[position] = amount\\n        \\n        \\n        if k == 0:\\n            return fruitMap[startPos]\\n        \\n        totalLeft = 0 # max sum if we go k steps to the left\\n        totalRight = 0 # max sum if we go k steps to the right\\n        inBetween = 0 # max sum if we go x steps to the left & k steps to the right (ensuring that we don\\'t move more than k steps in total)\\n        \\n        dp = dict()\\n        \\n        for i in range(startPos,startPos-k-1, -1):\\n            totalLeft += fruitMap[i]\\n            dp[i] = totalLeft\\n            \\n        for i in range(startPos,startPos+k+1):\\n            totalRight += fruitMap[i]\\n            dp[i] = totalRight\\n            \\n        \\n        leftSteps = 1\\n        rightSteps = k-2\\n        \\n        while rightSteps > 0:\\n            currAmount = 0\\n            \\n            # go right & collect\\n            currAmount += dp[startPos-leftSteps]\\n            # go left & collect\\n            currAmount += dp[startPos+rightSteps]\\n            \\n            \\n            inBetween = max(inBetween, currAmount-fruitMap[startPos])\\n            \\n            leftSteps += 1\\n            rightSteps -= 2\\n        \\n        \\n        leftSteps = k-2\\n        rightSteps = 1\\n        \\n        while leftSteps > 0:\\n            currAmount = 0\\n            \\n            # go right & collect\\n            currAmount += dp[startPos-leftSteps]\\n            # go left & collect\\n            currAmount += dp[startPos+rightSteps]\\n            \\n            inBetween = max(inBetween, currAmount-fruitMap[startPos])\\n            \\n            leftSteps -= 2\\n            rightSteps += 1\\n        \\n            \\n        return max(totalLeft, totalRight, inBetween)\\n"}
{"prompt": "Write an optimized Python function to solve the following problem: You are given a 0-indexed array arr consisting of n positive integers, and a positive integer k. The array arr is called K-increasing if arr[i-k] <= arr[i] holds for every index i, where k <= i <= n-1. For example, arr = [4, 1, 5, 2, 6, 2] is K-increasing for k = 2 because: arr[0] <= arr[2] (4 <= 5) arr[1] <= arr[3] (1 <= 2) arr[2] <= arr[4] (5 <= 6) arr[3] <= arr[5] (2 <= 2) However, the same arr is not K-increasing for k = 1 (because arr[0] > arr[1]) or k = 3 (because arr[0] > arr[3]). In one operation, you can choose an index i and change arr[i] into any positive integer. Return the minimum number of operations required to make the array K-increasing for the given k. Example 1: Input: arr = [5,4,3,2,1], k = 1 Output: 4 Explanation: For k = 1, the resultant array has to be non-decreasing. Some of the K-increasing arrays that can be formed are [5,6,7,8,9], [1,1,1,1,1], [2,2,3,4,4]. All of them require 4 operations. It is suboptimal to change the array to, for example, [6,7,8,9,10] because it would take 5 operations. It can be shown that we cannot make the array K-increasing in less than 4 operations. Example 2: Input: arr = [4,1,5,2,6,2], k = 2 Output: 0 Explanation: This is the same example as the one in the problem description. Here, for every index i where 2 <= i <= 5, arr[i-2] <= arr[i]. Since the given array is already K-increasing, we do not need to perform any operations. Example 3: Input: arr = [4,1,5,2,6,2], k = 3 Output: 2 Explanation: Indices 3 and 5 are the only ones not satisfying arr[i-3] <= arr[i] for 3 <= i <= 5. One of the ways we can make the array K-increasing is by changing arr[3] to 4 and arr[5] to 5. The array will now be [4,1,5,4,6,5]. Note that there can be other ways to make the array K-increasing, but none of them require less than 2 operations. Constraints: 1 <= arr.length <= 105 1 <= arr[i], k <= arr.length", "completion": "class Solution:\\n    def kIncreasing(self, arr: List[int], k: int) -> int:\\n        \\n        def fn(sub): \\n            \"\"\"Return ops to make sub non-decreasing.\"\"\"\\n            vals = []\\n            for x in sub: \\n                k = bisect_right(vals, x)\\n                if k == len(vals): vals.append(x)\\n                else: vals[k] = x\\n            return len(sub) - len(vals)\\n        \\n        return sum(fn(arr[i:len(arr):k]) for i in range(k))\\n"}
{"prompt": "Write an optimized Python function to solve the following problem: You are given two positive integers left and right with left <= right. Calculate the product of all integers in the inclusive range [left, right]. Since the product may be very large, you will abbreviate it following these steps: Count all trailing zeros in the product and remove them. Let us denote this count as C. For example, there are 3 trailing zeros in 1000, and there are 0 trailing zeros in 546. Denote the remaining number of digits in the product as d. If d > 10, then express the product as ... where denotes the first 5 digits of the product, and denotes the last 5 digits of the product after removing all trailing zeros. If d <= 10, we keep it unchanged. For example, we express 1234567654321 as 12345...54321, but 1234567 is represented as 1234567. Finally, represent the product as a string \"...eC\". For example, 12345678987600000 will be represented as \"12345...89876e5\". Return a string denoting the abbreviated product of all integers in the inclusive range [left, right]. Example 1: Input: left = 1, right = 4 Output: \"24e0\" Explanation: The product is 1 \u00d7 2 \u00d7 3 \u00d7 4 = 24. There are no trailing zeros, so 24 remains the same. The abbreviation will end with \"e0\". Since the number of digits is 2, which is less than 10, we do not have to abbreviate it further. Thus, the final representation is \"24e0\". Example 2: Input: left = 2, right = 11 Output: \"399168e2\" Explanation: The product is 39916800. There are 2 trailing zeros, which we remove to get 399168. The abbreviation will end with \"e2\". The number of digits after removing the trailing zeros is 6, so we do not abbreviate it further. Hence, the abbreviated product is \"399168e2\". Example 3: Input: left = 371, right = 375 Output: \"7219856259e3\" Explanation: The product is 7219856259000. Constraints: 1 <= left <= right <= 104", "completion": "class Solution:\\n    def abbreviateProduct(self, left: int, right: int) -> str:\\n        ans = prefix = suffix = 1\\n        trailing = 0 \\n        flag = False \\n        for x in range(left, right+1): \\n            if not flag: \\n                ans *= x\\n                while ans % 10 == 0: ans //= 10 \\n                if ans >= 1e10: flag = True \\n            prefix *= x\\n            suffix *= x\\n            while prefix >= 1e12: prefix //= 10 \\n            while suffix % 10 == 0: \\n                trailing += 1\\n                suffix //= 10 \\n            if suffix >= 1e10: suffix %= 10_000_000_000\\n        while prefix >= 100000: prefix //= 10 \\n        suffix %= 100000\\n        if flag: return f\"{prefix}...{suffix:>05}e{trailing}\"\\n        return f\"{ans}e{trailing}\"\\n"}
{"prompt": "Write an optimized Python function to solve the following problem: Alice had a 0-indexed array arr consisting of n positive integers. She chose an arbitrary positive integer k and created two new 0-indexed integer arrays lower and higher in the following manner: lower[i] = arr[i] - k, for every index i where 0 <= i < n higher[i] = arr[i] + k, for every index i where 0 <= i < n Unfortunately, Alice lost all three arrays. However, she remembers the integers that were present in the arrays lower and higher, but not the array each integer belonged to. Help Alice and recover the original array. Given an array nums consisting of 2n integers, where exactly n of the integers were present in lower and the remaining in higher, return the original array arr. In case the answer is not unique, return any valid array. Note: The test cases are generated such that there exists at least one valid array arr. Example 1: Input: nums = [2,10,6,4,8,12] Output: [3,7,11] Explanation: If arr = [3,7,11] and k = 1, we get lower = [2,6,10] and higher = [4,8,12]. Combining lower and higher gives us [2,6,10,4,8,12], which is a permutation of nums. Another valid possibility is that arr = [5,7,9] and k = 3. In that case, lower = [2,4,6] and higher = [8,10,12]. Example 2: Input: nums = [1,1,3,3] Output: [2,2] Explanation: If arr = [2,2] and k = 1, we get lower = [1,1] and higher = [3,3]. Combining lower and higher gives us [1,1,3,3], which is equal to nums. Note that arr cannot be [1,3] because in that case, the only possible way to obtain [1,1,3,3] is with k = 0. This is invalid since k must be positive. Example 3: Input: nums = [5,435] Output: [220] Explanation: The only possible combination is arr = [220] and k = 215. Using them, we get lower = [5] and higher = [435]. Constraints: 2 * n == nums.length 1 <= n <= 1000 1 <= nums[i] <= 109 The test cases are generated such that there exists at least one valid array arr.", "completion": "class Solution:\\n    def recoverArray(self, nums: List[int]) -> List[int]:\\n        nums.sort()\\n        cnt = Counter(nums)\\n        for i in range(1, len(nums)): \\n            diff = nums[i] - nums[0]\\n            if diff and diff&1 == 0: \\n                ans = []\\n                freq = cnt.copy()\\n                for k, v in freq.items(): \\n                    if v: \\n                        if freq[k+diff] < v: break \\n                        ans.extend([k+diff//2]*v)\\n                        freq[k+diff] -= v\\n                else: return ans \\n"}
{"prompt": "Write an optimized Python function to solve the following problem: A company is organizing a meeting and has a list of n employees, waiting to be invited. They have arranged for a large circular table, capable of seating any number of employees. The employees are numbered from 0 to n - 1. Each employee has a favorite person and they will attend the meeting only if they can sit next to their favorite person at the table. The favorite person of an employee is not themself. Given a 0-indexed integer array favorite, where favorite[i] denotes the favorite person of the ith employee, return the maximum number of employees that can be invited to the meeting. Example 1: Input: favorite = [2,2,1,2] Output: 3 Explanation: The above figure shows how the company can invite employees 0, 1, and 2, and seat them at the round table. All employees cannot be invited because employee 2 cannot sit beside employees 0, 1, and 3, simultaneously. Note that the company can also invite employees 1, 2, and 3, and give them their desired seats. The maximum number of employees that can be invited to the meeting is 3. Example 2: Input: favorite = [1,2,0] Output: 3 Explanation: Each employee is the favorite person of at least one other employee, and the only way the company can invite them is if they invite every employee. The seating arrangement will be the same as that in the figure given in example 1: - Employee 0 will sit between employees 2 and 1. - Employee 1 will sit between employees 0 and 2. - Employee 2 will sit between employees 1 and 0. The maximum number of employees that can be invited to the meeting is 3. Example 3: Input: favorite = [3,0,1,4,1] Output: 4 Explanation: The above figure shows how the company will invite employees 0, 1, 3, and 4, and seat them at the round table. Employee 2 cannot be invited because the two spots next to their favorite employee 1 are taken. So the company leaves them out of the meeting. The maximum number of employees that can be invited to the meeting is 4. Constraints: n == favorite.length 2 <= n <= 105 0 <= favorite[i] <= n - 1 favorite[i] != i", "completion": "class Solution:\\n    def maximumInvitations(self, favorite: List[int]) -> int:\\n        n = len(favorite)\\n        graph = [[] for _ in range(n)]\\n        for i, x in enumerate(favorite): graph[x].append(i)\\n        \\n        def bfs(x, seen): \\n            \"\"\"Return longest arm of x.\"\"\"\\n            ans = 0 \\n            queue = deque([x])\\n            while queue: \\n                for _ in range(len(queue)): \\n                    u = queue.popleft()\\n                    for v in graph[u]: \\n                        if v not in seen: \\n                            seen.add(v)\\n                            queue.append(v)\\n                ans += 1\\n            return ans \\n        \\n        ans = 0 \\n        seen = [False]*n\\n        for i, x in enumerate(favorite): \\n            if favorite[x] == i and not seen[i]: \\n                seen[i] = seen[x] = True \\n                ans += bfs(i, {i, x}) + bfs(x, {i, x})\\n                \\n        dp = [0]*n\\n        for i, x in enumerate(favorite): \\n            if dp[i] == 0: \\n                ii, val = i, 0\\n                memo = {}\\n                while ii not in memo: \\n                    if dp[ii]: \\n                        cycle = dp[ii]\\n                        break\\n                    memo[ii] = val\\n                    val += 1\\n                    ii = favorite[ii]\\n                else: cycle = val - memo[ii]\\n                for k in memo: dp[k] = cycle\\n        return max(ans, max(dp))\\n"}
{"prompt": "Write an optimized Python function to solve the following problem: You are given an m x n binary matrix grid where each cell is either 0 (empty) or 1 (occupied). You are then given stamps of size stampHeight x stampWidth. We want to fit the stamps such that they follow the given restrictions and requirements: Cover all the empty cells. Do not cover any of the occupied cells. We can put as many stamps as we want. Stamps can overlap with each other. Stamps are not allowed to be rotated. Stamps must stay completely inside the grid. Return true if it is possible to fit the stamps while following the given restrictions and requirements. Otherwise, return false. Example 1: Input: grid = [[1,0,0,0],[1,0,0,0],[1,0,0,0],[1,0,0,0],[1,0,0,0]], stampHeight = 4, stampWidth = 3 Output: true Explanation: We have two overlapping stamps (labeled 1 and 2 in the image) that are able to cover all the empty cells. Example 2: Input: grid = [[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]], stampHeight = 2, stampWidth = 2 Output: false Explanation: There is no way to fit the stamps onto all the empty cells without the stamps going outside the grid. Constraints: m == grid.length n == grid[r].length 1 <= m, n <= 105 1 <= m * n <= 2 * 105 grid[r][c] is either 0 or 1. 1 <= stampHeight, stampWidth <= 105", "completion": "class Solution:\\n    def possibleToStamp(self, grid, H, W):\\n        def acc_2d(grid):\\n            dp = [[0] * (n+1) for _ in range(m+1)] \\n            for c, r in product(range(n), range(m)):\\n                dp[r+1][c+1] = dp[r+1][c] + dp[r][c+1] - dp[r][c] + grid[r][c]\\n            return dp\\n\\n        def sumRegion(r1, c1, r2, c2):\\n            return dp[r2+1][c2+1] - dp[r1][c2+1] - dp[r2+1][c1] + dp[r1][c1]  \\n\\n        m, n = len(grid), len(grid[0])\\n        dp = acc_2d(grid)\\n\\n        diff = [[0] * (n+1) for _ in range(m+1)] \\n        for c in range(n - W + 1):\\n            for r in range(m - H + 1):\\n                if sumRegion(r, c, r + H - 1, c + W - 1) == 0:\\n                    diff[r][c] += 1\\n                    diff[r][c+W] -= 1\\n                    diff[r+H][c] -= 1\\n                    diff[r+H][c+W] += 1\\n        \\n        dp2 = acc_2d(diff)\\n        for c, r in product(range(n), range(m)):\\n            if dp2[r+1][c+1] == 0 and grid[r][c] != 1: return False\\n\\n        return True\\n"}
{"prompt": "Write an optimized Python function to solve the following problem: You have n flower seeds. Every seed must be planted first before it can begin to grow, then bloom. Planting a seed takes time and so does the growth of a seed. You are given two 0-indexed integer arrays plantTime and growTime, of length n each: plantTime[i] is the number of full days it takes you to plant the ith seed. Every day, you can work on planting exactly one seed. You do not have to work on planting the same seed on consecutive days, but the planting of a seed is not complete until you have worked plantTime[i] days on planting it in total. growTime[i] is the number of full days it takes the ith seed to grow after being completely planted. After the last day of its growth, the flower blooms and stays bloomed forever. From the beginning of day 0, you can plant the seeds in any order. Return the earliest possible day where all seeds are blooming. Example 1: Input: plantTime = [1,4,3], growTime = [2,3,1] Output: 9 Explanation: The grayed out pots represent planting days, colored pots represent growing days, and the flower represents the day it blooms. One optimal way is: On day 0, plant the 0th seed. The seed grows for 2 full days and blooms on day 3. On days 1, 2, 3, and 4, plant the 1st seed. The seed grows for 3 full days and blooms on day 8. On days 5, 6, and 7, plant the 2nd seed. The seed grows for 1 full day and blooms on day 9. Thus, on day 9, all the seeds are blooming. Example 2: Input: plantTime = [1,2,3,2], growTime = [2,1,2,1] Output: 9 Explanation: The grayed out pots represent planting days, colored pots represent growing days, and the flower represents the day it blooms. One optimal way is: On day 1, plant the 0th seed. The seed grows for 2 full days and blooms on day 4. On days 0 and 3, plant the 1st seed. The seed grows for 1 full day and blooms on day 5. On days 2, 4, and 5, plant the 2nd seed. The seed grows for 2 full days and blooms on day 8. On days 6 and 7, plant the 3rd seed. The seed grows for 1 full day and blooms on day 9. Thus, on day 9, all the seeds are blooming. Example 3: Input: plantTime = [1], growTime = [1] Output: 2 Explanation: On day 0, plant the 0th seed. The seed grows for 1 full day and blooms on day 2. Thus, on day 2, all the seeds are blooming. Constraints: n == plantTime.length == growTime.length 1 <= n <= 105 1 <= plantTime[i], growTime[i] <= 104", "completion": "class Solution:\\n    def earliestFullBloom(self, plantTime: List[int], growTime: List[int]) -> int:\\n        res = 0\\n        for grow, plant in sorted(zip(growTime, plantTime)):\\n            res = max(res, grow) + plant\\n        return res\\n"}
{"prompt": "Write an optimized Python function to solve the following problem: You have n computers. You are given the integer n and a 0-indexed integer array batteries where the ith battery can run a computer for batteries[i] minutes. You are interested in running all n computers simultaneously using the given batteries. Initially, you can insert at most one battery into each computer. After that and at any integer time moment, you can remove a battery from a computer and insert another battery any number of times. The inserted battery can be a totally new battery or a battery from another computer. You may assume that the removing and inserting processes take no time. Note that the batteries cannot be recharged. Return the maximum number of minutes you can run all the n computers simultaneously. Example 1: Input: n = 2, batteries = [3,3,3] Output: 4 Explanation: Initially, insert battery 0 into the first computer and battery 1 into the second computer. After two minutes, remove battery 1 from the second computer and insert battery 2 instead. Note that battery 1 can still run for one minute. At the end of the third minute, battery 0 is drained, and you need to remove it from the first computer and insert battery 1 instead. By the end of the fourth minute, battery 1 is also drained, and the first computer is no longer running. We can run the two computers simultaneously for at most 4 minutes, so we return 4. Example 2: Input: n = 2, batteries = [1,1,1,1] Output: 2 Explanation: Initially, insert battery 0 into the first computer and battery 2 into the second computer. After one minute, battery 0 and battery 2 are drained so you need to remove them and insert battery 1 into the first computer and battery 3 into the second computer. After another minute, battery 1 and battery 3 are also drained so the first and second computers are no longer running. We can run the two computers simultaneously for at most 2 minutes, so we return 2. Constraints: 1 <= n <= batteries.length <= 105 1 <= batteries[i] <= 109", "completion": "class Solution:\\n    def maxRunTime(self, n: int, batteries: List[int]) -> int:\\n        batteries.sort()\\n        extra = sum(batteries[:-n])\\n        batteries = batteries[-n:]\\n        \\n        ans = prefix = 0 \\n        for i, x in enumerate(batteries): \\n            prefix += x \\n            if i+1 < len(batteries) and batteries[i+1]*(i+1) - prefix > extra: return (prefix + extra) // (i+1)\\n        return (prefix + extra) // n\\n"}
{"prompt": "Write an optimized Python function to solve the following problem: Along a long library corridor, there is a line of seats and decorative plants. You are given a 0-indexed string corridor of length n consisting of letters 'S' and 'P' where each 'S' represents a seat and each 'P' represents a plant. One room divider has already been installed to the left of index 0, and another to the right of index n - 1. Additional room dividers can be installed. For each position between indices i - 1 and i (1 <= i <= n - 1), at most one divider can be installed. Divide the corridor into non-overlapping sections, where each section has exactly two seats with any number of plants. There may be multiple ways to perform the division. Two ways are different if there is a position with a room divider installed in the first way but not in the second way. Return the number of ways to divide the corridor. Since the answer may be very large, return it modulo 109 + 7. If there is no way, return 0. Example 1: Input: corridor = \"SSPPSPS\" Output: 3 Explanation: There are 3 different ways to divide the corridor. The black bars in the above image indicate the two room dividers already installed. Note that in each of the ways, each section has exactly two seats. Example 2: Input: corridor = \"PPSPSP\" Output: 1 Explanation: There is only 1 way to divide the corridor, by not installing any additional dividers. Installing any would create some section that does not have exactly two seats. Example 3: Input: corridor = \"S\" Output: 0 Explanation: There is no way to divide the corridor because there will always be a section that does not have exactly two seats. Constraints: n == corridor.length 1 <= n <= 105 corridor[i] is either 'S' or 'P'.", "completion": "class Solution:\\n    def numberOfWays(self, corridor):\\n        seat, res, plant = 0, 1, 0\\n        for i in corridor:\\n            if i==\\'S\\':\\n                seat += 1\\n            else:\\n                if seat == 2:\\n                    plant += 1\\n            if seat == 3:\\n                res = res*(plant+1) % (10**9 + 7)\\n                seat , plant = 1 , 0\\n        if seat != 2:\\n            return 0\\n        return res\\n"}
{"prompt": "Write an optimized Python function to solve the following problem: There are two types of persons: The good person: The person who always tells the truth. The bad person: The person who might tell the truth and might lie. You are given a 0-indexed 2D integer array statements of size n x n that represents the statements made by n people about each other. More specifically, statements[i][j] could be one of the following: 0 which represents a statement made by person i that person j is a bad person. 1 which represents a statement made by person i that person j is a good person. 2 represents that no statement is made by person i about person j. Additionally, no person ever makes a statement about themselves. Formally, we have that statements[i][i] = 2 for all 0 <= i < n. Return the maximum number of people who can be good based on the statements made by the n people. Example 1: Input: statements = [[2,1,2],[1,2,2],[2,0,2]] Output: 2 Explanation: Each person makes a single statement. - Person 0 states that person 1 is good. - Person 1 states that person 0 is good. - Person 2 states that person 1 is bad. Let's take person 2 as the key. - Assuming that person 2 is a good person: - Based on the statement made by person 2, person 1 is a bad person. - Now we know for sure that person 1 is bad and person 2 is good. - Based on the statement made by person 1, and since person 1 is bad, they could be: - telling the truth. There will be a contradiction in this case and this assumption is invalid. - lying. In this case, person 0 is also a bad person and lied in their statement. - Following that person 2 is a good person, there will be only one good person in the group. - Assuming that person 2 is a bad person: - Based on the statement made by person 2, and since person 2 is bad, they could be: - telling the truth. Following this scenario, person 0 and 1 are both bad as explained before. - Following that person 2 is bad but told the truth, there will be no good persons in the group. - lying. In this case person 1 is a good person. - Since person 1 is a good person, person 0 is also a good person. - Following that person 2 is bad and lied, there will be two good persons in the group. We can see that at most 2 persons are good in the best case, so we return 2. Note that there is more than one way to arrive at this conclusion. Example 2: Input: statements = [[2,0],[0,2]] Output: 1 Explanation: Each person makes a single statement. - Person 0 states that person 1 is bad. - Person 1 states that person 0 is bad. Let's take person 0 as the key. - Assuming that person 0 is a good person: - Based on the statement made by person 0, person 1 is a bad person and was lying. - Following that person 0 is a good person, there will be only one good person in the group. - Assuming that person 0 is a bad person: - Based on the statement made by person 0, and since person 0 is bad, they could be: - telling the truth. Following this scenario, person 0 and 1 are both bad. - Following that person 0 is bad but told the truth, there will be no good persons in the group. - lying. In this case person 1 is a good person. - Following that person 0 is bad and lied, there will be only one good person in the group. We can see that at most, one person is good in the best case, so we return 1. Note that there is more than one way to arrive at this conclusion. Constraints: n == statements.length == statements[i].length 2 <= n <= 15 statements[i][j] is either 0, 1, or 2. statements[i][i] == 2", "completion": "class Solution:        \\n    def maximumGood(self, statements: List[List[int]]) -> int:\\n        \\n        n = len(statements)\\n        res = 0\\n        \\n        def checkGood(person, mask):\\n            if (mask>>person) & 1:\\n                return True\\n            return False\\n        \\n        def validateStatement(mask):\\n            for i in range(n):\\n                if checkGood(i, mask):\\n                    for j in range(n):\\n                        statement = statements[i][j]\\n                        \\n                        if (statement==0 and checkGood(j, mask)) or (statement==1 and not checkGood(j, mask)):\\n                            return False\\n            return True\\n        \\n        for i in range(1,1<<n): \\n            if validateStatement(i):\\n                res = max(res, bin(i).count(\\'1\\'))\\n        return res\\n"}
{"prompt": "Write an optimized Python function to solve the following problem: The hash of a 0-indexed string s of length k, given integers p and m, is computed using the following function: hash(s, p, m) = (val(s[0]) * p0 + val(s[1]) * p1 + ... + val(s[k-1]) * pk-1) mod m. Where val(s[i]) represents the index of s[i] in the alphabet from val('a') = 1 to val('z') = 26. You are given a string s and the integers power, modulo, k, and hashValue. Return sub, the first substring of s of length k such that hash(sub, power, modulo) == hashValue. The test cases will be generated such that an answer always exists. A substring is a contiguous non-empty sequence of characters within a string. Example 1: Input: s = \"leetcode\", power = 7, modulo = 20, k = 2, hashValue = 0 Output: \"ee\" Explanation: The hash of \"ee\" can be computed to be hash(\"ee\", 7, 20) = (5 * 1 + 5 * 7) mod 20 = 40 mod 20 = 0. \"ee\" is the first substring of length 2 with hashValue 0. Hence, we return \"ee\". Example 2: Input: s = \"fbxzaad\", power = 31, modulo = 100, k = 3, hashValue = 32 Output: \"fbx\" Explanation: The hash of \"fbx\" can be computed to be hash(\"fbx\", 31, 100) = (6 * 1 + 2 * 31 + 24 * 312) mod 100 = 23132 mod 100 = 32. The hash of \"bxz\" can be computed to be hash(\"bxz\", 31, 100) = (2 * 1 + 24 * 31 + 26 * 312) mod 100 = 25732 mod 100 = 32. \"fbx\" is the first substring of length 3 with hashValue 32. Hence, we return \"fbx\". Note that \"bxz\" also has a hash of 32 but it appears later than \"fbx\". Constraints: 1 <= k <= s.length <= 2 * 104 1 <= power, modulo <= 109 0 <= hashValue < modulo s consists of lowercase English letters only. The test cases are generated such that an answer always exists.", "completion": "class Solution:\\n\\t\\tdef subStrHash(self, s: str, power: int, modulo: int, k: int, hashValue: int) -> str:\\n\\n\\t\\t\\tsc=0\\n\\t\\t\\ti=len(s)-1\\n\\t\\t\\ta=0\\n\\t\\t\\tm = (power**k)%modulo\\n\\n\\t\\t\\twhile i>-1:\\n\\n\\t\\t\\t\\tsc=(sc*power + ord(s[i])-97+1)%modulo\\n\\n\\t\\t\\t\\tif i+k<len(s):\\n\\t\\t\\t\\t\\tsc=(sc-((ord(s[i+k])-97+1)*m))%modulo\\n\\n\\t\\t\\t\\tif sc==hashValue:\\n\\t\\t\\t\\t\\ta=i\\n\\t\\t\\t\\ti=i-1\\n\\n\\t\\t\\treturn s[a:a+k]\\n\\n\\n"}
{"prompt": "Write an optimized Python function to solve the following problem: You are given a 0-indexed array of strings words. Each string consists of lowercase English letters only. No letter occurs more than once in any string of words. Two strings s1 and s2 are said to be connected if the set of letters of s2 can be obtained from the set of letters of s1 by any one of the following operations: Adding exactly one letter to the set of the letters of s1. Deleting exactly one letter from the set of the letters of s1. Replacing exactly one letter from the set of the letters of s1 with any letter, including itself. The array words can be divided into one or more non-intersecting groups. A string belongs to a group if any one of the following is true: It is connected to at least one other string of the group. It is the only string present in the group. Note that the strings in words should be grouped in such a manner that a string belonging to a group cannot be connected to a string present in any other group. It can be proved that such an arrangement is always unique. Return an array ans of size 2 where: ans[0] is the maximum number of groups words can be divided into, and ans[1] is the size of the largest group. Example 1: Input: words = [\"a\",\"b\",\"ab\",\"cde\"] Output: [2,3] Explanation: - words[0] can be used to obtain words[1] (by replacing 'a' with 'b'), and words[2] (by adding 'b'). So words[0] is connected to words[1] and words[2]. - words[1] can be used to obtain words[0] (by replacing 'b' with 'a'), and words[2] (by adding 'a'). So words[1] is connected to words[0] and words[2]. - words[2] can be used to obtain words[0] (by deleting 'b'), and words[1] (by deleting 'a'). So words[2] is connected to words[0] and words[1]. - words[3] is not connected to any string in words. Thus, words can be divided into 2 groups [\"a\",\"b\",\"ab\"] and [\"cde\"]. The size of the largest group is 3. Example 2: Input: words = [\"a\",\"ab\",\"abc\"] Output: [1,3] Explanation: - words[0] is connected to words[1]. - words[1] is connected to words[0] and words[2]. - words[2] is connected to words[1]. Since all strings are connected to each other, they should be grouped together. Thus, the size of the largest group is 3. Constraints: 1 <= words.length <= 2 * 104 1 <= words[i].length <= 26 words[i] consists of lowercase English letters only. No letter occurs more than once in words[i].", "completion": "class Solution:\\n    def groupStrings(self, words: List[str]) -> List[int]:\\n        n = len(words)\\n        uf = UnionFind(n)\\n        seen = {}\\n        for i, word in enumerate(words): \\n            m = reduce(or_, (1<<ord(ch)-97 for ch in word))\\n            if m in seen: uf.union(i, seen[m])\\n            for k in range(26): \\n                if m ^ 1<<k in seen: uf.union(i, seen[m ^ 1<<k])\\n                if m & 1<<k: \\n                    mm = m ^ 1<<k ^ 1<<26\\n                    if mm in seen: uf.union(i, seen[mm])\\n                    seen[mm] = i\\n            seen[m] = i \\n        freq = Counter(uf.find(i) for i in range(n))\\n        return [len(freq), max(freq.values())]\\n"}
{"prompt": "Write an optimized Python function to solve the following problem: You are given a 0-indexed integer array nums consisting of 3 * n elements. You are allowed to remove any subsequence of elements of size exactly n from nums. The remaining 2 * n elements will be divided into two equal parts: The first n elements belonging to the first part and their sum is sumfirst. The next n elements belonging to the second part and their sum is sumsecond. The difference in sums of the two parts is denoted as sumfirst - sumsecond. For example, if sumfirst = 3 and sumsecond = 2, their difference is 1. Similarly, if sumfirst = 2 and sumsecond = 3, their difference is -1. Return the minimum difference possible between the sums of the two parts after the removal of n elements. Example 1: Input: nums = [3,1,2] Output: -1 Explanation: Here, nums has 3 elements, so n = 1. Thus we have to remove 1 element from nums and divide the array into two equal parts. - If we remove nums[0] = 3, the array will be [1,2]. The difference in sums of the two parts will be 1 - 2 = -1. - If we remove nums[1] = 1, the array will be [3,2]. The difference in sums of the two parts will be 3 - 2 = 1. - If we remove nums[2] = 2, the array will be [3,1]. The difference in sums of the two parts will be 3 - 1 = 2. The minimum difference between sums of the two parts is min(-1,1,2) = -1. Example 2: Input: nums = [7,9,5,8,1,3] Output: 1 Explanation: Here n = 2. So we must remove 2 elements and divide the remaining array into two parts containing two elements each. If we remove nums[2] = 5 and nums[3] = 8, the resultant array will be [7,9,1,3]. The difference in sums will be (7+9) - (1+3) = 12. To obtain the minimum difference, we should remove nums[1] = 9 and nums[4] = 1. The resultant array becomes [7,5,8,3]. The difference in sums of the two parts is (7+5) - (8+3) = 1. It can be shown that it is not possible to obtain a difference smaller than 1. Constraints: nums.length == 3 * n 1 <= n <= 105 1 <= nums[i] <= 105", "completion": "class Solution:\\n    def minimumDifference(self, nums: List[int]) -> int:\\n        n = len(nums) // 3\\n\\n        # calculate max_sum using min_heap for second part\\n        min_heap = nums[(2 * n) :]\\n        heapq.heapify(min_heap)\\n\\n        max_sum = [0] * (n + 2)\\n        max_sum[n + 1] = sum(min_heap)\\n        for i in range((2 * n) - 1, n - 1, -1):\\n            # push current\\n            heapq.heappush(min_heap, nums[i])\\n            # popout minimum from heap\\n            val = heapq.heappop(min_heap)\\n            # max_sum for this partition\\n            max_sum[i - n + 1] = max_sum[i - n + 2] - val + nums[i]\\n\\n\\n        # calculate min_sum using max_heap for first part\\n        max_heap = [-x for x in nums[:n]]\\n        heapq.heapify(max_heap)\\n\\n        min_sum = [0] * (n + 2)\\n        min_sum[0] = -sum(max_heap)\\n        for i in range(n, (2 * n)):\\n            # push current\\n            heapq.heappush(max_heap, -nums[i])\\n            # popout maximum from heap\\n            val = -heapq.heappop(max_heap)\\n            # min_sum for this partition\\n            min_sum[i - n + 1] = min_sum[i - n] - val + nums[i]\\n\\n\\n        # find min difference bw second part (max_sum) and first part (min_sum)\\n        ans = math.inf\\n        for i in range(0, n + 1):\\n            print(i, min_sum[i], max_sum[i])\\n            ans = min((min_sum[i] - max_sum[i + 1]), ans)\\n\\n        return ans\\n\\n"}
{"prompt": "Write an optimized Python function to solve the following problem: You are given a 0-indexed binary string s which represents a sequence of train cars. s[i] = '0' denotes that the ith car does not contain illegal goods and s[i] = '1' denotes that the ith car does contain illegal goods. As the train conductor, you would like to get rid of all the cars containing illegal goods. You can do any of the following three operations any number of times: Remove a train car from the left end (i.e., remove s[0]) which takes 1 unit of time. Remove a train car from the right end (i.e., remove s[s.length - 1]) which takes 1 unit of time. Remove a train car from anywhere in the sequence which takes 2 units of time. Return the minimum time to remove all the cars containing illegal goods. Note that an empty sequence of cars is considered to have no cars containing illegal goods. Example 1: Input: s = \"1100101\" Output: 5 Explanation: One way to remove all the cars containing illegal goods from the sequence is to - remove a car from the left end 2 times. Time taken is 2 * 1 = 2. - remove a car from the right end. Time taken is 1. - remove the car containing illegal goods found in the middle. Time taken is 2. This obtains a total time of 2 + 1 + 2 = 5. An alternative way is to - remove a car from the left end 2 times. Time taken is 2 * 1 = 2. - remove a car from the right end 3 times. Time taken is 3 * 1 = 3. This also obtains a total time of 2 + 3 = 5. 5 is the minimum time taken to remove all the cars containing illegal goods. There are no other ways to remove them with less time. Example 2: Input: s = \"0010\" Output: 2 Explanation: One way to remove all the cars containing illegal goods from the sequence is to - remove a car from the left end 3 times. Time taken is 3 * 1 = 3. This obtains a total time of 3. Another way to remove all the cars containing illegal goods from the sequence is to - remove the car containing illegal goods found in the middle. Time taken is 2. This obtains a total time of 2. Another way to remove all the cars containing illegal goods from the sequence is to - remove a car from the right end 2 times. Time taken is 2 * 1 = 2. This obtains a total time of 2. 2 is the minimum time taken to remove all the cars containing illegal goods. There are no other ways to remove them with less time. Constraints: 1 <= s.length <= 2 * 105 s[i] is either '0' or '1'.", "completion": "class Solution:\\n    def minimumTime(self, s):\\n        left, res, n = 0, len(s), len(s)\\n        lefts = []\\n        for i,c in enumerate(s):\\n            left = min(left + (c == \\'1\\') * 2, i + 1)\\n            lefts.append(left)\\n        right = 0\\n        rights = []\\n        for i,c in enumerate(s[::-1]):\\n            right = min(right + (c == \\'1\\') * 2, i + 1)\\n            rights.append(right)   \\n        rights = rights[::-1]\\n        res = rights[0]\\n        for i in range(n-1):\\n            res = min(res,lefts[i]+rights[i+1])        \\n        res = min(res,lefts[n-1])\\n        return res\\n"}
{"prompt": "Write an optimized Python function to solve the following problem: You are given an integer array nums of length n and an integer numSlots such that 2 * numSlots >= n. There are numSlots slots numbered from 1 to numSlots. You have to place all n integers into the slots such that each slot contains at most two numbers. The AND sum of a given placement is the sum of the bitwise AND of every number with its respective slot number. For example, the AND sum of placing the numbers [1, 3] into slot 1 and [4, 6] into slot 2 is equal to (1 AND 1) + (3 AND 1) + (4 AND 2) + (6 AND 2) = 1 + 1 + 0 + 2 = 4. Return the maximum possible AND sum of nums given numSlots slots. Example 1: Input: nums = [1,2,3,4,5,6], numSlots = 3 Output: 9 Explanation: One possible placement is [1, 4] into slot 1, [2, 6] into slot 2, and [3, 5] into slot 3. This gives the maximum AND sum of (1 AND 1) + (4 AND 1) + (2 AND 2) + (6 AND 2) + (3 AND 3) + (5 AND 3) = 1 + 0 + 2 + 2 + 3 + 1 = 9. Example 2: Input: nums = [1,3,10,4,7,1], numSlots = 9 Output: 24 Explanation: One possible placement is [1, 1] into slot 1, [3] into slot 3, [4] into slot 4, [7] into slot 7, and [10] into slot 9. This gives the maximum AND sum of (1 AND 1) + (1 AND 1) + (3 AND 3) + (4 AND 4) + (7 AND 7) + (10 AND 9) = 1 + 1 + 3 + 4 + 7 + 8 = 24. Note that slots 2, 5, 6, and 8 are empty which is permitted. Constraints: n == nums.length 1 <= numSlots <= 9 1 <= n <= 2 * numSlots 1 <= nums[i] <= 15", "completion": "class Solution:\\n    def maximumANDSum(self, nums: List[int], numSlots: int) -> int:\\n        \\n        @cache\\n        def fn(k, m): \\n            \"\"\"Return max AND sum.\"\"\"\\n            if k == len(nums): return 0 \\n            ans = 0 \\n            for i in range(numSlots): \\n                if m & 1<<2*i == 0 or m & 1<<2*i+1 == 0: \\n                    if m & 1<<2*i == 0: mm = m ^ 1<<2*i\\n                    else: mm = m ^ 1<<2*i+1\\n                    ans = max(ans, (nums[k] & i+1) + fn(k+1, mm))\\n            return ans \\n        \\n        return fn(0, 0)\\n"}
{"prompt": "Write an optimized Python function to solve the following problem: You are given two 0-indexed arrays nums1 and nums2 of length n, both of which are permutations of [0, 1, ..., n - 1]. A good triplet is a set of 3 distinct values which are present in increasing order by position both in nums1 and nums2. In other words, if we consider pos1v as the index of the value v in nums1 and pos2v as the index of the value v in nums2, then a good triplet will be a set (x, y, z) where 0 <= x, y, z <= n - 1, such that pos1x < pos1y < pos1z and pos2x < pos2y < pos2z. Return the total number of good triplets. Example 1: Input: nums1 = [2,0,1,3], nums2 = [0,1,2,3] Output: 1 Explanation: There are 4 triplets (x,y,z) such that pos1x < pos1y < pos1z. They are (2,0,1), (2,0,3), (2,1,3), and (0,1,3). Out of those triplets, only the triplet (0,1,3) satisfies pos2x < pos2y < pos2z. Hence, there is only 1 good triplet. Example 2: Input: nums1 = [4,0,1,3,2], nums2 = [4,1,0,2,3] Output: 4 Explanation: The 4 good triplets are (4,0,3), (4,0,2), (4,1,3), and (4,1,2). Constraints: n == nums1.length == nums2.length 3 <= n <= 105 0 <= nums1[i], nums2[i] <= n - 1 nums1 and nums2 are permutations of [0, 1, ..., n - 1].", "completion": "class Solution:\\n    def goodTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        n = len(nums1)\\n        hashmap2 = {}\\n        for i in range(n):\\n            hashmap2[nums2[i]] = i\\n        indices = []\\n        for num in nums1:\\n            indices.append(hashmap2[num])\\n        from sortedcontainers import SortedList\\n        left, right = SortedList(), SortedList()\\n        leftCount, rightCount = [], []\\n        for i in range(n):\\n            leftCount.append(left.bisect_left(indices[i]))\\n            left.add(indices[i])\\n        for i in range(n - 1, -1, -1):\\n            rightCount.append(len(right) - right.bisect_right(indices[i]))\\n            right.add(indices[i])\\n        count = 0\\n        for i in range(n):\\n            count += leftCount[i] * rightCount[n - 1 - i]\\n        return count\\n"}
{"prompt": "Write an optimized Python function to solve the following problem: Given a 0-indexed integer array nums of length n and an integer k, return the number of pairs (i, j) such that: 0 <= i < j <= n - 1 and nums[i] * nums[j] is divisible by k. Example 1: Input: nums = [1,2,3,4,5], k = 2 Output: 7 Explanation: The 7 pairs of indices whose corresponding products are divisible by 2 are (0, 1), (0, 3), (1, 2), (1, 3), (1, 4), (2, 3), and (3, 4). Their products are 2, 4, 6, 8, 10, 12, and 20 respectively. Other pairs such as (0, 2) and (2, 4) have products 3 and 15 respectively, which are not divisible by 2. Example 2: Input: nums = [1,2,3,4], k = 5 Output: 0 Explanation: There does not exist any pair of indices whose corresponding product is divisible by 5. Constraints: 1 <= nums.length <= 105 1 <= nums[i], k <= 105", "completion": "class Solution:\\n    def countPairs(self, nums: List[int], k: int) -> int:\\n        counter = Counter() #hashmap dicitionary of python\\n        ans = 0\\n        n = len(nums)\\n        \\n        for i in range(n):\\n            x = math.gcd(k,nums[i]) #ex: 10 = k and we have nums[i] as 12 so gcd will be 2\\n            want = k // x #what do we want from upper ex: we need 5\\n            for num in counter:\\n                if num % want == 0: #so if we find a number that is divisible by 5 then we can multiply it to 12 and make it a factor of 10 for ex we find 20 so it will be 240 which is divisible by 10 hence we will add it to answer\\n                    ans += counter[num] #we are adding the freq as we can find no of numbers that have same factor\\n            counter[x] += 1 #here we are increasing the freq of 2 so that if we find 5 next time we can add these to the answer\\n        return ans\\n"}
{"prompt": "Write an optimized Python function to solve the following problem: You are given a 0-indexed 2D integer array tires where tires[i] = [fi, ri] indicates that the ith tire can finish its xth successive lap in fi * ri(x-1) seconds. For example, if fi = 3 and ri = 2, then the tire would finish its 1st lap in 3 seconds, its 2nd lap in 3 * 2 = 6 seconds, its 3rd lap in 3 * 22 = 12 seconds, etc. You are also given an integer changeTime and an integer numLaps. The race consists of numLaps laps and you may start the race with any tire. You have an unlimited supply of each tire and after every lap, you may change to any given tire (including the current tire type) if you wait changeTime seconds. Return the minimum time to finish the race. Example 1: Input: tires = [[2,3],[3,4]], changeTime = 5, numLaps = 4 Output: 21 Explanation: Lap 1: Start with tire 0 and finish the lap in 2 seconds. Lap 2: Continue with tire 0 and finish the lap in 2 * 3 = 6 seconds. Lap 3: Change tires to a new tire 0 for 5 seconds and then finish the lap in another 2 seconds. Lap 4: Continue with tire 0 and finish the lap in 2 * 3 = 6 seconds. Total time = 2 + 6 + 5 + 2 + 6 = 21 seconds. The minimum time to complete the race is 21 seconds. Example 2: Input: tires = [[1,10],[2,2],[3,4]], changeTime = 6, numLaps = 5 Output: 25 Explanation: Lap 1: Start with tire 1 and finish the lap in 2 seconds. Lap 2: Continue with tire 1 and finish the lap in 2 * 2 = 4 seconds. Lap 3: Change tires to a new tire 1 for 6 seconds and then finish the lap in another 2 seconds. Lap 4: Continue with tire 1 and finish the lap in 2 * 2 = 4 seconds. Lap 5: Change tires to tire 0 for 6 seconds then finish the lap in another 1 second. Total time = 2 + 4 + 6 + 2 + 4 + 6 + 1 = 25 seconds. The minimum time to complete the race is 25 seconds. Constraints: 1 <= tires.length <= 105 tires[i].length == 2 1 <= fi, changeTime <= 105 2 <= ri <= 105 1 <= numLaps <= 1000", "completion": "class Solution:\\n    def minimumFinishTime(self, tires: List[List[int]], changeTime: int, numLaps: int) -> int:\\n        tires.sort()\\n        newTires = []\\n        minTime = [changeTime*(i-1) + tires[0][0]*i for i in range(numLaps+1)]\\n        minTime[0] = 0\\n        maxi = 0\\n        for f,r in tires:\\n            if not newTires or f>newTires[-1][0] and r<newTires[-1][1]:\\n                newTires.append([f,r])\\n                t = f\\n                i = 1\\n                while i<numLaps and t*(r-1)<changeTime:\\n                    t = t*r + f\\n                    i += 1\\n                    if minTime[i]>t:\\n                        minTime[i]=t\\n                        maxi = max(i,maxi)\\n        for lap in range(numLaps+1):\\n            for run in range(min(lap,maxi+1)):\\n                minTime[lap] = min(minTime[lap],minTime[lap-run]+changeTime+minTime[run])\\n        return minTime[numLaps]\\n"}
{"prompt": "Write an optimized Python function to solve the following problem: You are given a string s consisting only of lowercase English letters. In one move, you can select any two adjacent characters of s and swap them. Return the minimum number of moves needed to make s a palindrome. Note that the input will be generated such that s can always be converted to a palindrome. Example 1: Input: s = \"aabb\" Output: 2 Explanation: We can obtain two palindromes from s, \"abba\" and \"baab\". - We can obtain \"abba\" from s in 2 moves: \"aabb\" -> \"abab\" -> \"abba\". - We can obtain \"baab\" from s in 2 moves: \"aabb\" -> \"abab\" -> \"baab\". Thus, the minimum number of moves needed to make s a palindrome is 2. Example 2: Input: s = \"letelt\" Output: 2 Explanation: One of the palindromes we can obtain from s in 2 moves is \"lettel\". One of the ways we can obtain it is \"letelt\" -> \"letetl\" -> \"lettel\". Other palindromes such as \"tleelt\" can also be obtained in 2 moves. It can be shown that it is not possible to obtain a palindrome in less than 2 moves. Constraints: 1 <= s.length <= 2000 s consists only of lowercase English letters. s can be converted to a palindrome using a finite number of moves.", "completion": "class Solution:\\n\\t\\tdef minMovesToMakePalindrome(self, s: str) -> int:\\n\\t\\t\\ts = list(s) #makes it easy for assignment op\\n\\n\\t\\t\\tres = 0\\n\\t\\t\\tleft, right = 0, len(s) - 1\\n\\n\\t\\t\\twhile left < right:\\n\\t\\t\\t\\tl, r = left, right\\n\\n\\t\\t\\t\\t#find matching char\\n\\t\\t\\t\\twhile s[l] != s[r]:\\n\\t\\t\\t\\t\\tr -= 1\\n\\n\\t\\t\\t\\t# if index dont match then swap\\n\\t\\t\\t\\tif l != r:\\n\\t\\t\\t\\t\\t# swap one by one\\n\\t\\t\\t\\t\\twhile r < right:\\n\\t\\t\\t\\t\\t\\ts[r], s[r + 1] = s[r + 1], s[r]\\n\\t\\t\\t\\t\\t\\tres += 1\\n\\t\\t\\t\\t\\t\\tr += 1\\n\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\ts[r], s[r + 1] = s[r + 1], s[r]\\n\\t\\t\\t\\t\\tres += 1\\n\\t\\t\\t\\t\\tcontinue # get outside the main while loop\\n\\n\\t\\t\\t\\tleft += 1\\n\\t\\t\\t\\tright -= 1\\n\\n\\t\\t\\treturn res"}
{"prompt": "Write an optimized Python function to solve the following problem: You are given an array of integers nums. Perform the following steps: Find any two adjacent numbers in nums that are non-coprime. If no such numbers are found, stop the process. Otherwise, delete the two numbers and replace them with their LCM (Least Common Multiple). Repeat this process as long as you keep finding two adjacent non-coprime numbers. Return the final modified array. It can be shown that replacing adjacent non-coprime numbers in any arbitrary order will lead to the same result. The test cases are generated such that the values in the final array are less than or equal to 108. Two values x and y are non-coprime if GCD(x, y) > 1 where GCD(x, y) is the Greatest Common Divisor of x and y. Example 1: Input: nums = [6,4,3,2,7,6,2] Output: [12,7,6] Explanation: - (6, 4) are non-coprime with LCM(6, 4) = 12. Now, nums = [12,3,2,7,6,2]. - (12, 3) are non-coprime with LCM(12, 3) = 12. Now, nums = [12,2,7,6,2]. - (12, 2) are non-coprime with LCM(12, 2) = 12. Now, nums = [12,7,6,2]. - (6, 2) are non-coprime with LCM(6, 2) = 6. Now, nums = [12,7,6]. There are no more adjacent non-coprime numbers in nums. Thus, the final modified array is [12,7,6]. Note that there are other ways to obtain the same resultant array. Example 2: Input: nums = [2,2,1,1,3,3,3] Output: [2,1,1,3] Explanation: - (3, 3) are non-coprime with LCM(3, 3) = 3. Now, nums = [2,2,1,1,3,3]. - (3, 3) are non-coprime with LCM(3, 3) = 3. Now, nums = [2,2,1,1,3]. - (2, 2) are non-coprime with LCM(2, 2) = 2. Now, nums = [2,1,1,3]. There are no more adjacent non-coprime numbers in nums. Thus, the final modified array is [2,1,1,3]. Note that there are other ways to obtain the same resultant array. Constraints: 1 <= nums.length <= 105 1 <= nums[i] <= 105 The test cases are generated such that the values in the final array are less than or equal to 108.", "completion": "class Solution:\\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n        stack = []\\n        for i in nums:\\n            toBeAppended = i\\n            while stack and gcd(stack[-1], toBeAppended) > 1:\\n                toBeAppended = lcm(toBeAppended, stack.pop())\\n            stack.append(toBeAppended)\\n        return stack        \\n"}
{"prompt": "Write an optimized Python function to solve the following problem: You are given an integer n denoting the number of nodes of a weighted directed graph. The nodes are numbered from 0 to n - 1. You are also given a 2D integer array edges where edges[i] = [fromi, toi, weighti] denotes that there exists a directed edge from fromi to toi with weight weighti. Lastly, you are given three distinct integers src1, src2, and dest denoting three distinct nodes of the graph. Return the minimum weight of a subgraph of the graph such that it is possible to reach dest from both src1 and src2 via a set of edges of this subgraph. In case such a subgraph does not exist, return -1. A subgraph is a graph whose vertices and edges are subsets of the original graph. The weight of a subgraph is the sum of weights of its constituent edges. Example 1: Input: n = 6, edges = [[0,2,2],[0,5,6],[1,0,3],[1,4,5],[2,1,1],[2,3,3],[2,3,4],[3,4,2],[4,5,1]], src1 = 0, src2 = 1, dest = 5 Output: 9 Explanation: The above figure represents the input graph. The blue edges represent one of the subgraphs that yield the optimal answer. Note that the subgraph [[1,0,3],[0,5,6]] also yields the optimal answer. It is not possible to get a subgraph with less weight satisfying all the constraints. Example 2: Input: n = 3, edges = [[0,1,1],[2,1,1]], src1 = 0, src2 = 1, dest = 2 Output: -1 Explanation: The above figure represents the input graph. It can be seen that there does not exist any path from node 1 to node 2, hence there are no subgraphs satisfying all the constraints. Constraints: 3 <= n <= 105 0 <= edges.length <= 105 edges[i].length == 3 0 <= fromi, toi, src1, src2, dest <= n - 1 fromi != toi src1, src2, and dest are pairwise distinct. 1 <= weight[i] <= 105", "completion": "class Solution:\\n    def minimumWeight(self, n: int, edges: List[List[int]], src1: int, src2: int, dest: int) -> int:\\n        g1 = collections.defaultdict(list)\\n        g2 = collections.defaultdict(list)\\n        for u, v , w in edges:\\n            g1[u].append((v, w))\\n            g2[v].append((u, w))\\n\\n        def get_distance(node: int, g: dict) -> List[float | int]:\\n            distance = [float(\\'inf\\') for _ in range(n)]\\n            distance[node] = 0\\n            q = [(0, node)]\\n            while q:\\n                d, u = heapq.heappop(q)\\n                if d > distance[u]: continue\\n                for v, w in g[u]:\\n                    if d + w < distance[v]:\\n                        distance[v] = d + w\\n                        heapq.heappush(q, (distance[v], v))\\n            return distance\\n        \\n        l1, l2, l3 = get_distance(src1, g1), get_distance(src2, g1), get_distance(dest, g2)\\n        ans = float(\"inf\")\\n        for i in range(n):\\n            ans = min(ans, l1[i] + l2[i] + l3[i])\\n        \\n        return ans if ans != float(\"inf\") else -1\\n"}
{"prompt": "Write an optimized Python function to solve the following problem: You are given a 0-indexed binary string floor, which represents the colors of tiles on a floor: floor[i] = '0' denotes that the ith tile of the floor is colored black. On the other hand, floor[i] = '1' denotes that the ith tile of the floor is colored white. You are also given numCarpets and carpetLen. You have numCarpets black carpets, each of length carpetLen tiles. Cover the tiles with the given carpets such that the number of white tiles still visible is minimum. Carpets may overlap one another. Return the minimum number of white tiles still visible. Example 1: Input: floor = \"10110101\", numCarpets = 2, carpetLen = 2 Output: 2 Explanation: The figure above shows one way of covering the tiles with the carpets such that only 2 white tiles are visible. No other way of covering the tiles with the carpets can leave less than 2 white tiles visible. Example 2: Input: floor = \"11111\", numCarpets = 2, carpetLen = 3 Output: 0 Explanation: The figure above shows one way of covering the tiles with the carpets such that no white tiles are visible. Note that the carpets are able to overlap one another. Constraints: 1 <= carpetLen <= floor.length <= 1000 floor[i] is either '0' or '1'. 1 <= numCarpets <= 1000", "completion": "class Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        \\n        @cache\\n        def fn(i, n):\\n            \"\"\"Return min while tiles at k with n carpets left.\"\"\"\\n            if n < 0: return inf \\n            if i >= len(floor): return 0 \\n            if floor[i] == \\'1\\': return min(fn(i+carpetLen, n-1), 1 + fn(i+1, n))\\n            return fn(i+1, n)\\n        \\n        return fn(0, numCarpets)\\n"}
{"prompt": "Write an optimized Python function to solve the following problem: You are given a 0-indexed string s. You are also given a 0-indexed string queryCharacters of length k and a 0-indexed array of integer indices queryIndices of length k, both of which are used to describe k queries. The ith query updates the character in s at index queryIndices[i] to the character queryCharacters[i]. Return an array lengths of length k where lengths[i] is the length of the longest substring of s consisting of only one repeating character after the ith query is performed. Example 1: Input: s = \"babacc\", queryCharacters = \"bcb\", queryIndices = [1,3,3] Output: [3,3,4] Explanation: - 1st query updates s = \"bbbacc\". The longest substring consisting of one repeating character is \"bbb\" with length 3. - 2nd query updates s = \"bbbccc\". The longest substring consisting of one repeating character can be \"bbb\" or \"ccc\" with length 3. - 3rd query updates s = \"bbbbcc\". The longest substring consisting of one repeating character is \"bbbb\" with length 4. Thus, we return [3,3,4]. Example 2: Input: s = \"abyzz\", queryCharacters = \"aa\", queryIndices = [2,1] Output: [2,3] Explanation: - 1st query updates s = \"abazz\". The longest substring consisting of one repeating character is \"zz\" with length 2. - 2nd query updates s = \"aaazz\". The longest substring consisting of one repeating character is \"aaa\" with length 3. Thus, we return [2,3]. Constraints: 1 <= s.length <= 105 s consists of lowercase English letters. k == queryCharacters.length == queryIndices.length 1 <= k <= 105 queryCharacters consists of lowercase English letters. 0 <= queryIndices[i] < s.length", "completion": "class Solution:\\n    def longestRepeating(self, s: str, queryCharacters: str, queryIndices: List[int]) -> List[int]:\\n        \\n        s = list(s)\\n        loc = defaultdict(lambda: SortedList()) # segment offsets (start, end) stored by character\\n        max_len = SortedList() # segment length stored by character\\n\\n        i = 0\\n        while i < len(s):\\n            j = i\\n            while j < len(s) and s[i] == s[j]:\\n                j += 1\\n            loc[s[i]].add((i, j-1))\\n            max_len.add(j - i)\\n            i = j\\n            \\n        # helper function to remove segment\\n        def del_seg(w, old_l, old_r):\\n            loc[w].remove((old_l, old_r))\\n            max_len.remove(old_r - old_l + 1)\\n        \\n        # helper function to add segment\\n        def add_seg(w, new_l, new_r):\\n            loc[w].add((new_l, new_r))\\n            max_len.add(new_r - new_l + 1)\\n\\n        ans = [0] * len(queryIndices)\\n        for k in range(len(queryIndices)):\\n            old, new = s[queryIndices[k]], queryCharacters[k]\\n            s[queryIndices[k]] = new\\n            pos = (queryIndices[k], queryIndices[k])\\n\\n            # old segment delete\\n            if pos in loc[old]:\\n                del_seg(old, *pos)\\n            else:\\n                l1 = bisect.bisect_left(loc[old], pos)\\n                if l1 == 0:\\n                    old_pos = loc[old][l1]\\n                    l, r = old_pos\\n                    del_seg(old, *old_pos)\\n                    add_seg(old, l + 1, r)\\n                elif l1 == len(loc[old]):\\n                    old_pos = loc[old][l1-1]\\n                    l, r = old_pos\\n                    del_seg(old, *old_pos)\\n                    if pos[0] == r:\\n                        add_seg(old, l, r-1)\\n                    else:\\n                        add_seg(old, l, pos[0]-1)\\n                        add_seg(old, pos[0] + 1, r)\\n                else:\\n                    a, b = loc[old][l1 - 1]\\n                    c, d = loc[old][l1]\\n                    if pos[0] == b:\\n                        del_seg(old, a, b)\\n                        add_seg(old, a, b-1)\\n                    elif pos[0] == c:\\n                        del_seg(old, c, d)\\n                        add_seg(old, c+1, d)\\n                    elif pos[0] < b:\\n                        del_seg(old, a, b)\\n                        add_seg(old, a, pos[0]-1)\\n                        add_seg(old, pos[0]+1, b)\\n                    elif pos[0] > c:\\n                        del_seg(old, c, d)\\n                        add_seg(old, c, pos[0]-1)\\n                        add_seg(old, pos[0]+1, d)\\n\\n            # new segment insert\\n            if not loc[new]:\\n                add_seg(new, *pos)\\n                ans[k] = max_len[-1]\\n                continue\\n            l2 = bisect.bisect_left(loc[new], pos)\\n            if l2 == 0:\\n                l, r = loc[new][l2]\\n                if l - pos[0] > 1:\\n                    add_seg(new, *pos)\\n                else:\\n                    del_seg(new, l, r)\\n                    add_seg(new, pos[0], r)\\n\\n            elif l2 == len(loc[new]):\\n                l, r = loc[new][l2 - 1]\\n                if pos[0] - r > 1:\\n                    add_seg(new, *pos)\\n                else:\\n                    del_seg(new, l, r)\\n                    add_seg(new, l, pos[0])\\n            else:\\n                a, b = loc[new][l2 - 1]\\n                c, d = loc[new][l2]\\n                if pos[0] - b == 1 and c - pos[0] == 1:\\n                    del_seg(new, a, b)\\n                    del_seg(new, c, d)\\n                    add_seg(new, a, d)\\n                elif pos[0] - b == 1:\\n                    del_seg(new, a, b)\\n                    add_seg(new, a, pos[0])\\n                elif c - pos[0] == 1:\\n                    del_seg(new, c, d)\\n                    add_seg(new, pos[0], d)\\n                else:\\n                    add_seg(new, *pos)\\n            ans[k] = max_len[-1]\\n        return ans\\n"}
{"prompt": "Write an optimized Python function to solve the following problem: There are n piles of coins on a table. Each pile consists of a positive number of coins of assorted denominations. In one move, you can choose any coin on top of any pile, remove it, and add it to your wallet. Given a list piles, where piles[i] is a list of integers denoting the composition of the ith pile from top to bottom, and a positive integer k, return the maximum total value of coins you can have in your wallet if you choose exactly k coins optimally. Example 1: Input: piles = [[1,100,3],[7,8,9]], k = 2 Output: 101 Explanation: The above diagram shows the different ways we can choose k coins. The maximum total we can obtain is 101. Example 2: Input: piles = [[100],[100],[100],[100],[100],[100],[1,1,1,1,1,1,700]], k = 7 Output: 706 Explanation: The maximum total can be obtained if we choose all coins from the last pile. Constraints: n == piles.length 1 <= n <= 1000 1 <= piles[i][j] <= 105 1 <= k <= sum(piles[i].length) <= 2000", "completion": "class Solution:\\n    def maxValueOfCoins(self, piles: List[List[int]], k: int) -> int:\\n        \\n        @functools.lru_cache(None)\\n        def _search(rest_k: int, pile_pos: int) -> int:\\n            \"\"\"Searches for best accumulated coin value starting from pile at position `pile_pos`.\\n            \\n            Args:\\n              - rest_k: The rest of coins we could pick.\\n              - pile_pos: The starting position of pile we are working on.\\n            \"\"\"\\n            if rest_k == 0 or pile_pos == len(piles): return 0\\n\\n            # Ignore the current pile and moving to next pile\\n            current_mv_found = _search(rest_k, pile_pos+1)\\n\\n            # Start looking solution with current pile being involved\\n            current_pile = piles[pile_pos]\\n            accum_coin_value = 0\\n            for i in range(min(rest_k, len(current_pile))):\\n                # Accumulate the coins\\n                accum_coin_value += current_pile[i]\\n\\n                # Moving to next pile with accumulated coin value in current pile\\n                current_mv_found = max(\\n                    current_mv_found, \\n                    accum_coin_value + _search(rest_k-i-1, pile_pos+1))\\n\\n            # Return the maximum accumulated coin value found from current pile.\\n            return current_mv_found\\n\\n        # Start searching with initial `k` and first pile\\n        return _search(k, 0)\\n"}
{"prompt": "Write an optimized Python function to solve the following problem: You are building a string s of length n one character at a time, prepending each new character to the front of the string. The strings are labeled from 1 to n, where the string with length i is labeled si. For example, for s = \"abaca\", s1 == \"a\", s2 == \"ca\", s3 == \"aca\", etc. The score of si is the length of the longest common prefix between si and sn (Note that s == sn). Given the final string s, return the sum of the score of every si. Example 1: Input: s = \"babab\" Output: 9 Explanation: For s1 == \"b\", the longest common prefix is \"b\" which has a score of 1. For s2 == \"ab\", there is no common prefix so the score is 0. For s3 == \"bab\", the longest common prefix is \"bab\" which has a score of 3. For s4 == \"abab\", there is no common prefix so the score is 0. For s5 == \"babab\", the longest common prefix is \"babab\" which has a score of 5. The sum of the scores is 1 + 0 + 3 + 0 + 5 = 9, so we return 9. Example 2: Input: s = \"azbazbzaz\" Output: 14 Explanation: For s2 == \"az\", the longest common prefix is \"az\" which has a score of 2. For s6 == \"azbzaz\", the longest common prefix is \"azb\" which has a score of 3. For s9 == \"azbazbzaz\", the longest common prefix is \"azbazbzaz\" which has a score of 9. For all other si, the score is 0. The sum of the scores is 2 + 3 + 9 = 14, so we return 14. Constraints: 1 <= s.length <= 105 s consists of lowercase English letters.", "completion": "class Solution:\\n    def sumScores(self, s: str) -> int:\\n        mod = 119_218_851_371\\n        hs = 0 \\n        vals = [0]\\n        for i, ch in enumerate(s): \\n            hs = (hs * 26 + ord(ch) - 97) % mod\\n            vals.append(hs)\\n        \\n        p26 = [1]\\n        for _ in range(len(s)): p26.append(p26[-1] * 26 % mod)\\n        \\n        ans = 0 \\n        for i in range(len(s)): \\n            if s[0] == s[i]: \\n                lo, hi = i, len(s)\\n                while lo < hi: \\n                    mid = lo + hi + 1 >> 1\\n                    hs = (vals[mid] - vals[i]*p26[mid-i]) % mod\\n                    if hs == vals[mid-i]: lo = mid\\n                    else: hi = mid - 1\\n                ans += lo - i \\n        return ans \\n"}
{"prompt": "Write an optimized Python function to solve the following problem: Alice is a caretaker of n gardens and she wants to plant flowers to maximize the total beauty of all her gardens. You are given a 0-indexed integer array flowers of size n, where flowers[i] is the number of flowers already planted in the ith garden. Flowers that are already planted cannot be removed. You are then given another integer newFlowers, which is the maximum number of flowers that Alice can additionally plant. You are also given the integers target, full, and partial. A garden is considered complete if it has at least target flowers. The total beauty of the gardens is then determined as the sum of the following: The number of complete gardens multiplied by full. The minimum number of flowers in any of the incomplete gardens multiplied by partial. If there are no incomplete gardens, then this value will be 0. Return the maximum total beauty that Alice can obtain after planting at most newFlowers flowers. Example 1: Input: flowers = [1,3,1,1], newFlowers = 7, target = 6, full = 12, partial = 1 Output: 14 Explanation: Alice can plant - 2 flowers in the 0th garden - 3 flowers in the 1st garden - 1 flower in the 2nd garden - 1 flower in the 3rd garden The gardens will then be [3,6,2,2]. She planted a total of 2 + 3 + 1 + 1 = 7 flowers. There is 1 garden that is complete. The minimum number of flowers in the incomplete gardens is 2. Thus, the total beauty is 1 * 12 + 2 * 1 = 12 + 2 = 14. No other way of planting flowers can obtain a total beauty higher than 14. Example 2: Input: flowers = [2,4,5,3], newFlowers = 10, target = 5, full = 2, partial = 6 Output: 30 Explanation: Alice can plant - 3 flowers in the 0th garden - 0 flowers in the 1st garden - 0 flowers in the 2nd garden - 2 flowers in the 3rd garden The gardens will then be [5,4,5,5]. She planted a total of 3 + 0 + 0 + 2 = 5 flowers. There are 3 gardens that are complete. The minimum number of flowers in the incomplete gardens is 4. Thus, the total beauty is 3 * 2 + 4 * 6 = 6 + 24 = 30. No other way of planting flowers can obtain a total beauty higher than 30. Note that Alice could make all the gardens complete but in this case, she would obtain a lower total beauty. Constraints: 1 <= flowers.length <= 105 1 <= flowers[i], target <= 105 1 <= newFlowers <= 1010 1 <= full, partial <= 105", "completion": "class Solution:\\n    def maximumBeauty(self, flowers: List[int], newFlowers: int, target: int, full: int, partial: int) -> int:\\n        n = len(flowers)\\n        flowers.sort() \\n        originally_complete = sum(flowers[i] >= target for i in range(n))\\n        work_end = n - originally_complete\\n        # [0,        j-1] \\u2014 incomplete (with >=`level` flowers each, where `0 <= `level` <= target - 1) \\n        # [j, work_end-1] \\u2014 complete\\n        # [work_end, n-1] \\u2014 originally complete\\n\\n        i = -1\\n        level = 0\\n        def maximize_min_number_of_flowers() -> None:\\n            nonlocal i, level, newFlowers\\n            if j == 0:\\n                return\\n            if i == -1:\\n                i = 0\\n                level = flowers[0]\\n            while i < j:\\n                next_level = flowers[i+1] if i + 1 < j else target - 1\\n                max_boost = min(next_level - level, newFlowers // (i+1))\\n                level += max_boost\\n                newFlowers -= max_boost * (i+1)\\n                if level != next_level:\\n                    break\\n                i += 1\\n        \\n        j = work_end\\n        def add_complete_garden() -> bool:\\n            nonlocal j, newFlowers\\n            if j - 1 < 0 or newFlowers < target - flowers[j-1]:\\n                return False\\n            newFlowers -= target - flowers[j-1]\\n            j -= 1\\n            return True\\n        def remove_complete_garden() -> None:\\n            nonlocal j, newFlowers\\n            assert j < work_end\\n            newFlowers += target - flowers[j]\\n            flowers[j] = flowers[j]\\n            j += 1\\n\\n        while add_complete_garden():\\n            pass\\n        maximize_min_number_of_flowers()\\n        ans = full * (n - j) + partial * level\\n        while j < work_end:\\n            remove_complete_garden()\\n            maximize_min_number_of_flowers()\\n            ans = max(ans, full * (n - j) + partial * level)\\n        return ans\\n"}
{"prompt": "Write an optimized Python function to solve the following problem: You are given a tree (i.e. a connected, undirected graph that has no cycles) rooted at node 0 consisting of n nodes numbered from 0 to n - 1. The tree is represented by a 0-indexed array parent of size n, where parent[i] is the parent of node i. Since node 0 is the root, parent[0] == -1. You are also given a string s of length n, where s[i] is the character assigned to node i. Return the length of the longest path in the tree such that no pair of adjacent nodes on the path have the same character assigned to them. Example 1: Input: parent = [-1,0,0,1,1,2], s = \"abacbe\" Output: 3 Explanation: The longest path where each two adjacent nodes have different characters in the tree is the path: 0 -> 1 -> 3. The length of this path is 3, so 3 is returned. It can be proven that there is no longer path that satisfies the conditions. Example 2: Input: parent = [-1,0,0,0], s = \"aabc\" Output: 3 Explanation: The longest path where each two adjacent nodes have different characters is the path: 2 -> 0 -> 3. The length of this path is 3, so 3 is returned. Constraints: n == parent.length == s.length 1 <= n <= 105 0 <= parent[i] <= n - 1 for all i >= 1 parent[0] == -1 parent represents a valid tree. s consists of only lowercase English letters.", "completion": "class Solution:\\n    def longestPath(self, par: List[int], s: str) -> int:\\n        dit = {}\\n        # store tree in dictionary\\n        for i in range(len(par)):\\n            if par[i] in dit:\\n                dit[par[i]].append(i)\\n            else:\\n                dit[par[i]] = [i]\\n                \\n        ans = 1        \\n        def dfs(n):\\n            nonlocal ans\\n            if n not in dit:\\n                return 1\\n            \\n            largest=0 # largest path lenght among all children\\n            second_largest=0 # second largest path lenght among all children\\n            for u in dit[n]:\\n                curr = dfs(u)\\n                if s[u]!=s[n]: # pick child path if child and parent both have different value\\n                    if curr>largest:\\n                        second_largest = largest\\n                        largest = curr\\n                    elif curr>second_largest:\\n                        second_largest = curr\\n                        \\n            ans = max(ans,largest+second_largest+1) # largest path including parent with at most two children \\n            \\n            return largest+1  # return largest path end at parent\\n        \\n        dfs(0)\\n        return ans\\n"}
