{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: You are given an array pairs, where pairs[i] = [xi, yi], and: There are no duplicates. xi < yi Let ways be the number of rooted trees that satisfy the following conditions: The tree consists of nodes whose values appeared in pairs. A pair [xi, yi] exists in pairs if and only if xi is an ancestor of yi or yi is an ancestor of xi. Note: the tree does not have to be a binary tree. Two ways are considered to be different if there is at least one node that has different parents in both ways. Return: 0 if ways == 0 1 if ways == 1 2 if ways > 1 A rooted tree is a tree that has a single root node, and all edges are oriented to be outgoing from the root. An ancestor of a node is any node on the path from the root to that node (excluding the node itself). The root has no ancestors. Example 1: Input: pairs = [[1,2],[2,3]] Output: 1 Explanation: There is exactly one valid rooted tree, which is shown in the above figure. Example 2: Input: pairs = [[1,2],[2,3],[1,3]] Output: 2 Explanation: There are multiple valid rooted trees. Three of them are shown in the above figures. Example 3: Input: pairs = [[1,2],[2,3],[2,4],[1,5]] Output: 0 Explanation: There are no valid rooted trees. Constraints: 1 <= pairs.length <= 105 1 <= xi < yi <= 500 The elements in pairs are unique."}, {"role": "assistant", "content": "class Solution:\\n    def checkWays(self, pairs: List[List[int]]) -> int:\\n        graph = {}\\n        for x, y in pairs: \\n            graph.setdefault(x, set()).add(y)\\n            graph.setdefault(y, set()).add(x)\\n        \\n        ans = 1 \\n        ancestors = set()\\n        for n in sorted(graph, key=lambda x: len(graph[x]), reverse=True): \\n            p = min(ancestors & graph[n], key=lambda x: len(graph[x]), default=None) # immediate ancestor \\n            ancestors.add(n)\\n            if p: \\n                if graph[n] - (graph[p] | {p}): return 0 # impossible to have more than ancestor\\n                if len(graph[n]) == len(graph[p]): ans = 2\\n            elif len(graph[n]) != len(graph)-1: return 0\\n        return ans \\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: You are given an integer array jobs, where jobs[i] is the amount of time it takes to complete the ith job. There are k workers that you can assign jobs to. Each job should be assigned to exactly one worker. The working time of a worker is the sum of the time it takes to complete all jobs assigned to them. Your goal is to devise an optimal assignment such that the maximum working time of any worker is minimized. Return the minimum possible maximum working time of any assignment. Example 1: Input: jobs = [3,2,3], k = 3 Output: 3 Explanation: By assigning each person one job, the maximum time is 3. Example 2: Input: jobs = [1,2,4,7,8], k = 2 Output: 11 Explanation: Assign the jobs the following way: Worker 1: 1, 2, 8 (working time = 1 + 2 + 8 = 11) Worker 2: 4, 7 (working time = 4 + 7 = 11) The maximum working time is 11. Constraints: 1 <= k <= jobs.length <= 12 1 <= jobs[i] <= 107"}, {"role": "assistant", "content": "class Solution:\\n    def minimumTimeRequired(self, jobs: List[int], k: int) -> int:\\n        jobs.sort(reverse=True)\\n        \\n        def fn(i):\\n            \"\"\"Assign jobs to worker and find minimum time.\"\"\"\\n            nonlocal ans \\n            if i == len(jobs): ans = max(time)\\n            else: \\n                for kk in range(k): \\n                    if not kk or time[kk-1] > time[kk]: \\n                        time[kk] += jobs[i]\\n                        if max(time) < ans: fn(i+1)\\n                        time[kk] -= jobs[i]\\n            \\n        ans = inf\\n        time = [0]*k\\n        fn(0)\\n        return ans \\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: A game is played by a cat and a mouse named Cat and Mouse. The environment is represented by a grid of size rows x cols, where each element is a wall, floor, player (Cat, Mouse), or food. Players are represented by the characters 'C'(Cat),'M'(Mouse). Floors are represented by the character '.' and can be walked on. Walls are represented by the character '#' and cannot be walked on. Food is represented by the character 'F' and can be walked on. There is only one of each character 'C', 'M', and 'F' in grid. Mouse and Cat play according to the following rules: Mouse moves first, then they take turns to move. During each turn, Cat and Mouse can jump in one of the four directions (left, right, up, down). They cannot jump over the wall nor outside of the grid. catJump, mouseJump are the maximum lengths Cat and Mouse can jump at a time, respectively. Cat and Mouse can jump less than the maximum length. Staying in the same position is allowed. Mouse can jump over Cat. The game can end in 4 ways: If Cat occupies the same position as Mouse, Cat wins. If Cat reaches the food first, Cat wins. If Mouse reaches the food first, Mouse wins. If Mouse cannot get to the food within 1000 turns, Cat wins. Given a rows x cols matrix grid and two integers catJump and mouseJump, return true if Mouse can win the game if both Cat and Mouse play optimally, otherwise return false. Example 1: Input: grid = [\"####F\",\"#C...\",\"M....\"], catJump = 1, mouseJump = 2 Output: true Explanation: Cat cannot catch Mouse on its turn nor can it get the food before Mouse. Example 2: Input: grid = [\"M.C...F\"], catJump = 1, mouseJump = 4 Output: true Example 3: Input: grid = [\"M.C...F\"], catJump = 1, mouseJump = 3 Output: false Constraints: rows == grid.length cols = grid[i].length 1 <= rows, cols <= 8 grid[i][j] consist only of characters 'C', 'M', 'F', '.', and '#'. There is only one of each character 'C', 'M', and 'F' in grid. 1 <= catJump, mouseJump <= 8"}, {"role": "assistant", "content": "class Solution:\\n    def canMouseWin(self, grid: List[str], catJump: int, mouseJump: int) -> bool:\\n        dirs = [[1, 0], [-1, 0], [0, 1], [0, -1]]\\n        m, n = len(grid), len(grid[0])\\n        mouse_pos = cat_pos = None\\n\\t\\tavailable = 0 # available steps for mouse and cat\\n\\t\\t# Search the start pos of mouse and cat\\n        for i in range(m):\\n            for j in range(n):\\n\\t\\t\\t\\tif grid[i][j] != \\'#\\':\\n                    available += 1\\n                if grid[i][j] == \\'M\\':\\n                    mouse_pos = (i, j)\\n                elif grid[i][j] == \\'C\\':\\n                    cat_pos = (i, j)\\n        \\n        @functools.lru_cache(None)\\n        def dp(turn, mouse_pos, cat_pos):\\n            # if turn == m * n * 2:\\n\\t\\t\\t# We already search the whole grid (9372 ms 74.3 MB)\\n\\t\\t\\tif turn == available * 2:\\n\\t\\t\\t\\t# We already search the whole touchable grid (5200 ms 57.5 MB)\\n                return False\\n            if turn % 2 == 0:\\n                # Mouse\\n                i, j = mouse_pos\\n                for di, dj in dirs:\\n                    for jump in range(mouseJump + 1):\\n\\t\\t\\t\\t\\t\\t# Note that we want to do range(mouseJump + 1) instead of range(1, mouseJump + 1)\\n\\t\\t\\t\\t\\t\\t# considering the case that we can stay at the same postion for next turn.\\n                        new_i, new_j = i + di * jump, j + dj * jump\\n                        if 0 <= new_i < m and 0 <= new_j < n and grid[new_i][new_j] != \\'#\\':\\n\\t\\t\\t\\t\\t\\t\\t# Valid pos\\n                            if dp(turn + 1, (new_i, new_j), cat_pos) or grid[new_i][new_j] == \\'F\\':\\n                                return True\\n                        else:\\n\\t\\t\\t\\t\\t\\t\\t# Stop extending the jump since we cannot go further\\n                            break\\n                return False\\n            else:\\n                # Cat\\n                i, j = cat_pos\\n                for di, dj in dirs:\\n                    for jump in range(catJump + 1):\\n                        new_i, new_j = i + di * jump, j + dj * jump\\n                        if 0 <= new_i < m and 0 <= new_j < n and grid[new_i][new_j] != \\'#\\':\\n                            if not dp(turn + 1, mouse_pos, (new_i, new_j)) or (new_i, new_j) == mouse_pos or grid[new_i][new_j] == \\'F\\':\\n\\t\\t\\t\\t\\t\\t\\t# This condition will also handle the case that the cat cannot jump through the mouse\\n                                return False\\n                        else:\\n                            break\\n                return True\\n\\t\\t\\t\\t\\n        return dp(0, mouse_pos, cat_pos)\\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: You are given a 2D integer array, queries. For each queries[i], where queries[i] = [ni, ki], find the number of different ways you can place positive integers into an array of size ni such that the product of the integers is ki. As the number of ways may be too large, the answer to the ith query is the number of ways modulo 109 + 7. Return an integer array answer where answer.length == queries.length, and answer[i] is the answer to the ith query. Example 1: Input: queries = [[2,6],[5,1],[73,660]] Output: [4,1,50734910] Explanation: Each query is independent. [2,6]: There are 4 ways to fill an array of size 2 that multiply to 6: [1,6], [2,3], [3,2], [6,1]. [5,1]: There is 1 way to fill an array of size 5 that multiply to 1: [1,1,1,1,1]. [73,660]: There are 1050734917 ways to fill an array of size 73 that multiply to 660. 1050734917 modulo 109 + 7 = 50734910. Example 2: Input: queries = [[1,1],[2,2],[3,3],[4,4],[5,5]] Output: [1,2,3,10,5] Constraints: 1 <= queries.length <= 104 1 <= ni, ki <= 104"}, {"role": "assistant", "content": "class Solution:\\n    def waysToFillArray(self, queries: List[List[int]]) -> List[int]:\\n        # brute DP O(NK) where N is max(q[0]) and K is max(q[1])\\n        @cache\\n        def dp(n,k):\\n            \\n            if k == 1 or n == 1: return 1\\n            ways = 0\\n            for factor in range(1, k+1):\\n                if k % factor == 0:\\n                    ways += dp(n-1, k//factor) # or take the \\'3\\' part\\n                    ways %= (10**9+7)\\n            return ways % (10**9+7)\\n        \\n        res = [0] * len(queries)\\n        for i,(n, k) in enumerate(queries):\\n            res[i] = dp(n,k)\\n        \\n        return res\\n            \\n        # better solution -> find out how many prime factors a number has.\\n        # how many ways to group P numbers into N groups (since array has N values only)\\n        # but you can group in lesser groups and keep 1 1 1 1 as padding in array :(\\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: You have a cubic storeroom where the width, length, and height of the room are all equal to n units. You are asked to place n boxes in this room where each box is a cube of unit side length. There are however some rules to placing the boxes: You can place the boxes anywhere on the floor. If box x is placed on top of the box y, then each side of the four vertical sides of the box y must either be adjacent to another box or to a wall. Given an integer n, return the minimum possible number of boxes touching the floor. Example 1: Input: n = 3 Output: 3 Explanation: The figure above is for the placement of the three boxes. These boxes are placed in the corner of the room, where the corner is on the left side. Example 2: Input: n = 4 Output: 3 Explanation: The figure above is for the placement of the four boxes. These boxes are placed in the corner of the room, where the corner is on the left side. Example 3: Input: n = 10 Output: 6 Explanation: The figure above is for the placement of the ten boxes. These boxes are placed in the corner of the room, where the corner is on the back side. Constraints: 1 <= n <= 109"}, {"role": "assistant", "content": "class Solution:\\n    def minimumBoxes(self, n: int) -> int:\\n        x = int((6*n)**(1/3))\\n        if x*(x+1)*(x+2) > 6*n: x -= 1\\n        \\n        ans = x*(x+1)//2\\n        n -= x*(x+1)*(x+2)//6\\n        k = 1\\n        while n > 0: \\n            ans += 1\\n            n -= k\\n            k += 1\\n        return ans \\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: Given a string s, return true if it is possible to split the string s into three non-empty palindromic substrings. Otherwise, return false.\u200b\u200b\u200b\u200b\u200b A string is said to be palindrome if it the same string when reversed. Example 1: Input: s = \"abcbdd\" Output: true Explanation: \"abcbdd\" = \"a\" + \"bcb\" + \"dd\", and all three substrings are palindromes. Example 2: Input: s = \"bcbddxy\" Output: false Explanation: s cannot be split into 3 palindromes. Constraints: 3 <= s.length <= 2000 s\u200b\u200b\u200b\u200b\u200b\u200b consists only of lowercase English letters."}, {"role": "assistant", "content": "class Solution:\\n    def checkPartitioning(self, s: str) -> bool:\\n        mp = {}\\n        for i in range(2*len(s)-1): \\n            lo, hi = i//2, (i+1)//2\\n            while 0 <= lo <= hi < len(s) and s[lo] == s[hi]: \\n                mp.setdefault(lo, set()).add(hi)\\n                lo -= 1\\n                hi += 1\\n        \\n        @lru_cache(None)\\n        def fn(i, k): \\n            \"\"\"Return True if s[i:] can be split into k palindromic substrings.\"\"\"\\n            if k < 0: return False \\n            if i == len(s): return k == 0\\n            return any(fn(ii+1, k-1) for ii in mp[i])\\n        \\n        return fn(0, 3)\\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: You are given an array of events where events[i] = [startDayi, endDayi, valuei]. The ith event starts at startDayi and ends at endDayi, and if you attend this event, you will receive a value of valuei. You are also given an integer k which represents the maximum number of events you can attend. You can only attend one event at a time. If you choose to attend an event, you must attend the entire event. Note that the end day is inclusive: that is, you cannot attend two events where one of them starts and the other ends on the same day. Return the maximum sum of values that you can receive by attending events. Example 1: Input: events = [[1,2,4],[3,4,3],[2,3,1]], k = 2 Output: 7 Explanation: Choose the green events, 0 and 1 (0-indexed) for a total value of 4 + 3 = 7. Example 2: Input: events = [[1,2,4],[3,4,3],[2,3,10]], k = 2 Output: 10 Explanation: Choose event 2 for a total value of 10. Notice that you cannot attend any other event as they overlap, and that you do not have to attend k events. Example 3: Input: events = [[1,1,1],[2,2,2],[3,3,3],[4,4,4]], k = 3 Output: 9 Explanation: Although the events do not overlap, you can only attend 3 events. Pick the highest valued three. Constraints: 1 <= k <= events.length 1 <= k * events.length <= 106 1 <= startDayi <= endDayi <= 109 1 <= valuei <= 106"}, {"role": "assistant", "content": "class Solution:\\n    def maxValue(self, events: List[List[int]], k: int) -> int:\\n        \\n        # The number of events\\n        n = len(events)\\n        # Sort the events in chronological order\\n        events.sort()\\n        \\n        # k is the number of events we can attend\\n        # end is the last event we attended\\'s END TIME\\n        # event_index is the current event we are checking\\n        @lru_cache(None)\\n        def dp(end: int, event_index: int, k: int):\\n            \\n            # No more events left or we have checked all possible events\\n            if k == 0 or event_index == n:\\n                return 0\\n            \\n            event = events[event_index]\\n            event_start, event_end, event_value = event\\n            # Can we attend this event?\\n            # Does its start time conflict with the previous events end time?\\n            # If the start time is the same as the end time we cannot end as well (view example 2)\\n            if event_start <= end:\\n                # Could not attend, check the next event\\n                return dp(end, event_index + 1, k)\\n            \\n            # We made it here, so we can attend!\\n            # Two possible options, we either attend (add the value) or do not attend this event\\n            # Value for attending versus the value for skipping\\n            attend = event_value + dp(event_end, event_index + 1, k - 1)\\n            skip = dp(end, event_index + 1, k)\\n            \\n            # Get the best option\\n            return max(attend, skip)\\n            \\n        # Clear cache to save memory\\n        dp.cache_clear()\\n        return dp(0, 0, k)\\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: You are given an integer array nums and an integer goal. You want to choose a subsequence of nums such that the sum of its elements is the closest possible to goal. That is, if the sum of the subsequence's elements is sum, then you want to minimize the absolute difference abs(sum - goal). Return the minimum possible value of abs(sum - goal). Note that a subsequence of an array is an array formed by removing some elements (possibly all or none) of the original array. Example 1: Input: nums = [5,-7,3,5], goal = 6 Output: 0 Explanation: Choose the whole array as a subsequence, with a sum of 6. This is equal to the goal, so the absolute difference is 0. Example 2: Input: nums = [7,-9,15,-2], goal = -5 Output: 1 Explanation: Choose the subsequence [7,-9,-2], with a sum of -4. The absolute difference is abs(-4 - (-5)) = abs(1) = 1, which is the minimum. Example 3: Input: nums = [1,2,3], goal = -7 Output: 7 Constraints: 1 <= nums.length <= 40 -107 <= nums[i] <= 107 -109 <= goal <= 109"}, {"role": "assistant", "content": "class Solution:\\n    def minAbsDifference(self, nums: List[int], goal: int) -> int:\\n        \\n        def fn(nums):\\n            ans = {0}\\n            for x in nums: \\n                ans |= {x + y for y in ans}\\n            return ans \\n        \\n        nums0 = sorted(fn(nums[:len(nums)//2]))\\n        \\n        ans = inf\\n        for x in fn(nums[len(nums)//2:]): \\n            k = bisect_left(nums0, goal - x)\\n            if k < len(nums0): ans = min(ans, nums0[k] + x - goal)\\n            if 0 < k: ans = min(ans, goal - x - nums0[k-1])\\n        return ans \\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: You are given an undirected graph. You are given an integer n which is the number of nodes in the graph and an array edges, where each edges[i] = [ui, vi] indicates that there is an undirected edge between ui and vi. A connected trio is a set of three nodes where there is an edge between every pair of them. The degree of a connected trio is the number of edges where one endpoint is in the trio, and the other is not. Return the minimum degree of a connected trio in the graph, or -1 if the graph has no connected trios. Example 1: Input: n = 6, edges = [[1,2],[1,3],[3,2],[4,1],[5,2],[3,6]] Output: 3 Explanation: There is exactly one trio, which is [1,2,3]. The edges that form its degree are bolded in the figure above. Example 2: Input: n = 7, edges = [[1,3],[4,1],[4,3],[2,5],[5,6],[6,7],[7,5],[2,6]] Output: 0 Explanation: There are exactly three trios: 1) [1,4,3] with degree 0. 2) [2,5,6] with degree 2. 3) [5,6,7] with degree 2. Constraints: 2 <= n <= 400 edges[i].length == 2 1 <= edges.length <= n * (n-1) / 2 1 <= ui, vi <= n ui != vi There are no repeated edges."}, {"role": "assistant", "content": "class Solution:\\n    def minTrioDegree(self, n: int, edges: List[List[int]]) -> int:\\n        graph = [[False]*n for _ in range(n)]\\n        degree = [0]*n\\n        \\n        for u, v in edges: \\n            graph[u-1][v-1] = graph[v-1][u-1] = True\\n            degree[u-1] += 1\\n            degree[v-1] += 1\\n        \\n        ans = inf\\n        for i in range(n): \\n            for j in range(i+1, n):\\n                if graph[i][j]: \\n                    for k in range(j+1, n):\\n                        if graph[j][k] and graph[k][i]: \\n                            ans = min(ans, degree[i] + degree[j] + degree[k] - 6)\\n        return ans if ans < inf else -1\\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: There is a tree (i.e., a connected, undirected graph that has no cycles) consisting of n nodes numbered from 0 to n - 1 and exactly n - 1 edges. Each node has a value associated with it, and the root of the tree is node 0. To represent this tree, you are given an integer array nums and a 2D array edges. Each nums[i] represents the ith node's value, and each edges[j] = [uj, vj] represents an edge between nodes uj and vj in the tree. Two values x and y are coprime if gcd(x, y) == 1 where gcd(x, y) is the greatest common divisor of x and y. An ancestor of a node i is any other node on the shortest path from node i to the root. A node is not considered an ancestor of itself. Return an array ans of size n, where ans[i] is the closest ancestor to node i such that nums[i] and nums[ans[i]] are coprime, or -1 if there is no such ancestor. Example 1: Input: nums = [2,3,3,2], edges = [[0,1],[1,2],[1,3]] Output: [-1,0,0,1] Explanation: In the above figure, each node's value is in parentheses. - Node 0 has no coprime ancestors. - Node 1 has only one ancestor, node 0. Their values are coprime (gcd(2,3) == 1). - Node 2 has two ancestors, nodes 1 and 0. Node 1's value is not coprime (gcd(3,3) == 3), but node 0's value is (gcd(2,3) == 1), so node 0 is the closest valid ancestor. - Node 3 has two ancestors, nodes 1 and 0. It is coprime with node 1 (gcd(3,2) == 1), so node 1 is its closest valid ancestor. Example 2: Input: nums = [5,6,10,2,3,6,15], edges = [[0,1],[0,2],[1,3],[1,4],[2,5],[2,6]] Output: [-1,0,-1,0,0,0,-1] Constraints: nums.length == n 1 <= nums[i] <= 50 1 <= n <= 105 edges.length == n - 1 edges[j].length == 2 0 <= uj, vj < n uj != vj"}, {"role": "assistant", "content": "class Solution:\\n    def getCoprimes(self, nums: List[int], edges: List[List[int]]) -> List[int]:\\n        tree = {} # tree as adjacency list \\n        for u, v in edges: \\n            tree.setdefault(u, []).append(v)\\n            tree.setdefault(v, []).append(u)\\n        \\n        ans = [-1]*len(nums)\\n        path = {} # val -> list of position & depth \\n        seen = {0}\\n        \\n        def fn(k, i): \\n            \"\"\"Populate ans via dfs.\"\"\"\\n            ii = -1 \\n            for x in path:\\n                if gcd(nums[k], x) == 1: # coprime \\n                    if path[x] and path[x][-1][1] > ii: \\n                        ans[k] = path[x][-1][0]\\n                        ii = path[x][-1][1]\\n                        \\n            path.setdefault(nums[k], []).append((k, i))\\n            for kk in tree.get(k, []): \\n                if kk not in seen: \\n                    seen.add(kk)\\n                    fn(kk, i+1)\\n            path[nums[k]].pop()\\n            \\n            \\n        fn(0, 0)\\n        return ans \\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: You are given two 0-indexed integer arrays nums and multipliers of size n and m respectively, where n >= m. You begin with a score of 0. You want to perform exactly m operations. On the ith operation (0-indexed) you will: Choose one integer x from either the start or the end of the array nums. Add multipliers[i] * x to your score. Note that multipliers[0] corresponds to the first operation, multipliers[1] to the second operation, and so on. Remove x from nums. Return the maximum score after performing m operations. Example 1: Input: nums = [1,2,3], multipliers = [3,2,1] Output: 14 Explanation: An optimal solution is as follows: - Choose from the end, [1,2,3], adding 3 * 3 = 9 to the score. - Choose from the end, [1,2], adding 2 * 2 = 4 to the score. - Choose from the end, [1], adding 1 * 1 = 1 to the score. The total score is 9 + 4 + 1 = 14. Example 2: Input: nums = [-5,-3,-3,-2,7,1], multipliers = [-10,-5,3,4,6] Output: 102 Explanation: An optimal solution is as follows: - Choose from the start, [-5,-3,-3,-2,7,1], adding -5 * -10 = 50 to the score. - Choose from the start, [-3,-3,-2,7,1], adding -3 * -5 = 15 to the score. - Choose from the start, [-3,-2,7,1], adding -3 * 3 = -9 to the score. - Choose from the end, [-2,7,1], adding 1 * 4 = 4 to the score. - Choose from the end, [-2,7], adding 7 * 6 = 42 to the score. The total score is 50 + 15 - 9 + 4 + 42 = 102. Constraints: n == nums.length m == multipliers.length 1 <= m <= 300 m <= n <= 105 -1000 <= nums[i], multipliers[i] <= 1000"}, {"role": "assistant", "content": "class Solution:\\n    def maximumScore(self, nums: List[int], multipliers: List[int]) -> int:\\n        n = len(nums)\\n        m = len(multipliers)\\n        \\n        @lru_cache(None)\\n        #To Save Computed Result\\n        \\n        def X(i, left):\\n            \\n            if i==m:\\n                return 0\\n            \\n            return max  (   (multipliers[i] * nums[left])          + X(i + 1, left + 1), \\n                            (multipliers[i] * nums[n-1-(i-left)])  + X(i + 1, left)       )        \\n                \\n        #Start from Zero operations\\n        return X(0,0)\\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: You are given two strings, word1 and word2. You want to construct a string in the following manner: Choose some non-empty subsequence subsequence1 from word1. Choose some non-empty subsequence subsequence2 from word2. Concatenate the subsequences: subsequence1 + subsequence2, to make the string. Return the length of the longest palindrome that can be constructed in the described manner. If no palindromes can be constructed, return 0. A subsequence of a string s is a string that can be made by deleting some (possibly none) characters from s without changing the order of the remaining characters. A palindrome is a string that reads the same forward as well as backward. Example 1: Input: word1 = \"cacb\", word2 = \"cbba\" Output: 5 Explanation: Choose \"ab\" from word1 and \"cba\" from word2 to make \"abcba\", which is a palindrome. Example 2: Input: word1 = \"ab\", word2 = \"ab\" Output: 3 Explanation: Choose \"ab\" from word1 and \"a\" from word2 to make \"aba\", which is a palindrome. Example 3: Input: word1 = \"aa\", word2 = \"bb\" Output: 0 Explanation: You cannot construct a palindrome from the described method, so return 0. Constraints: 1 <= word1.length, word2.length <= 1000 word1 and word2 consist of lowercase English letters."}, {"role": "assistant", "content": "class Solution:\\n    def longestPalindrome(self, word1: str, word2: str) -> int:\\n        \\n        @cache\\n        def fn(lo, hi):\\n            \"\"\"Return length of longest palindromic subsequence.\"\"\"\\n            if lo >= hi: return int(lo == hi)\\n            if word[lo] == word[hi]: return 2 + fn(lo+1, hi-1)\\n            return max(fn(lo+1, hi), fn(lo, hi-1))\\n        \\n        ans = 0\\n        word = word1 + word2\\n        for x in ascii_lowercase: \\n            i = word1.find(x) \\n            j = word2.rfind(x)\\n            if i != -1 and j != -1: ans = max(ans, fn(i, j + len(word1)))\\n        return ans \\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: There are n cars traveling at different speeds in the same direction along a one-lane road. You are given an array cars of length n, where cars[i] = [positioni, speedi] represents: positioni is the distance between the ith car and the beginning of the road in meters. It is guaranteed that positioni < positioni+1. speedi is the initial speed of the ith car in meters per second. For simplicity, cars can be considered as points moving along the number line. Two cars collide when they occupy the same position. Once a car collides with another car, they unite and form a single car fleet. The cars in the formed fleet will have the same position and the same speed, which is the initial speed of the slowest car in the fleet. Return an array answer, where answer[i] is the time, in seconds, at which the ith car collides with the next car, or -1 if the car does not collide with the next car. Answers within 10-5 of the actual answers are accepted. Example 1: Input: cars = [[1,2],[2,1],[4,3],[7,2]] Output: [1.00000,-1.00000,3.00000,-1.00000] Explanation: After exactly one second, the first car will collide with the second car, and form a car fleet with speed 1 m/s. After exactly 3 seconds, the third car will collide with the fourth car, and form a car fleet with speed 2 m/s. Example 2: Input: cars = [[3,4],[5,4],[6,3],[9,1]] Output: [2.00000,1.00000,1.50000,-1.00000] Constraints: 1 <= cars.length <= 105 1 <= positioni, speedi <= 106 positioni < positioni+1"}, {"role": "assistant", "content": "class Solution:\\n    def getCollisionTimes(self, cars: List[List[int]]) -> List[float]:\\n        colis_times = [-1] * len(cars)\\n        cars = [Car(pos, sp, i) for i, (pos, sp) in enumerate(cars)]\\n        for i in range(len(cars)-1): cars[i].next = cars[i+1]\\n        for i in range(1, len(cars)): cars[i].prev = cars[i-1]\\n        \\n        catchup_order = [((b.pos-a.pos)/(a.speed-b.speed), a.idx, a)\\n                        for i, (a, b) \\n                        in enumerate(zip(cars, cars[1:])) if a.speed > b.speed]\\n        heapify(catchup_order)\\n        \\n        while catchup_order:\\n            catchup_time, idx, car = heappop(catchup_order)\\n            if colis_times[idx] > -1: continue # ith car has already caught up\\n            colis_times[idx] = catchup_time\\n            if not car.prev: continue # no car is following us\\n            car.prev.next, car.next.prev = car.next, car.prev\\n            if car.next.speed >= car.prev.speed: continue # the follower is too slow to catch up\\n            new_catchup_time = (car.next.pos-car.prev.pos)/(car.prev.speed-car.next.speed)\\n            heappush(catchup_order, (new_catchup_time, car.prev.idx, car.prev))\\n        \\n        return colis_times\\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: You are given an undirected graph defined by an integer n, the number of nodes, and a 2D integer array edges, the edges in the graph, where edges[i] = [ui, vi] indicates that there is an undirected edge between ui and vi. You are also given an integer array queries. Let incident(a, b) be defined as the number of edges that are connected to either node a or b. The answer to the jth query is the number of pairs of nodes (a, b) that satisfy both of the following conditions: a < b incident(a, b) > queries[j] Return an array answers such that answers.length == queries.length and answers[j] is the answer of the jth query. Note that there can be multiple edges between the same two nodes. Example 1: Input: n = 4, edges = [[1,2],[2,4],[1,3],[2,3],[2,1]], queries = [2,3] Output: [6,5] Explanation: The calculations for incident(a, b) are shown in the table above. The answers for each of the queries are as follows: - answers[0] = 6. All the pairs have an incident(a, b) value greater than 2. - answers[1] = 5. All the pairs except (3, 4) have an incident(a, b) value greater than 3. Example 2: Input: n = 5, edges = [[1,5],[1,5],[3,4],[2,5],[1,3],[5,1],[2,3],[2,5]], queries = [1,2,3,4,5] Output: [10,10,9,8,6] Constraints: 2 <= n <= 2 * 104 1 <= edges.length <= 105 1 <= ui, vi <= n ui != vi 1 <= queries.length <= 20 0 <= queries[j] < edges.length"}, {"role": "assistant", "content": "class Solution:\\n    def countPairs(self, n: int, edges: List[List[int]], queries: List[int]) -> List[int]:\\n        degree = [0]*n\\n        freq = defaultdict(int)\\n        for u, v in edges: \\n            degree[u-1] += 1\\n            degree[v-1] += 1\\n            freq[min(u-1, v-1), max(u-1, v-1)] += 1\\n        \\n        vals = sorted(degree)\\n        \\n        ans = []\\n        for query in queries: \\n            cnt = 0 \\n            lo, hi = 0, n-1\\n            while lo < hi: \\n                if query < vals[lo] + vals[hi]: \\n                    cnt += hi - lo # (lo, hi), (lo+1, hi), ..., (hi-1, hi) all valid\\n                    hi -= 1\\n                else: lo += 1\\n            for u, v in freq: \\n                if degree[u] + degree[v] - freq[u, v] <= query < degree[u] + degree[v]: cnt -= 1\\n            ans.append(cnt)\\n        return ans\\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: You are given an array of integers nums (0-indexed) and an integer k. The score of a subarray (i, j) is defined as min(nums[i], nums[i+1], ..., nums[j]) * (j - i + 1). A good subarray is a subarray where i <= k <= j. Return the maximum possible score of a good subarray. Example 1: Input: nums = [1,4,3,7,4,5], k = 3 Output: 15 Explanation: The optimal subarray is (1, 5) with a score of min(4,3,7,4,5) * (5-1+1) = 3 * 5 = 15. Example 2: Input: nums = [5,5,4,5,4,1,1,1], k = 0 Output: 20 Explanation: The optimal subarray is (0, 4) with a score of min(5,5,4,5,4) * (4-0+1) = 4 * 5 = 20. Constraints: 1 <= nums.length <= 105 1 <= nums[i] <= 2 * 104 0 <= k < nums.length"}, {"role": "assistant", "content": "class Solution:\\n    def maximumScore(self, nums: List[int], k: int) -> int:\\n        left, right = k, k\\n        min_val = nums[k]\\n        max_score = min_val\\n        \\n        while left > 0 or right < len(nums) - 1:\\n            if left == 0 or (right < len(nums) - 1 and nums[right + 1] > nums[left - 1]):\\n                right += 1\\n            else:\\n                left -= 1\\n            min_val = min(min_val, nums[left], nums[right])\\n            max_score = max(max_score, min_val * (right - left + 1))\\n        \\n        return max_score\\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: You are given nums, an array of positive integers of size 2 * n. You must perform n operations on this array. In the ith operation (1-indexed), you will: Choose two elements, x and y. Receive a score of i * gcd(x, y). Remove x and y from nums. Return the maximum score you can receive after performing n operations. The function gcd(x, y) is the greatest common divisor of x and y. Example 1: Input: nums = [1,2] Output: 1 Explanation: The optimal choice of operations is: (1 * gcd(1, 2)) = 1 Example 2: Input: nums = [3,4,6,8] Output: 11 Explanation: The optimal choice of operations is: (1 * gcd(3, 6)) + (2 * gcd(4, 8)) = 3 + 8 = 11 Example 3: Input: nums = [1,2,3,4,5,6] Output: 14 Explanation: The optimal choice of operations is: (1 * gcd(1, 5)) + (2 * gcd(2, 4)) + (3 * gcd(3, 6)) = 1 + 4 + 9 = 14 Constraints: 1 <= n <= 7 nums.length == 2 * n 1 <= nums[i] <= 106"}, {"role": "assistant", "content": "class Solution:\\n    def maxScore(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        \\n       \\n        gcd_matrix = [[0] * n for _ in range(n)]\\n        for i in range(n):\\n            for j in range(i+1, n):\\n                gcd_matrix[i][j] = gcd_matrix[j][i] = gcd(nums[i], nums[j])\\n        \\n      \\n        dp = [0] * (1 << n)\\n        \\n        \\n        for state in range(1, 1 << n):\\n          \\n            cnt = bin(state).count(\\'1\\')\\n            \\n           \\n            if cnt % 2 == 1:\\n                continue\\n            \\n            \\n            for i in range(n):\\n                if not (state & (1 << i)):\\n                    continue\\n                for j in range(i+1, n):\\n                    if not (state & (1 << j)):\\n                        continue\\n                    nextState = state ^ (1 << i) ^ (1 << j)\\n                    dp[state] = max(dp[state], dp[nextState] + cnt // 2 * gcd_matrix[i][j])\\n        \\n        return dp[(1 << n) - 1]\\n\\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: Given a (0-indexed) integer array nums and two integers low and high, return the number of nice pairs. A nice pair is a pair (i, j) where 0 <= i < j < nums.length and low <= (nums[i] XOR nums[j]) <= high. Example 1: Input: nums = [1,4,2,7], low = 2, high = 6 Output: 6 Explanation: All nice pairs (i, j) are as follows: - (0, 1): nums[0] XOR nums[1] = 5 - (0, 2): nums[0] XOR nums[2] = 3 - (0, 3): nums[0] XOR nums[3] = 6 - (1, 2): nums[1] XOR nums[2] = 6 - (1, 3): nums[1] XOR nums[3] = 3 - (2, 3): nums[2] XOR nums[3] = 5 Example 2: Input: nums = [9,8,4,2,1], low = 5, high = 14 Output: 8 Explanation: All nice pairs (i, j) are as follows: \u200b\u200b\u200b\u200b\u200b - (0, 2): nums[0] XOR nums[2] = 13 - (0, 3): nums[0] XOR nums[3] = 11 - (0, 4): nums[0] XOR nums[4] = 8 - (1, 2): nums[1] XOR nums[2] = 12 - (1, 3): nums[1] XOR nums[3] = 10 - (1, 4): nums[1] XOR nums[4] = 9 - (2, 3): nums[2] XOR nums[3] = 6 - (2, 4): nums[2] XOR nums[4] = 5 Constraints: 1 <= nums.length <= 2 * 104 1 <= nums[i] <= 2 * 104 1 <= low <= high <= 2 * 104"}, {"role": "assistant", "content": "class Solution:\\n    def countPairs(self, nums: List[int], low: int, high: int) -> int:\\n        trie = Trie()\\n        ans = 0\\n        for x in nums: \\n            ans += trie.count(x, high+1) - trie.count(x, low)\\n            trie.insert(x)\\n        return ans \\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: You are given a positive integer primeFactors. You are asked to construct a positive integer n that satisfies the following conditions: The number of prime factors of n (not necessarily distinct) is at most primeFactors. The number of nice divisors of n is maximized. Note that a divisor of n is nice if it is divisible by every prime factor of n. For example, if n = 12, then its prime factors are [2,2,3], then 6 and 12 are nice divisors, while 3 and 4 are not. Return the number of nice divisors of n. Since that number can be too large, return it modulo 109 + 7. Note that a prime number is a natural number greater than 1 that is not a product of two smaller natural numbers. The prime factors of a number n is a list of prime numbers such that their product equals n. Example 1: Input: primeFactors = 5 Output: 6 Explanation: 200 is a valid value of n. It has 5 prime factors: [2,2,2,5,5], and it has 6 nice divisors: [10,20,40,50,100,200]. There is not other value of n that has at most 5 prime factors and more nice divisors. Example 2: Input: primeFactors = 8 Output: 18 Constraints: 1 <= primeFactors <= 109"}, {"role": "assistant", "content": "class Solution:\\n    def maxNiceDivisors(self, n: int) -> int:\\n        if n <= 2: return n\\n        i, c = divmod(n, 3)\\n        if not c: return pow(3, i, MOD)\\n        return (self.maxNiceDivisors(n-2)*2) % MOD\\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: You are given an array nums that consists of positive integers. The GCD of a sequence of numbers is defined as the greatest integer that divides all the numbers in the sequence evenly. For example, the GCD of the sequence [4,6,16] is 2. A subsequence of an array is a sequence that can be formed by removing some elements (possibly none) of the array. For example, [2,5,10] is a subsequence of [1,2,1,2,4,1,5,10]. Return the number of different GCDs among all non-empty subsequences of nums. Example 1: Input: nums = [6,10,3] Output: 5 Explanation: The figure shows all the non-empty subsequences and their GCDs. The different GCDs are 6, 10, 3, 2, and 1. Example 2: Input: nums = [5,15,40,5,6] Output: 7 Constraints: 1 <= nums.length <= 105 1 <= nums[i] <= 2 * 105"}, {"role": "assistant", "content": "class Solution:\\n    def countDifferentSubsequenceGCDs(self, nums: List[int]) -> int:\\n        nums = set(nums)\\n        \\n        ans = 0\\n        m = max(nums)\\n        for x in range(1, m+1): \\n            g = 0\\n            for xx in range(x, m+1, x): \\n                if xx in nums: \\n                    g = gcd(g, xx)\\n            if g == x: ans += 1\\n        return ans \\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: You are given a string s (0-indexed)\u200b\u200b\u200b\u200b\u200b\u200b. You are asked to perform the following operation on s\u200b\u200b\u200b\u200b\u200b\u200b until you get a sorted string: Find the largest index i such that 1 <= i < s.length and s[i] < s[i - 1]. Find the largest index j such that i <= j < s.length and s[k] < s[i - 1] for all the possible values of k in the range [i, j] inclusive. Swap the two characters at indices i - 1\u200b\u200b\u200b\u200b and j\u200b\u200b\u200b\u200b\u200b. Reverse the suffix starting at index i\u200b\u200b\u200b\u200b\u200b\u200b. Return the number of operations needed to make the string sorted. Since the answer can be too large, return it modulo 109 + 7. Example 1: Input: s = \"cba\" Output: 5 Explanation: The simulation goes as follows: Operation 1: i=2, j=2. Swap s[1] and s[2] to get s=\"cab\", then reverse the suffix starting at 2. Now, s=\"cab\". Operation 2: i=1, j=2. Swap s[0] and s[2] to get s=\"bac\", then reverse the suffix starting at 1. Now, s=\"bca\". Operation 3: i=2, j=2. Swap s[1] and s[2] to get s=\"bac\", then reverse the suffix starting at 2. Now, s=\"bac\". Operation 4: i=1, j=1. Swap s[0] and s[1] to get s=\"abc\", then reverse the suffix starting at 1. Now, s=\"acb\". Operation 5: i=2, j=2. Swap s[1] and s[2] to get s=\"abc\", then reverse the suffix starting at 2. Now, s=\"abc\". Example 2: Input: s = \"aabaa\" Output: 2 Explanation: The simulation goes as follows: Operation 1: i=3, j=4. Swap s[2] and s[4] to get s=\"aaaab\", then reverse the substring starting at 3. Now, s=\"aaaba\". Operation 2: i=4, j=4. Swap s[3] and s[4] to get s=\"aaaab\", then reverse the substring starting at 4. Now, s=\"aaaab\". Constraints: 1 <= s.length <= 3000 s\u200b\u200b\u200b\u200b\u200b\u200b consists only of lowercase English letters."}, {"role": "assistant", "content": "class Solution:\\n    def makeStringSorted(self, s: str) -> int:\\n        freq = [0]*26\\n        for c in s: freq[ord(c) - 97] += 1\\n        \\n        MOD = 1_000_000_007\\n        fac = cache(lambda x: x*fac(x-1)%MOD if x else 1)\\n        ifac = cache(lambda x: pow(fac(x), MOD-2, MOD)) # Fermat\\'s little theorem (a**(p-1) = 1 (mod p))\\n        \\n        ans, n = 0, len(s)\\n        for c in s: \\n            val = ord(c) - 97\\n            mult = fac(n-1)\\n            for k in range(26): mult *= ifac(freq[k])\\n            for k in range(val): ans += freq[k] * mult\\n            n -= 1\\n            freq[val] -= 1\\n        return ans % MOD\\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: The XOR sum of a list is the bitwise XOR of all its elements. If the list only contains one element, then its XOR sum will be equal to this element. For example, the XOR sum of [1,2,3,4] is equal to 1 XOR 2 XOR 3 XOR 4 = 4, and the XOR sum of [3] is equal to 3. You are given two 0-indexed arrays arr1 and arr2 that consist only of non-negative integers. Consider the list containing the result of arr1[i] AND arr2[j] (bitwise AND) for every (i, j) pair where 0 <= i < arr1.length and 0 <= j < arr2.length. Return the XOR sum of the aforementioned list. Example 1: Input: arr1 = [1,2,3], arr2 = [6,5] Output: 0 Explanation: The list = [1 AND 6, 1 AND 5, 2 AND 6, 2 AND 5, 3 AND 6, 3 AND 5] = [0,1,2,0,2,1]. The XOR sum = 0 XOR 1 XOR 2 XOR 0 XOR 2 XOR 1 = 0. Example 2: Input: arr1 = [12], arr2 = [4] Output: 4 Explanation: The list = [12 AND 4] = [4]. The XOR sum = 4. Constraints: 1 <= arr1.length, arr2.length <= 105 0 <= arr1[i], arr2[j] <= 109"}, {"role": "assistant", "content": "class Solution:\\n    #example 1 \\n    #result =[(1&6)^(1&5)^(2&6)^(2&5)^(3&6)^(3&5)]\\n                \\\\     /     \\\\    /      \\\\     /\\n    #           (1&(6^5)) ^ (2&(6^5)) ^ (3&(6^5))   \\n                   \\\\            |           /\\n                    \\\\           |          /\\n                     \\\\          |         /\\n                      \\\\         |        /\\n    #                  ((1^2^3) & (6^5))\\n    def getXORSum(self, a, b):\\n        x = 0 \\n        for i in range(len(a)):\\n            x = x ^ a[i]\\n        y = 0 \\n        for j in range(len(b)):\\n            y = y ^ b[j]\\n        return x & y\\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: You want to build n new buildings in a city. The new buildings will be built in a line and are labeled from 1 to n. However, there are city restrictions on the heights of the new buildings: The height of each building must be a non-negative integer. The height of the first building must be 0. The height difference between any two adjacent buildings cannot exceed 1. Additionally, there are city restrictions on the maximum height of specific buildings. These restrictions are given as a 2D integer array restrictions where restrictions[i] = [idi, maxHeighti] indicates that building idi must have a height less than or equal to maxHeighti. It is guaranteed that each building will appear at most once in restrictions, and building 1 will not be in restrictions. Return the maximum possible height of the tallest building. Example 1: Input: n = 5, restrictions = [[2,1],[4,1]] Output: 2 Explanation: The green area in the image indicates the maximum allowed height for each building. We can build the buildings with heights [0,1,2,1,2], and the tallest building has a height of 2. Example 2: Input: n = 6, restrictions = [] Output: 5 Explanation: The green area in the image indicates the maximum allowed height for each building. We can build the buildings with heights [0,1,2,3,4,5], and the tallest building has a height of 5. Example 3: Input: n = 10, restrictions = [[5,3],[2,5],[7,4],[10,3]] Output: 5 Explanation: The green area in the image indicates the maximum allowed height for each building. We can build the buildings with heights [0,1,2,3,3,4,4,5,4,3], and the tallest building has a height of 5. Constraints: 2 <= n <= 109 0 <= restrictions.length <= min(n - 1, 105) 2 <= idi <= n idi is unique. 0 <= maxHeighti <= 109"}, {"role": "assistant", "content": "class Solution:\\n    def maxBuilding(self, n: int, restrictions: List[List[int]]) -> int:\\n        restrictions.extend([[1, 0], [n, n-1]])\\n        restrictions.sort()\\n        \\n        for i in reversed(range(len(restrictions)-1)): \\n            restrictions[i][1] = min(restrictions[i][1], restrictions[i+1][1] + restrictions[i+1][0] - restrictions[i][0])\\n        \\n        ans = 0 \\n        for i in range(1, len(restrictions)): \\n            restrictions[i][1] = min(restrictions[i][1], restrictions[i-1][1] + restrictions[i][0] - restrictions[i-1][0])\\n            ans = max(ans, (restrictions[i-1][1] + restrictions[i][0] - restrictions[i-1][0] + restrictions[i][1])//2)\\n        return ans \\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: There is a hotel with n rooms. The rooms are represented by a 2D integer array rooms where rooms[i] = [roomIdi, sizei] denotes that there is a room with room number roomIdi and size equal to sizei. Each roomIdi is guaranteed to be unique. You are also given k queries in a 2D array queries where queries[j] = [preferredj, minSizej]. The answer to the jth query is the room number id of a room such that: The room has a size of at least minSizej, and abs(id - preferredj) is minimized, where abs(x) is the absolute value of x. If there is a tie in the absolute difference, then use the room with the smallest such id. If there is no such room, the answer is -1. Return an array answer of length k where answer[j] contains the answer to the jth query. Example 1: Input: rooms = [[2,2],[1,2],[3,2]], queries = [[3,1],[3,3],[5,2]] Output: [3,-1,3] Explanation: The answers to the queries are as follows: Query = [3,1]: Room number 3 is the closest as abs(3 - 3) = 0, and its size of 2 is at least 1. The answer is 3. Query = [3,3]: There are no rooms with a size of at least 3, so the answer is -1. Query = [5,2]: Room number 3 is the closest as abs(3 - 5) = 2, and its size of 2 is at least 2. The answer is 3. Example 2: Input: rooms = [[1,4],[2,3],[3,5],[4,1],[5,2]], queries = [[2,3],[2,4],[2,5]] Output: [2,1,3] Explanation: The answers to the queries are as follows: Query = [2,3]: Room number 2 is the closest as abs(2 - 2) = 0, and its size of 3 is at least 3. The answer is 2. Query = [2,4]: Room numbers 1 and 3 both have sizes of at least 4. The answer is 1 since it is smaller. Query = [2,5]: Room number 3 is the only room with a size of at least 5. The answer is 3. Constraints: n == rooms.length 1 <= n <= 105 k == queries.length 1 <= k <= 104 1 <= roomIdi, preferredj <= 107 1 <= sizei, minSizej <= 107"}, {"role": "assistant", "content": "class Solution:\\n    def closestRoom(self, rooms: List[List[int]], queries: List[List[int]]) -> List[int]:\\n        ans = [0] * len(queries)\\n        \\n        # sort queries to handle largest size queries first\\n        q = deque(sorted([(size, room, i) for i, (room, size) in enumerate(queries)], key=lambda a: (-a[0], a[1], a[2])))\\n\\n        # sort rooms by descending size\\n        rooms = deque(sorted(rooms, key=lambda x: -x[1]))\\n\\n        # current available room ids\\n        cands = []\\n        \\n        \\n        while q:\\n            size, room, i = q.popleft()\\n            # add room ids to candidates as long as top of room size meet the requirements\\n            while rooms and rooms[0][1] >= size:\\n                bisect.insort(cands, rooms.popleft()[0])\\n                    \\n            # if no room size available, return -1\\n            if not cands: ans[i] = -1\\n                \\n            # else use bisect to find optimal room ids\\n            else:\\n                loc = bisect.bisect_left(cands, room)\\n                if loc == 0: ans[i] = cands[loc]\\n                elif loc == len(cands): ans[i] = cands[-1]\\n                else: ans[i] = cands[loc - 1] if room - cands[loc - 1] <= cands[loc] - room else cands[loc]\\n        \\n        return ans"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: You are given a 2D integer array intervals, where intervals[i] = [lefti, righti] describes the ith interval starting at lefti and ending at righti (inclusive). The size of an interval is defined as the number of integers it contains, or more formally righti - lefti + 1. You are also given an integer array queries. The answer to the jth query is the size of the smallest interval i such that lefti <= queries[j] <= righti. If no such interval exists, the answer is -1. Return an array containing the answers to the queries. Example 1: Input: intervals = [[1,4],[2,4],[3,6],[4,4]], queries = [2,3,4,5] Output: [3,3,1,4] Explanation: The queries are processed as follows: - Query = 2: The interval [2,4] is the smallest interval containing 2. The answer is 4 - 2 + 1 = 3. - Query = 3: The interval [2,4] is the smallest interval containing 3. The answer is 4 - 2 + 1 = 3. - Query = 4: The interval [4,4] is the smallest interval containing 4. The answer is 4 - 4 + 1 = 1. - Query = 5: The interval [3,6] is the smallest interval containing 5. The answer is 6 - 3 + 1 = 4. Example 2: Input: intervals = [[2,3],[2,5],[1,8],[20,25]], queries = [2,19,5,22] Output: [2,-1,4,6] Explanation: The queries are processed as follows: - Query = 2: The interval [2,3] is the smallest interval containing 2. The answer is 3 - 2 + 1 = 2. - Query = 19: None of the intervals contain 19. The answer is -1. - Query = 5: The interval [2,5] is the smallest interval containing 5. The answer is 5 - 2 + 1 = 4. - Query = 22: The interval [20,25] is the smallest interval containing 22. The answer is 25 - 20 + 1 = 6. Constraints: 1 <= intervals.length <= 105 1 <= queries.length <= 105 intervals[i].length == 2 1 <= lefti <= righti <= 107 1 <= queries[j] <= 107"}, {"role": "assistant", "content": "class Solution:\\n    def minInterval(self, intervals: List[List[int]], queries: List[int]) -> List[int]:\\n        \\n        intervals.sort(key = lambda x:x[1]-x[0])\\n        q = sorted([qu,i] for i,qu in enumerate(queries))\\n        res=[-1]*len(queries)\\n\\t\\t\\n        for left,right in intervals:\\n            ind = bisect.bisect(q,[left])\\n            while ind<len(q) and q[ind][0]<=right:\\n                res[q.pop(ind)[1]]=right-left+1\\n        return res\\n\\t\\t\\nFeel free to ask if you have any doubt. \\uD83E\\uDD17\\n**Thanku** and do **Upvote** if you got any help !!\\uD83E\\uDD1E"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: There is a directed graph of n colored nodes and m edges. The nodes are numbered from 0 to n - 1. You are given a string colors where colors[i] is a lowercase English letter representing the color of the ith node in this graph (0-indexed). You are also given a 2D array edges where edges[j] = [aj, bj] indicates that there is a directed edge from node aj to node bj. A valid path in the graph is a sequence of nodes x1 -> x2 -> x3 -> ... -> xk such that there is a directed edge from xi to xi+1 for every 1 <= i < k. The color value of the path is the number of nodes that are colored the most frequently occurring color along that path. Return the largest color value of any valid path in the given graph, or -1 if the graph contains a cycle. Example 1: Input: colors = \"abaca\", edges = [[0,1],[0,2],[2,3],[3,4]] Output: 3 Explanation: The path 0 -> 2 -> 3 -> 4 contains 3 nodes that are colored \"a\" (red in the above image). Example 2: Input: colors = \"a\", edges = [[0,0]] Output: -1 Explanation: There is a cycle from 0 to 0. Constraints: n == colors.length m == edges.length 1 <= n <= 105 0 <= m <= 105 colors consists of lowercase English letters. 0 <= aj, bj < n"}, {"role": "assistant", "content": "class Solution:\\r\\n    def largestPathValue(self, colors: str, edges: List[List[int]]) -> int:\\r\\n        n = len(colors)\\r\\n        indegrees = [0] * n\\r\\n        graph = [[] for _ in range(n)]\\r\\n        for edge in edges:\\r\\n            graph[edge[0]].append(edge[1])\\r\\n            indegrees[edge[1]] += 1\\r\\n        zero_indegree = deque()\\r\\n        for i in range(n):\\r\\n            if indegrees[i] == 0:\\r\\n                zero_indegree.append(i)\\r\\n        counts = [[0]*26 for _ in range(n)]\\r\\n        for i in range(n):\\r\\n            counts[i][ord(colors[i]) - ord(\\'a\\')] += 1\\r\\n        max_count = 0\\r\\n        visited = 0\\r\\n        while zero_indegree:\\r\\n            u = zero_indegree.popleft()\\r\\n            visited += 1\\r\\n            for v in graph[u]:\\r\\n                for i in range(26):\\r\\n                    counts[v][i] = max(counts[v][i], counts[u][i] + (ord(colors[v]) - ord(\\'a\\') == i))\\r\\n                indegrees[v] -= 1\\r\\n                if indegrees[v] == 0:\\r\\n                    zero_indegree.append(v)\\r\\n            max_count = max(max_count, max(counts[u]))\\r\\n        return max_count if visited == n else -1\\r\\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: Given an integer array nums, return the sum of floor(nums[i] / nums[j]) for all pairs of indices 0 <= i, j < nums.length in the array. Since the answer may be too large, return it modulo 109 + 7. The floor() function returns the integer part of the division. Example 1: Input: nums = [2,5,9] Output: 10 Explanation: floor(2 / 5) = floor(2 / 9) = floor(5 / 9) = 0 floor(2 / 2) = floor(5 / 5) = floor(9 / 9) = 1 floor(5 / 2) = 2 floor(9 / 2) = 4 floor(9 / 5) = 1 We calculate the floor of the division for every pair of indices in the array then sum them up. Example 2: Input: nums = [7,7,7,7,7,7,7] Output: 49 Constraints: 1 <= nums.length <= 105 1 <= nums[i] <= 105"}, {"role": "assistant", "content": "class Solution:\\n    def sumOfFlooredPairs(self, nums: List[int]) -> int:\\n        sumP = 0 #To store the value of Sum of floor values\\n        for i in nums: #Traverse every element in nums\\n            for j in nums: #Traverse every element in nums\\n                sumP += (j//i) #Simply do floor division and add the number to sumP\\n        return sumP % (10**9 +7)#return the sumof the pairs\\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: There are n uniquely-sized sticks whose lengths are integers from 1 to n. You want to arrange the sticks such that exactly k sticks are visible from the left. A stick is visible from the left if there are no longer sticks to the left of it. For example, if the sticks are arranged [1,3,2,5,4], then the sticks with lengths 1, 3, and 5 are visible from the left. Given n and k, return the number of such arrangements. Since the answer may be large, return it modulo 109 + 7. Example 1: Input: n = 3, k = 2 Output: 3 Explanation: [1,3,2], [2,3,1], and [2,1,3] are the only arrangements such that exactly 2 sticks are visible. The visible sticks are underlined. Example 2: Input: n = 5, k = 5 Output: 1 Explanation: [1,2,3,4,5] is the only arrangement such that all 5 sticks are visible. The visible sticks are underlined. Example 3: Input: n = 20, k = 11 Output: 647427950 Explanation: There are 647427950 (mod 109 + 7) ways to rearrange the sticks such that exactly 11 sticks are visible. Constraints: 1 <= n <= 1000 1 <= k <= n"}, {"role": "assistant", "content": "class Solution:\\n    def rearrangeSticks(self, n: int, k: int) -> int:\\n        \\n        @cache \\n        def fn(n, k): \\n            \"\"\"Return number of ways to rearrange n sticks to that k are visible.\"\"\"\\n            if n == k: return 1\\n            if k == 0: return 0\\n            return ((n-1)*fn(n-1, k) + fn(n-1, k-1)) % 1_000_000_007\\n        \\n        return fn(n, k) \\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: Alice and Bob take turns playing a game, with Alice starting first. There are n stones arranged in a row. On each player's turn, while the number of stones is more than one, they will do the following: Choose an integer x > 1, and remove the leftmost x stones from the row. Add the sum of the removed stones' values to the player's score. Place a new stone, whose value is equal to that sum, on the left side of the row. The game stops when only one stone is left in the row. The score difference between Alice and Bob is (Alice's score - Bob's score). Alice's goal is to maximize the score difference, and Bob's goal is the minimize the score difference. Given an integer array stones of length n where stones[i] represents the value of the ith stone from the left, return the score difference between Alice and Bob if they both play optimally. Example 1: Input: stones = [-1,2,-3,4,-5] Output: 5 Explanation: - Alice removes the first 4 stones, adds (-1) + 2 + (-3) + 4 = 2 to her score, and places a stone of value 2 on the left. stones = [2,-5]. - Bob removes the first 2 stones, adds 2 + (-5) = -3 to his score, and places a stone of value -3 on the left. stones = [-3]. The difference between their scores is 2 - (-3) = 5. Example 2: Input: stones = [7,-6,5,10,5,-2,-6] Output: 13 Explanation: - Alice removes all stones, adds 7 + (-6) + 5 + 10 + 5 + (-2) + (-6) = 13 to her score, and places a stone of value 13 on the left. stones = [13]. The difference between their scores is 13 - 0 = 13. Example 3: Input: stones = [-10,-12] Output: -22 Explanation: - Alice can only make one move, which is to remove both stones. She adds (-10) + (-12) = -22 to her score and places a stone of value -22 on the left. stones = [-22]. The difference between their scores is (-22) - 0 = -22. Constraints: n == stones.length 2 <= n <= 105 -104 <= stones[i] <= 104"}, {"role": "assistant", "content": "class Solution:\\n    def stoneGameVIII(self, s: List[int]) -> int:\\n        s, res = list(accumulate(s)), 0\\n        for i in range(len(s) - 1, 0, -1):\\n            res = s[i] if i == len(s) - 1 else max(res, s[i] - res)\\n        return res\\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: You are given two integer arrays nums1 and nums2 of length n. The XOR sum of the two integer arrays is (nums1[0] XOR nums2[0]) + (nums1[1] XOR nums2[1]) + ... + (nums1[n - 1] XOR nums2[n - 1]) (0-indexed). For example, the XOR sum of [1,2,3] and [3,2,1] is equal to (1 XOR 3) + (2 XOR 2) + (3 XOR 1) = 2 + 0 + 2 = 4. Rearrange the elements of nums2 such that the resulting XOR sum is minimized. Return the XOR sum after the rearrangement. Example 1: Input: nums1 = [1,2], nums2 = [2,3] Output: 2 Explanation: Rearrange nums2 so that it becomes [3,2]. The XOR sum is (1 XOR 3) + (2 XOR 2) = 2 + 0 = 2. Example 2: Input: nums1 = [1,0,3], nums2 = [5,3,4] Output: 8 Explanation: Rearrange nums2 so that it becomes [5,4,3]. The XOR sum is (1 XOR 5) + (0 XOR 4) + (3 XOR 3) = 4 + 4 + 0 = 8. Constraints: n == nums1.length n == nums2.length 1 <= n <= 14 0 <= nums1[i], nums2[i] <= 107"}, {"role": "assistant", "content": "class Solution:\\n    def minimumXORSum(self, a: List[int], b: List[int]) -> int:\\n        @cache\\n        def dp(mask: int) -> int:\\n            i = bin(mask).count(\"1\")\\n            if i >= len(a):\\n                return 0\\n            return min((a[i] ^ b[j]) + dp(mask + (1 << j)) \\n                       for j in range(len(b)) if mask & (1 << j) == 0)\\n        return dp(0)\\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: You are given an integer hoursBefore, the number of hours you have to travel to your meeting. To arrive at your meeting, you have to travel through n roads. The road lengths are given as an integer array dist of length n, where dist[i] describes the length of the ith road in kilometers. In addition, you are given an integer speed, which is the speed (in km/h) you will travel at. After you travel road i, you must rest and wait for the next integer hour before you can begin traveling on the next road. Note that you do not have to rest after traveling the last road because you are already at the meeting. For example, if traveling a road takes 1.4 hours, you must wait until the 2 hour mark before traveling the next road. If traveling a road takes exactly 2 hours, you do not need to wait. However, you are allowed to skip some rests to be able to arrive on time, meaning you do not need to wait for the next integer hour. Note that this means you may finish traveling future roads at different hour marks. For example, suppose traveling the first road takes 1.4 hours and traveling the second road takes 0.6 hours. Skipping the rest after the first road will mean you finish traveling the second road right at the 2 hour mark, letting you start traveling the third road immediately. Return the minimum number of skips required to arrive at the meeting on time, or -1 if it is impossible. Example 1: Input: dist = [1,3,2], speed = 4, hoursBefore = 2 Output: 1 Explanation: Without skipping any rests, you will arrive in (1/4 + 3/4) + (3/4 + 1/4) + (2/4) = 2.5 hours. You can skip the first rest to arrive in ((1/4 + 0) + (3/4 + 0)) + (2/4) = 1.5 hours. Note that the second rest is shortened because you finish traveling the second road at an integer hour due to skipping the first rest. Example 2: Input: dist = [7,3,5,5], speed = 2, hoursBefore = 10 Output: 2 Explanation: Without skipping any rests, you will arrive in (7/2 + 1/2) + (3/2 + 1/2) + (5/2 + 1/2) + (5/2) = 11.5 hours. You can skip the first and third rest to arrive in ((7/2 + 0) + (3/2 + 0)) + ((5/2 + 0) + (5/2)) = 10 hours. Example 3: Input: dist = [7,3,5,5], speed = 1, hoursBefore = 10 Output: -1 Explanation: It is impossible to arrive at the meeting on time even if you skip all the rests. Constraints: n == dist.length 1 <= n <= 1000 1 <= dist[i] <= 105 1 <= speed <= 106 1 <= hoursBefore <= 107"}, {"role": "assistant", "content": "class Solution:\\n    def minSkips(self, dist: List[int], speed: int, hoursBefore: int) -> int:\\n        if sum(dist)/speed > hoursBefore: return -1 # impossible \\n        \\n        @cache\\n        def fn(i, k): \\n            \"\"\"Return min time (in distance) of traveling first i roads with k skips.\"\"\"\\n            if k < 0: return inf # impossible \\n            if i == 0: return 0 \\n            return min(ceil((fn(i-1, k) + dist[i-1])/speed) * speed, dist[i-1] + fn(i-1, k-1))\\n        \\n        for k in range(len(dist)):\\n            if fn(len(dist)-1, k) + dist[-1] <= hoursBefore*speed: return k \\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: You have n packages that you are trying to place in boxes, one package in each box. There are m suppliers that each produce boxes of different sizes (with infinite supply). A package can be placed in a box if the size of the package is less than or equal to the size of the box. The package sizes are given as an integer array packages, where packages[i] is the size of the ith package. The suppliers are given as a 2D integer array boxes, where boxes[j] is an array of box sizes that the jth supplier produces. You want to choose a single supplier and use boxes from them such that the total wasted space is minimized. For each package in a box, we define the space wasted to be size of the box - size of the package. The total wasted space is the sum of the space wasted in all the boxes. For example, if you have to fit packages with sizes [2,3,5] and the supplier offers boxes of sizes [4,8], you can fit the packages of size-2 and size-3 into two boxes of size-4 and the package with size-5 into a box of size-8. This would result in a waste of (4-2) + (4-3) + (8-5) = 6. Return the minimum total wasted space by choosing the box supplier optimally, or -1 if it is impossible to fit all the packages inside boxes. Since the answer may be large, return it modulo 109 + 7. Example 1: Input: packages = [2,3,5], boxes = [[4,8],[2,8]] Output: 6 Explanation: It is optimal to choose the first supplier, using two size-4 boxes and one size-8 box. The total waste is (4-2) + (4-3) + (8-5) = 6. Example 2: Input: packages = [2,3,5], boxes = [[1,4],[2,3],[3,4]] Output: -1 Explanation: There is no box that the package of size 5 can fit in. Example 3: Input: packages = [3,5,8,10,11,12], boxes = [[12],[11,9],[10,5,14]] Output: 9 Explanation: It is optimal to choose the third supplier, using two size-5 boxes, two size-10 boxes, and two size-14 boxes. The total waste is (5-3) + (5-5) + (10-8) + (10-10) + (14-11) + (14-12) = 9. Constraints: n == packages.length m == boxes.length 1 <= n <= 105 1 <= m <= 105 1 <= packages[i] <= 105 1 <= boxes[j].length <= 105 1 <= boxes[j][k] <= 105 sum(boxes[j].length) <= 105 The elements in boxes[j] are distinct."}, {"role": "assistant", "content": "class Solution:\\n    def minWastedSpace(self, packages: List[int], boxes: List[List[int]]) -> int:\\n        packages.sort()\\n        prefix = [0]\\n        for x in packages: prefix.append(prefix[-1] + x)\\n        \\n        ans = inf \\n        for box in boxes: \\n            box.sort()\\n            if packages[-1] <= box[-1]: \\n                kk = val = 0 \\n                for x in box: \\n                    k = bisect_right(packages, x)\\n                    val += (k - kk) * x - (prefix[k] - prefix[kk])\\n                    kk = k\\n                ans = min(ans, val)\\n        return ans % 1_000_000_007 if ans < inf else -1 \\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: You are given a valid boolean expression as a string expression consisting of the characters '1','0','&' (bitwise AND operator),'|' (bitwise OR operator),'(', and ')'. For example, \"()1|1\" and \"(1)&()\" are not valid while \"1\", \"(((1))|(0))\", and \"1|(0&(1))\" are valid expressions. Return the minimum cost to change the final value of the expression. For example, if expression = \"1|1|(0&0)&1\", its value is 1|1|(0&0)&1 = 1|1|0&1 = 1|0&1 = 1&1 = 1. We want to apply operations so that the new expression evaluates to 0. The cost of changing the final value of an expression is the number of operations performed on the expression. The types of operations are described as follows: Turn a '1' into a '0'. Turn a '0' into a '1'. Turn a '&' into a '|'. Turn a '|' into a '&'. Note: '&' does not take precedence over '|' in the order of calculation. Evaluate parentheses first, then in left-to-right order. Example 1: Input: expression = \"1&(0|1)\" Output: 1 Explanation: We can turn \"1&(0|1)\" into \"1&(0&1)\" by changing the '|' to a '&' using 1 operation. The new expression evaluates to 0. Example 2: Input: expression = \"(0&0)&(0&0&0)\" Output: 3 Explanation: We can turn \"(0&0)&(0&0&0)\" into \"(0|1)|(0&0&0)\" using 3 operations. The new expression evaluates to 1. Example 3: Input: expression = \"(0|(1|0&1))\" Output: 1 Explanation: We can turn \"(0|(1|0&1))\" into \"(0|(0|0&1))\" using 1 operation. The new expression evaluates to 0. Constraints: 1 <= expression.length <= 105 expression only contains '1','0','&','|','(', and ')' All parentheses are properly matched. There will be no empty parentheses (i.e: \"()\" is not a substring of expression)."}, {"role": "assistant", "content": "class Solution:\\n    def minOperationsToFlip(self, expression: str) -> int:\\n        loc = {}\\n        stack = []\\n        for i in reversed(range(len(expression))):\\n            if expression[i] == \")\": stack.append(i)\\n            elif expression[i] == \"(\": loc[stack.pop()] = i \\n        \\n        def fn(lo, hi): \\n            \"\"\"Return value and min op to change value.\"\"\"\\n            if lo == hi: return int(expression[lo]), 1\\n            if expression[hi] == \")\" and loc[hi] == lo: return fn(lo+1, hi-1) # strip parenthesis \\n            mid = loc.get(hi, hi) - 1 \\n            v, c = fn(mid+1, hi)\\n            vv, cc = fn(lo, mid-1)\\n            if expression[mid] == \"|\": \\n                val = v | vv \\n                if v == vv == 0: chg = min(c, cc)\\n                elif v == vv == 1: chg = 1 + min(c, cc)\\n                else: chg = 1 \\n            else: # expression[k] == \"&\"\\n                val = v & vv\\n                if v == vv == 0: chg = 1 + min(c, cc)\\n                elif v == vv == 1: chg = min(c, cc)\\n                else: chg = 1\\n            return val, chg\\n                    \\n        return fn(0, len(expression)-1)[1]\\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: There is a tournament where n players are participating. The players are standing in a single row and are numbered from 1 to n based on their initial standing position (player 1 is the first player in the row, player 2 is the second player in the row, etc.). The tournament consists of multiple rounds (starting from round number 1). In each round, the ith player from the front of the row competes against the ith player from the end of the row, and the winner advances to the next round. When the number of players is odd for the current round, the player in the middle automatically advances to the next round. For example, if the row consists of players 1, 2, 4, 6, 7 Player 1 competes against player 7. Player 2 competes against player 6. Player 4 automatically advances to the next round. After each round is over, the winners are lined back up in the row based on the original ordering assigned to them initially (ascending order). The players numbered firstPlayer and secondPlayer are the best in the tournament. They can win against any other player before they compete against each other. If any two other players compete against each other, either of them might win, and thus you may choose the outcome of this round. Given the integers n, firstPlayer, and secondPlayer, return an integer array containing two values, the earliest possible round number and the latest possible round number in which these two players will compete against each other, respectively. Example 1: Input: n = 11, firstPlayer = 2, secondPlayer = 4 Output: [3,4] Explanation: One possible scenario which leads to the earliest round number: First round: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 Second round: 2, 3, 4, 5, 6, 11 Third round: 2, 3, 4 One possible scenario which leads to the latest round number: First round: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 Second round: 1, 2, 3, 4, 5, 6 Third round: 1, 2, 4 Fourth round: 2, 4 Example 2: Input: n = 5, firstPlayer = 1, secondPlayer = 5 Output: [1,1] Explanation: The players numbered 1 and 5 compete in the first round. There is no way to make them compete in any other round. Constraints: 2 <= n <= 28 1 <= firstPlayer < secondPlayer <= n"}, {"role": "assistant", "content": "class Solution:\\n    def earliestAndLatest(self, n: int, firstPlayer: int, secondPlayer: int) -> List[int]:\\n        firstPlayer, secondPlayer = firstPlayer-1, secondPlayer-1 # 0-indexed\\n        \\n        @cache\\n        def fn(k, mask): \\n            \"\"\"Return earliest and latest rounds.\"\"\"\\n            can = deque()\\n            for i in range(n): \\n                if mask & (1 << i): can.append(i)\\n                    \\n            cand = [] # eliminated player\\n            while len(can) > 1: \\n                p1, p2 = can.popleft(), can.pop()\\n                if p1 == firstPlayer and p2 == secondPlayer or p1 == secondPlayer and p2 == firstPlayer: return [k, k] # game of interest \\n                if p1 in (firstPlayer, secondPlayer): cand.append([p2]) # p2 eliminated \\n                elif p2 in (firstPlayer, secondPlayer): cand.append([p1]) # p1 eliminated \\n                else: cand.append([p1, p2]) # both could be elimited \\n            \\n            minn, maxx = inf, -inf\\n            for x in product(*cand): \\n                mask0 = mask\\n                for i in x: mask0 ^= 1 << i\\n                mn, mx = fn(k+1, mask0)\\n                minn = min(minn, mn)\\n                maxx = max(maxx, mx)\\n            return minn, maxx\\n        \\n        return fn(1, (1<<n)-1)\\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: You are an ant tasked with adding n new rooms numbered 0 to n-1 to your colony. You are given the expansion plan as a 0-indexed integer array of length n, prevRoom, where prevRoom[i] indicates that you must build room prevRoom[i] before building room i, and these two rooms must be connected directly. Room 0 is already built, so prevRoom[0] = -1. The expansion plan is given such that once all the rooms are built, every room will be reachable from room 0. You can only build one room at a time, and you can travel freely between rooms you have already built only if they are connected. You can choose to build any room as long as its previous room is already built. Return the number of different orders you can build all the rooms in. Since the answer may be large, return it modulo 109 + 7. Example 1: Input: prevRoom = [-1,0,1] Output: 1 Explanation: There is only one way to build the additional rooms: 0 \u2192 1 \u2192 2 Example 2: Input: prevRoom = [-1,0,0,1,2] Output: 6 Explanation: The 6 ways are: 0 \u2192 1 \u2192 3 \u2192 2 \u2192 4 0 \u2192 2 \u2192 4 \u2192 1 \u2192 3 0 \u2192 1 \u2192 2 \u2192 3 \u2192 4 0 \u2192 1 \u2192 2 \u2192 4 \u2192 3 0 \u2192 2 \u2192 1 \u2192 3 \u2192 4 0 \u2192 2 \u2192 1 \u2192 4 \u2192 3 Constraints: n == prevRoom.length 2 <= n <= 105 prevRoom[0] == -1 0 <= prevRoom[i] < n for all 1 <= i < n Every room is reachable from room 0 once all the rooms are built."}, {"role": "assistant", "content": "class Solution:\\n    def waysToBuildRooms(self, prevRoom: List[int]) -> int:\\n        tree = defaultdict(list)\\n        for i, x in enumerate(prevRoom): tree[x].append(i)\\n        \\n        def fn(n): \\n            \"\"\"Return number of nodes and ways to build sub-tree.\"\"\"\\n            if not tree[n]: return 1, 1 # leaf \\n            c, m = 0, 1\\n            for nn in tree[n]: \\n                cc, mm = fn(nn)\\n                c += cc\\n                m = (m * comb(c, cc) * mm) % 1_000_000_007\\n            return c+1, m\\n        \\n        return fn(0)[1] \\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: There is a country of n cities numbered from 0 to n - 1. In this country, there is a road connecting every pair of cities. There are m friends numbered from 0 to m - 1 who are traveling through the country. Each one of them will take a path consisting of some cities. Each path is represented by an integer array that contains the visited cities in order. The path may contain a city more than once, but the same city will not be listed consecutively. Given an integer n and a 2D integer array paths where paths[i] is an integer array representing the path of the ith friend, return the length of the longest common subpath that is shared by every friend's path, or 0 if there is no common subpath at all. A subpath of a path is a contiguous sequence of cities within that path. Example 1: Input: n = 5, paths = [[0,1,2,3,4], [2,3,4], [4,0,1,2,3]] Output: 2 Explanation: The longest common subpath is [2,3]. Example 2: Input: n = 3, paths = [[0],[1],[2]] Output: 0 Explanation: There is no common subpath shared by the three paths. Example 3: Input: n = 5, paths = [[0,1,2,3,4], [4,3,2,1,0]] Output: 1 Explanation: The possible longest common subpaths are [0], [1], [2], [3], and [4]. All have a length of 1. Constraints: 1 <= n <= 105 m == paths.length 2 <= m <= 105 sum(paths[i].length) <= 105 0 <= paths[i][j] < n The same city is not listed multiple times consecutively in paths[i]."}, {"role": "assistant", "content": "class Solution:\\n    def longestCommonSubpath(self, n, paths):\\n        def get_hash(path,k):\\n            h, base, ans = 0, 1<<17, set()\\n\\n            for i in range(len(path)):\\n                h = h*base + path[i]\\n\\n                if i >= k:\\n                    h -= path[i-k]*pow(base,k,self.mod)\\n\\n                h = h%self.mod\\n\\n                if i >= k-1:\\n                    ans.add(h)\\n\\n            return ans\\n\\n        self.mod =  (1<<128)-159\\n\\n        low, high = 0, min(len(p) for p in paths)\\n\\n        while low <= high:\\n            mid = (low+high)//2\\n            tt = set.intersection(*[get_hash(p,mid) for p in paths])\\n\\n            if len(tt):\\n                low = mid + 1\\n            else:\\n                high = mid - 1\\n\\n        return high\\n\\n\\n\\n\\n\\n\\n\\n        \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n        \\n\\n        \\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: There is a country of n cities numbered from 0 to n - 1 where all the cities are connected by bi-directional roads. The roads are represented as a 2D integer array edges where edges[i] = [xi, yi, timei] denotes a road between cities xi and yi that takes timei minutes to travel. There may be multiple roads of differing travel times connecting the same two cities, but no road connects a city to itself. Each time you pass through a city, you must pay a passing fee. This is represented as a 0-indexed integer array passingFees of length n where passingFees[j] is the amount of dollars you must pay when you pass through city j. In the beginning, you are at city 0 and want to reach city n - 1 in maxTime minutes or less. The cost of your journey is the summation of passing fees for each city that you passed through at some moment of your journey (including the source and destination cities). Given maxTime, edges, and passingFees, return the minimum cost to complete your journey, or -1 if you cannot complete it within maxTime minutes. Example 1: Input: maxTime = 30, edges = [[0,1,10],[1,2,10],[2,5,10],[0,3,1],[3,4,10],[4,5,15]], passingFees = [5,1,2,20,20,3] Output: 11 Explanation: The path to take is 0 -> 1 -> 2 -> 5, which takes 30 minutes and has $11 worth of passing fees. Example 2: Input: maxTime = 29, edges = [[0,1,10],[1,2,10],[2,5,10],[0,3,1],[3,4,10],[4,5,15]], passingFees = [5,1,2,20,20,3] Output: 48 Explanation: The path to take is 0 -> 3 -> 4 -> 5, which takes 26 minutes and has $48 worth of passing fees. You cannot take path 0 -> 1 -> 2 -> 5 since it would take too long. Example 3: Input: maxTime = 25, edges = [[0,1,10],[1,2,10],[2,5,10],[0,3,1],[3,4,10],[4,5,15]], passingFees = [5,1,2,20,20,3] Output: -1 Explanation: There is no way to reach city 5 from city 0 within 25 minutes. Constraints: 1 <= maxTime <= 1000 n == passingFees.length 2 <= n <= 1000 n - 1 <= edges.length <= 1000 0 <= xi, yi <= n - 1 1 <= timei <= 1000 1 <= passingFees[j] <= 1000 The graph may contain multiple edges between two nodes. The graph does not contain self loops."}, {"role": "assistant", "content": "class Solution:\\n    def minCost(self, maxTime: int, edges: List[List[int]], passingFees: List[int]) -> int:\\n        n = len(passingFees)\\n        graph = defaultdict(list)\\n\\n        for u, v, t in edges:\\n            graph[u].append((v, t))\\n            graph[v].append((u, t)) \\n        queue = [(passingFees[0], 0, 0)]\\n        dist = [float(\\'inf\\') for i in range(n)]\\n        while queue:\\n            cost, time, city = heappop(queue)\\n            \\n            if city == n - 1:\\n                return cost\\n            \\n            for neigh, t in graph[city]:\\n                new_time = time + t\\n                if (dist[neigh] > t+time) and (new_time <= maxTime):\\n                    heappush(queue, (cost + passingFees[neigh], new_time, neigh))\\n                    dist[neigh] = new_time\\n                    \\n        return -1\\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: You are given two integers m and n. Consider an m x n grid where each cell is initially white. You can paint each cell red, green, or blue. All cells must be painted. Return the number of ways to color the grid with no two adjacent cells having the same color. Since the answer can be very large, return it modulo 109 + 7. Example 1: Input: m = 1, n = 1 Output: 3 Explanation: The three possible colorings are shown in the image above. Example 2: Input: m = 1, n = 2 Output: 6 Explanation: The six possible colorings are shown in the image above. Example 3: Input: m = 5, n = 5 Output: 580986 Constraints: 1 <= m <= 5 1 <= n <= 1000"}, {"role": "assistant", "content": "class Solution:\\n    def colorTheGrid(self, m: int, n: int) -> int:\\n        \\'\\'\\'\\n            Solves a given recurrence relation\\n            @params dp: the nth sum per ith equation\\n            @params coeff: coefficients for the ith equation\\n        \\'\\'\\'\\n        def solve_rel(dp, coeff):\\n            for _ in range(n - 1):\\n                for i in range(len(dp)):\\n                    tmp = 0\\n                    for j, c in enumerate(coeff[i]):\\n                        # If j >= i we must add the second last\\n                        #value appended, we already updated that dp.\\n                        tmp += c*dp[j][-1 if j >= i else -2]\\n                    dp[i].append(tmp)\\n\\n            return sum(e[-1] for e in dp) % 1000000007\\n\\n\\n        if m == 1:\\n            return solve_rel([[3]], [[2]])\\n        if m == 2:\\n            return solve_rel([[6]], [[3]])\\n        elif m == 3:\\n            return solve_rel([[6], [6]], [[3,2], [2,2]])\\n        elif m == 4:\\n            return solve_rel(\\n                [[6], [6], [6], [6]], \\n                [[3,1,2,2], [1,2,1,1], [2,1,2,2], [2,1,2,2]])\\n        else:\\n            return solve_rel(\\n                [[6], [6], [6], [6], [6], [6], [6], [6]],\\n                [\\n                    [2,1,1,1,2,2,1,1], \\n                    [1,2,1,1,0,0,1,0], \\n                    [1,1,2,1,1,1,1,1], \\n                    [1,1,1,2,2,2,1,1], \\n                    [2,0,1,2,3,2,1,2], \\n                    [2,0,1,2,2,2,1,2], \\n                    [1,1,1,1,1,1,2,1], \\n                    [1,0,1,1,2,2,1,2]\\n                ])\\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: You are given n BST (binary search tree) root nodes for n separate BSTs stored in an array trees (0-indexed). Each BST in trees has at most 3 nodes, and no two roots have the same value. In one operation, you can: Select two distinct indices i and j such that the value stored at one of the leaves of trees[i] is equal to the root value of trees[j]. Replace the leaf node in trees[i] with trees[j]. Remove trees[j] from trees. Return the root of the resulting BST if it is possible to form a valid BST after performing n - 1 operations, or null if it is impossible to create a valid BST. A BST (binary search tree) is a binary tree where each node satisfies the following property: Every node in the node's left subtree has a value strictly less than the node's value. Every node in the node's right subtree has a value strictly greater than the node's value. A leaf is a node that has no children. Example 1: Input: trees = [[2,1],[3,2,5],[5,4]] Output: [3,2,5,1,null,4] Explanation: In the first operation, pick i=1 and j=0, and merge trees[0] into trees[1]. Delete trees[0], so trees = [[3,2,5,1],[5,4]]. In the second operation, pick i=0 and j=1, and merge trees[1] into trees[0]. Delete trees[1], so trees = [[3,2,5,1,null,4]]. The resulting tree, shown above, is a valid BST, so return its root. Example 2: Input: trees = [[5,3,8],[3,2,6]] Output: [] Explanation: Pick i=0 and j=1 and merge trees[1] into trees[0]. Delete trees[1], so trees = [[5,3,8,2,6]]. The resulting tree is shown above. This is the only valid operation that can be performed, but the resulting tree is not a valid BST, so return null. Example 3: Input: trees = [[5,4],[3]] Output: [] Explanation: It is impossible to perform any operations. Constraints: n == trees.length 1 <= n <= 5 * 104 The number of nodes in each tree is in the range [1, 3]. Each node in the input may have children but no grandchildren. No two roots of trees have the same value. All the trees in the input are valid BSTs. 1 <= TreeNode.val <= 5 * 104."}, {"role": "assistant", "content": "class Solution:\\n    def canMerge(self, trees: List[TreeNode]) -> Optional[TreeNode]:\\n\\n        leaves = set()\\n        treeDict = {}\\n\\n        for tree in trees:\\n            treeDict[tree.val]=tree\\n            if tree.left:\\n                leaves.add(tree.left.val)\\n            if tree.right:\\n                leaves.add(tree.right.val)\\n\\n        root=None\\n\\n        for tree in trees:\\n            if tree.val not in leaves:\\n                root = tree\\n                break\\n        \\n        if not root:\\n            return None\\n        \\n        curleaves = {}\\n        if root.left:\\n            curleaves[root.left.val] = (-sys.maxsize,root.val,root,0)\\n\\n        if root.right:\\n            curleaves[root.right.val] = (root.val,sys.maxsize,root,1)\\n\\n        del treeDict[root.val]\\n\\n        while treeDict:\\n            findTree = False\\n            for leaf,(low,high,par,lor) in curleaves.items():\\n                if leaf in treeDict:\\n                    newTree = treeDict[leaf]\\n                    del curleaves[leaf]\\n\\n                    if newTree.left:\\n                        if low < newTree.left.val < high and newTree.left.val not in curleaves:\\n                            curleaves[newTree.left.val] = (low,newTree.val,newTree,0)\\n                        else:\\n                            return None\\n                    if newTree.right:\\n                        if low < newTree.right.val < high and newTree.right.val not in curleaves:\\n                            curleaves[newTree.right.val] = (newTree.val,high,newTree,1)\\n                        else:\\n                            return None\\n\\n                    if lor == 0:\\n                        par.left = newTree\\n                    else:\\n                        par.right = newTree\\n\\n                    findTree = True\\n                    del treeDict[newTree.val]\\n                    break\\n            if not findTree:\\n                return None\\n        return root\\n                    \\n             \\n\\n\\n\\n\\n\\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: There is a rooted tree consisting of n nodes numbered 0 to n - 1. Each node's number denotes its unique genetic value (i.e. the genetic value of node x is x). The genetic difference between two genetic values is defined as the bitwise-XOR of their values. You are given the integer array parents, where parents[i] is the parent for node i. If node x is the root of the tree, then parents[x] == -1. You are also given the array queries where queries[i] = [nodei, vali]. For each query i, find the maximum genetic difference between vali and pi, where pi is the genetic value of any node that is on the path between nodei and the root (including nodei and the root). More formally, you want to maximize vali XOR pi. Return an array ans where ans[i] is the answer to the ith query. Example 1: Input: parents = [-1,0,1,1], queries = [[0,2],[3,2],[2,5]] Output: [2,3,7] Explanation: The queries are processed as follows: - [0,2]: The node with the maximum genetic difference is 0, with a difference of 2 XOR 0 = 2. - [3,2]: The node with the maximum genetic difference is 1, with a difference of 2 XOR 1 = 3. - [2,5]: The node with the maximum genetic difference is 2, with a difference of 5 XOR 2 = 7. Example 2: Input: parents = [3,7,-1,2,0,7,0,2], queries = [[4,6],[1,15],[0,5]] Output: [6,14,7] Explanation: The queries are processed as follows: - [4,6]: The node with the maximum genetic difference is 0, with a difference of 6 XOR 0 = 6. - [1,15]: The node with the maximum genetic difference is 1, with a difference of 15 XOR 1 = 14. - [0,5]: The node with the maximum genetic difference is 2, with a difference of 5 XOR 2 = 7. Constraints: 2 <= parents.length <= 105 0 <= parents[i] <= parents.length - 1 for every node i that is not the root. parents[root] == -1 1 <= queries.length <= 3 * 104 0 <= nodei <= parents.length - 1 0 <= vali <= 2 * 105"}, {"role": "assistant", "content": "class Solution:\\n    def maxGeneticDifference(self, parents: List[int], queries: List[List[int]]) -> List[int]:\\n        mp = {}\\n        for i, (node, val) in enumerate(queries): \\n            mp.setdefault(node, []).append([val, i])\\n        \\n        tree, root = {}, -1\\n        for i, x in enumerate(parents): \\n            if x == -1: root = i\\n            else: tree.setdefault(x, []).append(i)\\n        \\n        ans = [0]*len(queries)\\n        trie = Trie()\\n        \\n        def fn(x): \\n            \"\"\"Collect query results while traversing the tree.\"\"\"\\n            trie.insert(x)\\n            for v, i in mp.get(x, []): ans[i] = trie.search(v)\\n            for xx in tree.get(x, []): fn(xx)\\n            trie.remove(x)\\n        \\n        fn(root)\\n        return ans \\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: Due to a bug, there are many duplicate folders in a file system. You are given a 2D array paths, where paths[i] is an array representing an absolute path to the ith folder in the file system. For example, [\"one\", \"two\", \"three\"] represents the path \"/one/two/three\". Two folders (not necessarily on the same level) are identical if they contain the same non-empty set of identical subfolders and underlying subfolder structure. The folders do not need to be at the root level to be identical. If two or more folders are identical, then mark the folders as well as all their subfolders. For example, folders \"/a\" and \"/b\" in the file structure below are identical. They (as well as their subfolders) should all be marked: /a /a/x /a/x/y /a/z /b /b/x /b/x/y /b/z However, if the file structure also included the path \"/b/w\", then the folders \"/a\" and \"/b\" would not be identical. Note that \"/a/x\" and \"/b/x\" would still be considered identical even with the added folder. Once all the identical folders and their subfolders have been marked, the file system will delete all of them. The file system only runs the deletion once, so any folders that become identical after the initial deletion are not deleted. Return the 2D array ans containing the paths of the remaining folders after deleting all the marked folders. The paths may be returned in any order. Example 1: Input: paths = [[\"a\"],[\"c\"],[\"d\"],[\"a\",\"b\"],[\"c\",\"b\"],[\"d\",\"a\"]] Output: [[\"d\"],[\"d\",\"a\"]] Explanation: The file structure is as shown. Folders \"/a\" and \"/c\" (and their subfolders) are marked for deletion because they both contain an empty folder named \"b\". Example 2: Input: paths = [[\"a\"],[\"c\"],[\"a\",\"b\"],[\"c\",\"b\"],[\"a\",\"b\",\"x\"],[\"a\",\"b\",\"x\",\"y\"],[\"w\"],[\"w\",\"y\"]] Output: [[\"c\"],[\"c\",\"b\"],[\"a\"],[\"a\",\"b\"]] Explanation: The file structure is as shown. Folders \"/a/b/x\" and \"/w\" (and their subfolders) are marked for deletion because they both contain an empty folder named \"y\". Note that folders \"/a\" and \"/c\" are identical after the deletion, but they are not deleted because they were not marked beforehand. Example 3: Input: paths = [[\"a\",\"b\"],[\"c\",\"d\"],[\"c\"],[\"a\"]] Output: [[\"c\"],[\"c\",\"d\"],[\"a\"],[\"a\",\"b\"]] Explanation: All folders are unique in the file system. Note that the returned array can be in a different order as the order does not matter. Constraints: 1 <= paths.length <= 2 * 104 1 <= paths[i].length <= 500 1 <= paths[i][j].length <= 10 1 <= sum(paths[i][j].length) <= 2 * 105 path[i][j] consists of lowercase English letters. No two paths lead to the same folder. For any folder not at the root level, its parent folder will also be in the input."}, {"role": "assistant", "content": "class Solution:\\n    def deleteDuplicateFolder(self, paths: List[List[str]]) -> List[List[str]]:\\n        paths.sort()\\n        \\n        tree = {\"#\": -1}\\n        for i, path in enumerate(paths): \\n            node = tree\\n            for x in path: node = node.setdefault(x, {})\\n            node[\"#\"] = i\\n        \\n        seen = {}\\n        mark = set()\\n        \\n        def fn(n): \\n            \"\"\"Return serialized value of sub-tree rooted at n.\"\"\"\\n            if len(n) == 1: return \"$\" # leaf node \\n            vals = []\\n            for k in n: \\n                if k != \"#\": vals.append(f\"${k}${fn(n[k])}\")\\n            hs = \"\".join(vals)\\n            if hs in seen: \\n                mark.add(n[\"#\"])\\n                mark.add(seen[hs])\\n            if hs != \"$\": seen[hs] = n[\"#\"]\\n            return hs\\n        \\n        fn(tree)\\n        \\n        ans = []\\n        stack = [tree]\\n        while stack: \\n            n = stack.pop()\\n            if n[\"#\"] >= 0: ans.append(paths[n[\"#\"]])\\n            for k in n: \\n                if k != \"#\" and n[k][\"#\"] not in mark: stack.append(n[k])\\n        return ans \\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: A sequence is special if it consists of a positive number of 0s, followed by a positive number of 1s, then a positive number of 2s. For example, [0,1,2] and [0,0,1,1,1,2] are special. In contrast, [2,1,0], [1], and [0,1,2,0] are not special. Given an array nums (consisting of only integers 0, 1, and 2), return the number of different subsequences that are special. Since the answer may be very large, return it modulo 109 + 7. A subsequence of an array is a sequence that can be derived from the array by deleting some or no elements without changing the order of the remaining elements. Two subsequences are different if the set of indices chosen are different. Example 1: Input: nums = [0,1,2,2] Output: 3 Explanation: The special subsequences are bolded [0,1,2,2], [0,1,2,2], and [0,1,2,2]. Example 2: Input: nums = [2,2,0,0] Output: 0 Explanation: There are no special subsequences in [2,2,0,0]. Example 3: Input: nums = [0,1,2,0,1,2] Output: 7 Explanation: The special subsequences are bolded: - [0,1,2,0,1,2] - [0,1,2,0,1,2] - [0,1,2,0,1,2] - [0,1,2,0,1,2] - [0,1,2,0,1,2] - [0,1,2,0,1,2] - [0,1,2,0,1,2] Constraints: 1 <= nums.length <= 105 0 <= nums[i] <= 2"}, {"role": "assistant", "content": "class Solution:\\n    def countSpecialSubsequences(self, nums: List[int]) -> int:\\n        total_zeros = 0 # number of subsequences of 0s so far\\n        total_ones = 0 # the number of subsequences of 0s followed by 1s so far\\n        total_twos = 0 # the number of special subsequences so far\\n        \\n        M = 1000000007\\n        \\n        for n in nums:\\n            if n == 0:\\n                # if we have found new 0 we can add it to any existing subsequence of 0s\\n                # or use only this 0\\n                total_zeros += (total_zeros + 1) % M\\n            elif n == 1:\\n                # if we have found new 1 we can add it to any existing subsequence of 0s or 0s and 1s\\n                # to get a valid subsequence of 0s and 1s\\n                total_ones += (total_zeros + total_ones) % M\\n            else:\\n                # if we have found new 2 we can add it to any existing subsequence of 0s and 1s 0r 0s,1s and 2s\\n                # to get a valid subsequence of 0s,1s and 2s\\n                total_twos += (total_ones + total_twos) % M\\n        \\n        return total_twos % M\\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: You are given a 0-indexed string s and are tasked with finding two non-intersecting palindromic substrings of odd length such that the product of their lengths is maximized. More formally, you want to choose four integers i, j, k, l such that 0 <= i <= j < k <= l < s.length and both the substrings s[i...j] and s[k...l] are palindromes and have odd lengths. s[i...j] denotes a substring from index i to index j inclusive. Return the maximum possible product of the lengths of the two non-intersecting palindromic substrings. A palindrome is a string that is the same forward and backward. A substring is a contiguous sequence of characters in a string. Example 1: Input: s = \"ababbb\" Output: 9 Explanation: Substrings \"aba\" and \"bbb\" are palindromes with odd length. product = 3 * 3 = 9. Example 2: Input: s = \"zaaaxbbby\" Output: 9 Explanation: Substrings \"aaa\" and \"bbb\" are palindromes with odd length. product = 3 * 3 = 9. Constraints: 2 <= s.length <= 105 s consists of lowercase English letters."}, {"role": "assistant", "content": "class Solution:\\n    def maxProduct(self, s: str) -> int:\\n        n = len(s)\\n        \\n        # Manacher\\'s algo\\n        hlen = [0]*n # half-length\\n        center = right = 0 \\n        for i in range(n): \\n            if i < right: hlen[i] = min(right - i, hlen[2*center - i])\\n            while 0 <= i-1-hlen[i] and i+1+hlen[i] < len(s) and s[i-1-hlen[i]] == s[i+1+hlen[i]]: \\n                hlen[i] += 1\\n            if right < i+hlen[i]: center, right = i, i+hlen[i]\\n        \\n        prefix = [0]*n\\n        suffix = [0]*n\\n        for i in range(n): \\n            prefix[i+hlen[i]] = max(prefix[i+hlen[i]], 2*hlen[i]+1)\\n            suffix[i-hlen[i]] = max(suffix[i-hlen[i]], 2*hlen[i]+1)\\n        \\n        for i in range(1, n): \\n            prefix[~i] = max(prefix[~i], prefix[~i+1]-2)\\n            suffix[i] = max(suffix[i], suffix[i-1]-2)\\n        \\n        for i in range(1, n): \\n            prefix[i] = max(prefix[i-1], prefix[i])\\n            suffix[~i] = max(suffix[~i], suffix[~i+1])\\n        \\n        return max(prefix[i-1]*suffix[i] for i in range(1, n))\\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: You want to build some obstacle courses. You are given a 0-indexed integer array obstacles of length n, where obstacles[i] describes the height of the ith obstacle. For every index i between 0 and n - 1 (inclusive), find the length of the longest obstacle course in obstacles such that: You choose any number of obstacles between 0 and i inclusive. You must include the ith obstacle in the course. You must put the chosen obstacles in the same order as they appear in obstacles. Every obstacle (except the first) is taller than or the same height as the obstacle immediately before it. Return an array ans of length n, where ans[i] is the length of the longest obstacle course for index i as described above. Example 1: Input: obstacles = [1,2,3,2] Output: [1,2,3,3] Explanation: The longest valid obstacle course at each position is: - i = 0: [1], [1] has length 1. - i = 1: [1,2], [1,2] has length 2. - i = 2: [1,2,3], [1,2,3] has length 3. - i = 3: [1,2,3,2], [1,2,2] has length 3. Example 2: Input: obstacles = [2,2,1] Output: [1,2,1] Explanation: The longest valid obstacle course at each position is: - i = 0: [2], [2] has length 1. - i = 1: [2,2], [2,2] has length 2. - i = 2: [2,2,1], [1] has length 1. Example 3: Input: obstacles = [3,1,5,6,4,2] Output: [1,1,2,3,2,2] Explanation: The longest valid obstacle course at each position is: - i = 0: [3], [3] has length 1. - i = 1: [3,1], [1] has length 1. - i = 2: [3,1,5], [3,5] has length 2. [1,5] is also valid. - i = 3: [3,1,5,6], [3,5,6] has length 3. [1,5,6] is also valid. - i = 4: [3,1,5,6,4], [3,4] has length 2. [1,4] is also valid. - i = 5: [3,1,5,6,4,2], [1,2] has length 2. Constraints: n == obstacles.length 1 <= n <= 105 1 <= obstacles[i] <= 107"}, {"role": "assistant", "content": "class Solution:\\n    def longestObstacleCourseAtEachPosition(self, obstacles: List[int]) -> List[int]:\\n        lst,ans=[],[]\\n        for i in obstacles:\\n            b=bisect_right(lst,i)\\n            if b==len(lst):\\n                lst.append(i)\\n            else:\\n                lst[b]=i\\n            ans.append(b+1)\\n        return ans\\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: There is a 1-based binary matrix where 0 represents land and 1 represents water. You are given integers row and col representing the number of rows and columns in the matrix, respectively. Initially on day 0, the entire matrix is land. However, each day a new cell becomes flooded with water. You are given a 1-based 2D array cells, where cells[i] = [ri, ci] represents that on the ith day, the cell on the rith row and cith column (1-based coordinates) will be covered with water (i.e., changed to 1). You want to find the last day that it is possible to walk from the top to the bottom by only walking on land cells. You can start from any cell in the top row and end at any cell in the bottom row. You can only travel in the four cardinal directions (left, right, up, and down). Return the last day where it is possible to walk from the top to the bottom by only walking on land cells. Example 1: Input: row = 2, col = 2, cells = [[1,1],[2,1],[1,2],[2,2]] Output: 2 Explanation: The above image depicts how the matrix changes each day starting from day 0. The last day where it is possible to cross from top to bottom is on day 2. Example 2: Input: row = 2, col = 2, cells = [[1,1],[1,2],[2,1],[2,2]] Output: 1 Explanation: The above image depicts how the matrix changes each day starting from day 0. The last day where it is possible to cross from top to bottom is on day 1. Example 3: Input: row = 3, col = 3, cells = [[1,2],[2,1],[3,3],[2,2],[1,1],[1,3],[2,3],[3,2],[3,1]] Output: 3 Explanation: The above image depicts how the matrix changes each day starting from day 0. The last day where it is possible to cross from top to bottom is on day 3. Constraints: 2 <= row, col <= 2 * 104 4 <= row * col <= 2 * 104 cells.length == row * col 1 <= ri <= row 1 <= ci <= col All the values of cells are unique."}, {"role": "assistant", "content": "class Solution:\\n    def isPossible(self, row, col, cells, day):\\n        grid = [[0] * col for _ in range(row)]\\n        queue = collections.deque()\\n        \\n        for r, c in cells[:day]:\\n            grid[r - 1][c - 1] = 1\\n            \\n        for i in range(col):\\n            if not grid[0][i]:\\n                queue.append((0, i))\\n                grid[0][i] = -1\\n\\n        while queue:\\n            r, c = queue.popleft()\\n            if r == row - 1:\\n                return True\\n            for dr, dc in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\\n                nr, nc = r + dr, c + dc\\n                if 0 <= nr < row and 0 <= nc < col and grid[nr][nc] == 0:\\n                    grid[nr][nc] = -1\\n                    queue.append((nr, nc))\\n                    \\n        return False\\n    \\n    \\n    def latestDayToCross(self, row: int, col: int, cells: List[List[int]]) -> int:\\n        left, right = 1, row * col\\n        \\n        while left < right:\\n            mid = right - (right - left) // 2\\n            if self.isPossible(row, col, cells, mid):\\n                left = mid\\n            else:\\n                right = mid - 1\\n                \\n        return left\\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: You wrote down many positive integers in a string called num. However, you realized that you forgot to add commas to seperate the different numbers. You remember that the list of integers was non-decreasing and that no integer had leading zeros. Return the number of possible lists of integers that you could have written down to get the string num. Since the answer may be large, return it modulo 109 + 7. Example 1: Input: num = \"327\" Output: 2 Explanation: You could have written down the numbers: 3, 27 327 Example 2: Input: num = \"094\" Output: 0 Explanation: No numbers can have leading zeros and all numbers must be positive. Example 3: Input: num = \"0\" Output: 0 Explanation: No numbers can have leading zeros and all numbers must be positive. Constraints: 1 <= num.length <= 3500 num consists of digits '0' through '9'."}, {"role": "assistant", "content": "class Solution:\\n    def numberOfCombinations(self, num: str) -> int:\\n        n = len(num)\\n        lcs = [[0]*(n+1) for _ in range(n)]\\n        for i in reversed(range(n)): \\n            for j in reversed(range(i+1, n)): \\n                if num[i] == num[j]: lcs[i][j] = 1 + lcs[i+1][j+1]\\n        \\n        def cmp(i, j, d): \\n            \"\"\"Return True if \"\"\"\\n            m = lcs[i][j]\\n            if m >= d: return True \\n            return num[i+m] <= num[j+m]\\n        \\n        dp = [[0]*(n+1) for _ in range(n)]\\n        for i in range(n): \\n            if num[i] != \"0\": \\n                for j in range(i+1, n+1): \\n                    if i == 0: dp[i][j] = 1\\n                    else: \\n                        dp[i][j] = dp[i][j-1]\\n                        if 2*i-j >= 0 and cmp(2*i-j, i, j-i): dp[i][j] += dp[2*i-j][i]\\n                        if 2*i-j+1 >= 0 and not cmp(2*i-j+1, i, j-i-1): dp[i][j] += dp[2*i-j+1][i]\\n        return sum(dp[i][n] for i in range(n)) % 1_000_000_007\\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: You are given an integer n representing the length of an unknown array that you are trying to recover. You are also given an array sums containing the values of all 2n subset sums of the unknown array (in no particular order). Return the array ans of length n representing the unknown array. If multiple answers exist, return any of them. An array sub is a subset of an array arr if sub can be obtained from arr by deleting some (possibly zero or all) elements of arr. The sum of the elements in sub is one possible subset sum of arr. The sum of an empty array is considered to be 0. Note: Test cases are generated such that there will always be at least one correct answer. Example 1: Input: n = 3, sums = [-3,-2,-1,0,0,1,2,3] Output: [1,2,-3] Explanation: [1,2,-3] is able to achieve the given subset sums: - []: sum is 0 - [1]: sum is 1 - [2]: sum is 2 - [1,2]: sum is 3 - [-3]: sum is -3 - [1,-3]: sum is -2 - [2,-3]: sum is -1 - [1,2,-3]: sum is 0 Note that any permutation of [1,2,-3] and also any permutation of [-1,-2,3] will also be accepted. Example 2: Input: n = 2, sums = [0,0,0,0] Output: [0,0] Explanation: The only correct answer is [0,0]. Example 3: Input: n = 4, sums = [0,0,5,5,4,-1,4,9,9,-1,4,3,4,8,3,8] Output: [0,-1,4,5] Explanation: [0,-1,4,5] is able to achieve the given subset sums. Constraints: 1 <= n <= 15 sums.length == 2n -104 <= sums[i] <= 104"}, {"role": "assistant", "content": "class Solution:\\n    def recoverArray(self, n: int, sums: List[int]) -> List[int]:\\n        res = []  # Result set\\n        sums.sort()\\n        \\n        while len(sums) > 1:\\n            num = sums[-1] - sums[-2] # max - secondMax\\n            countMap = Counter(sums) # Get count of each elements\\n            excluding = [] # Subset sums that do NOT contain num\\n            including = [] # Subset sums that contain num\\n            \\n            for x in sums:\\n                if countMap.get(x) > 0:\\n                    excluding.append(x)\\n                    including.append(x+num)\\n                    countMap[x] -= 1\\n                    countMap[x+num] -= 1\\n                    \\n\\t\\t\\t# Check validity of excluding set\\t\\n            if 0 in excluding:\\n                sums = excluding\\n                res.append(num)\\n            else:\\n                sums = including\\n                res.append(-1*num)\\n        \\n        return res\\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: You are given a binary string binary. A subsequence of binary is considered good if it is not empty and has no leading zeros (with the exception of \"0\"). Find the number of unique good subsequences of binary. For example, if binary = \"001\", then all the good subsequences are [\"0\", \"0\", \"1\"], so the unique good subsequences are \"0\" and \"1\". Note that subsequences \"00\", \"01\", and \"001\" are not good because they have leading zeros. Return the number of unique good subsequences of binary. Since the answer may be very large, return it modulo 109 + 7. A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements. Example 1: Input: binary = \"001\" Output: 2 Explanation: The good subsequences of binary are [\"0\", \"0\", \"1\"]. The unique good subsequences are \"0\" and \"1\". Example 2: Input: binary = \"11\" Output: 2 Explanation: The good subsequences of binary are [\"1\", \"1\", \"11\"]. The unique good subsequences are \"1\" and \"11\". Example 3: Input: binary = \"101\" Output: 5 Explanation: The good subsequences of binary are [\"1\", \"0\", \"1\", \"10\", \"11\", \"101\"]. The unique good subsequences are \"0\", \"1\", \"10\", \"11\", and \"101\". Constraints: 1 <= binary.length <= 105 binary consists of only '0's and '1's."}, {"role": "assistant", "content": "class Solution:\\n    def numberOfUniqueGoodSubsequences(self, binary: str) -> int:\\n        mod = 10**9 + 7\\n        dp = [[0, 0] for _ in range(2)]  # dp[i][j] represents count of subsequences ending at index i with last element j (0 or 1)\\n        n = len(binary)\\n        \\n        for ch in binary:\\n            if ch == \\'0\\':\\n                # For a \\'0\\', we have two cases:\\n                # 1. Extend the subsequences ending with \\'0\\' by one more \\'0\\'.\\n                # 2. Extend the subsequences ending with \\'1\\' by appending this \\'0\\' to form new subsequences.\\n                dp[0][0] = 1\\n                dp[1][0] = (dp[1][0] + dp[1][1]) % mod\\n            else:\\n                # For a \\'1\\', we have one case:\\n                # Extend the subsequences ending with \\'0\\' or \\'1\\' by appending this \\'1\\' to form new subsequences.\\n                dp[1][1] = (dp[1][0] + dp[1][1] + 1) % mod\\n        \\n        # The answer is the sum of counts of subsequences ending with \\'0\\' and \\'1\\',\\n        # considering all the possibilities.\\n        result = (dp[0][0] + dp[0][1] + dp[1][0] + dp[1][1]) % mod\\n        return result\\n\\n# Create an instance of the Solution class\\nsol = Solution()\\n\\n# Test cases\\nprint(sol.numberOfUniqueGoodSubsequences(\"001\"))  # Output: 2\\nprint(sol.numberOfUniqueGoodSubsequences(\"11\"))   # Output: 2\\nprint(sol.numberOfUniqueGoodSubsequences(\"101\"))  # Output: 5\\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: You are given an integer array nums. We call a subset of nums good if its product can be represented as a product of one or more distinct prime numbers. For example, if nums = [1, 2, 3, 4]: [2, 3], [1, 2, 3], and [1, 3] are good subsets with products 6 = 2*3, 6 = 2*3, and 3 = 3 respectively. [1, 4] and [4] are not good subsets with products 4 = 2*2 and 4 = 2*2 respectively. Return the number of different good subsets in nums modulo 109 + 7. A subset of nums is any array that can be obtained by deleting some (possibly none or all) elements from nums. Two subsets are different if and only if the chosen indices to delete are different. Example 1: Input: nums = [1,2,3,4] Output: 6 Explanation: The good subsets are: - [1,2]: product is 2, which is the product of distinct prime 2. - [1,2,3]: product is 6, which is the product of distinct primes 2 and 3. - [1,3]: product is 3, which is the product of distinct prime 3. - [2]: product is 2, which is the product of distinct prime 2. - [2,3]: product is 6, which is the product of distinct primes 2 and 3. - [3]: product is 3, which is the product of distinct prime 3. Example 2: Input: nums = [4,2,3,15] Output: 5 Explanation: The good subsets are: - [2]: product is 2, which is the product of distinct prime 2. - [2,3]: product is 6, which is the product of distinct primes 2 and 3. - [2,15]: product is 30, which is the product of distinct primes 2, 3, and 5. - [3]: product is 3, which is the product of distinct prime 3. - [15]: product is 15, which is the product of distinct primes 3 and 5. Constraints: 1 <= nums.length <= 105 1 <= nums[i] <= 30"}, {"role": "assistant", "content": "class Solution:\\n    def numberOfGoodSubsets(self, nums: List[int]) -> int:\\n        freq = [0] * 31\\n        for x in nums: freq[x] += 1\\n        \\n        masks = [0] * 31\\n        for x in range(1, 31): \\n            if x == 1: masks[x] = 0b10\\n            else: \\n                bits = 0\\n                xx = x\\n                for k in (2, 3, 5, 7, 11, 13, 17, 19, 23, 29): \\n                    while xx % k == 0: \\n                        if (bits >> k) & 1: break # repeated factors \\n                        bits ^= 1 << k\\n                        xx //= k\\n                    else: continue \\n                    break \\n                else: masks[x] = bits\\n                    \\n        @cache\\n        def fn(x, m): \\n            \"\"\"Return number of good subsets.\"\"\"\\n            if x == 31: return int(m > 2)\\n            ans = fn(x+1, m)\\n            if freq[x] and masks[x]: \\n                if x == 1: ans *= 2**freq[x]\\n                elif not m & masks[x]: ans += freq[x] * fn(x+1, m | masks[x])\\n            return ans % 1_000_000_007\\n        \\n        return fn(1, 0)\\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: You are given an integer array nums, and you can perform the following operation any number of times on nums: Swap the positions of two elements nums[i] and nums[j] if gcd(nums[i], nums[j]) > 1 where gcd(nums[i], nums[j]) is the greatest common divisor of nums[i] and nums[j]. Return true if it is possible to sort nums in non-decreasing order using the above swap method, or false otherwise. Example 1: Input: nums = [7,21,3] Output: true Explanation: We can sort [7,21,3] by performing the following operations: - Swap 7 and 21 because gcd(7,21) = 7. nums = [21,7,3] - Swap 21 and 3 because gcd(21,3) = 3. nums = [3,7,21] Example 2: Input: nums = [5,2,6,2] Output: false Explanation: It is impossible to sort the array because 5 cannot be swapped with any other element. Example 3: Input: nums = [10,5,9,3,15] Output: true We can sort [10,5,9,3,15] by performing the following operations: - Swap 10 and 15 because gcd(10,15) = 5. nums = [15,5,9,3,10] - Swap 15 and 3 because gcd(15,3) = 3. nums = [3,5,9,15,10] - Swap 10 and 15 because gcd(10,15) = 5. nums = [3,5,9,10,15] Constraints: 1 <= nums.length <= 3 * 104 2 <= nums[i] <= 105"}, {"role": "assistant", "content": "class Solution:\\n    def gcdSort(self, nums: List[int]) -> bool:\\n        m = max(nums)\\n        uf = UnionFind(m+1)\\n        \\n        seen = set(nums)\\n        \\n        # modified sieve of eratosthenes\\n        sieve = [1]*(m+1)\\n        sieve[0] = sieve[1] = 0\\n        for k in range(m//2 + 1): \\n            if sieve[k]: \\n                for x in range(2*k, m+1, k): \\n                    sieve[x] = 0\\n                    if x in seen: uf.union(k, x)\\n        return all(uf.find(x) == uf.find(y) for x, y in zip(nums, sorted(nums)))\\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: There is a family tree rooted at 0 consisting of n nodes numbered 0 to n - 1. You are given a 0-indexed integer array parents, where parents[i] is the parent for node i. Since node 0 is the root, parents[0] == -1. There are 105 genetic values, each represented by an integer in the inclusive range [1, 105]. You are given a 0-indexed integer array nums, where nums[i] is a distinct genetic value for node i. Return an array ans of length n where ans[i] is the smallest genetic value that is missing from the subtree rooted at node i. The subtree rooted at a node x contains node x and all of its descendant nodes. Example 1: Input: parents = [-1,0,0,2], nums = [1,2,3,4] Output: [5,1,1,1] Explanation: The answer for each subtree is calculated as follows: - 0: The subtree contains nodes [0,1,2,3] with values [1,2,3,4]. 5 is the smallest missing value. - 1: The subtree contains only node 1 with value 2. 1 is the smallest missing value. - 2: The subtree contains nodes [2,3] with values [3,4]. 1 is the smallest missing value. - 3: The subtree contains only node 3 with value 4. 1 is the smallest missing value. Example 2: Input: parents = [-1,0,1,0,3,3], nums = [5,4,6,2,1,3] Output: [7,1,1,4,2,1] Explanation: The answer for each subtree is calculated as follows: - 0: The subtree contains nodes [0,1,2,3,4,5] with values [5,4,6,2,1,3]. 7 is the smallest missing value. - 1: The subtree contains nodes [1,2] with values [4,6]. 1 is the smallest missing value. - 2: The subtree contains only node 2 with value 6. 1 is the smallest missing value. - 3: The subtree contains nodes [3,4,5] with values [2,1,3]. 4 is the smallest missing value. - 4: The subtree contains only node 4 with value 1. 2 is the smallest missing value. - 5: The subtree contains only node 5 with value 3. 1 is the smallest missing value. Example 3: Input: parents = [-1,2,3,0,2,4,1], nums = [2,3,4,5,6,7,8] Output: [1,1,1,1,1,1,1] Explanation: The value 1 is missing from all the subtrees. Constraints: n == parents.length == nums.length 2 <= n <= 105 0 <= parents[i] <= n - 1 for i != 0 parents[0] == -1 parents represents a valid tree. 1 <= nums[i] <= 105 Each nums[i] is distinct."}, {"role": "assistant", "content": "class Solution:\\n    def smallestMissingValueSubtree(self, parents: List[int], nums: List[int]) -> List[int]:\\n        ans = [1] * len(parents)\\n        if 1 in nums: \\n            tree = {}\\n            for i, x in enumerate(parents): \\n                tree.setdefault(x, []).append(i)\\n                \\n            k = nums.index(1)\\n            val = 1\\n            seen = set()\\n            \\n            while k != -1: \\n                stack = [k]\\n                while stack: \\n                    x = stack.pop()\\n                    seen.add(nums[x])\\n                    for xx in tree.get(x, []): \\n                        if nums[xx] not in seen: \\n                            stack.append(xx)\\n                            seen.add(nums[xx])\\n                while val in seen: val += 1\\n                ans[k] = val\\n                k = parents[k]\\n        return ans \\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: You are given an integer array nums. In one operation, you can replace any element in nums with any integer. nums is considered continuous if both of the following conditions are fulfilled: All elements in nums are unique. The difference between the maximum element and the minimum element in nums equals nums.length - 1. For example, nums = [4, 2, 5, 3] is continuous, but nums = [1, 2, 3, 5, 6] is not continuous. Return the minimum number of operations to make nums continuous. Example 1: Input: nums = [4,2,5,3] Output: 0 Explanation: nums is already continuous. Example 2: Input: nums = [1,2,3,5,6] Output: 1 Explanation: One possible solution is to change the last element to 4. The resulting array is [1,2,3,5,4], which is continuous. Example 3: Input: nums = [1,10,100,1000] Output: 3 Explanation: One possible solution is to: - Change the second element to 2. - Change the third element to 3. - Change the fourth element to 4. The resulting array is [1,2,3,4], which is continuous. Constraints: 1 <= nums.length <= 105 1 <= nums[i] <= 109"}, {"role": "assistant", "content": "class Solution:\\n    def minOperations(self, nums: List[int]) -> int:\\n        length = len(nums)\\n        min_operations = length\\n        unique_nums = sorted(set(nums))\\n        right = 0\\n        \\n        for left in range(len(unique_nums)):\\n            while right < len(unique_nums) and unique_nums[right] < unique_nums[left] + length:\\n                right += 1\\n            \\n            min_operations = min(min_operations, length - (right - left))\\n\\n        return min_operations\\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: You are given a string s of length n, and an integer k. You are tasked to find the longest subsequence repeated k times in string s. A subsequence is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters. A subsequence seq is repeated k times in the string s if seq * k is a subsequence of s, where seq * k represents a string constructed by concatenating seq k times. For example, \"bba\" is repeated 2 times in the string \"bababcba\", because the string \"bbabba\", constructed by concatenating \"bba\" 2 times, is a subsequence of the string \"bababcba\". Return the longest subsequence repeated k times in string s. If multiple such subsequences are found, return the lexicographically largest one. If there is no such subsequence, return an empty string. Example 1: Input: s = \"letsleetcode\", k = 2 Output: \"let\" Explanation: There are two longest subsequences repeated 2 times: \"let\" and \"ete\". \"let\" is the lexicographically largest one. Example 2: Input: s = \"bb\", k = 2 Output: \"b\" Explanation: The longest subsequence repeated 2 times is \"b\". Example 3: Input: s = \"ab\", k = 2 Output: \"\" Explanation: There is no subsequence repeated 2 times. Empty string is returned. Constraints: n == s.length 2 <= n, k <= 2000 2 <= n < k * 8 s consists of lowercase English letters."}, {"role": "assistant", "content": "class Solution:\\n    def longestSubsequenceRepeatedK(self, s: str, k: int) -> str:\\n        freq = [0] * 26\\n        for ch in s: freq[ord(ch)-97] += 1\\n        \\n        cand = [chr(i+97) for i, x in enumerate(freq) if x >= k] # valid candidates \\n        \\n        def fn(ss): \\n            \"\"\"Return True if ss is a k-repeated sub-sequence of s.\"\"\"\\n            i = cnt = 0\\n            for ch in s: \\n                if ss[i] == ch: \\n                    i += 1\\n                    if i == len(ss): \\n                        if (cnt := cnt + 1) == k: return True  \\n                        i = 0\\n            return False \\n        \\n        ans = \"\"\\n        queue = deque([\"\"])\\n        while queue: \\n            x = queue.popleft()\\n            for ch in cand:  \\n                xx = x + ch\\n                if fn(xx): \\n                    ans = xx\\n                    queue.append(xx)\\n        return ans\\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: You are given a string s that contains digits 0-9, addition symbols '+', and multiplication symbols '*' only, representing a valid math expression of single digit numbers (e.g., 3+5*2). This expression was given to n elementary school students. The students were instructed to get the answer of the expression by following this order of operations: Compute multiplication, reading from left to right; Then, Compute addition, reading from left to right. You are given an integer array answers of length n, which are the submitted answers of the students in no particular order. You are asked to grade the answers, by following these rules: If an answer equals the correct answer of the expression, this student will be rewarded 5 points; Otherwise, if the answer could be interpreted as if the student applied the operators in the wrong order but had correct arithmetic, this student will be rewarded 2 points; Otherwise, this student will be rewarded 0 points. Return the sum of the points of the students. Example 1: Input: s = \"7+3*1*2\", answers = [20,13,42] Output: 7 Explanation: As illustrated above, the correct answer of the expression is 13, therefore one student is rewarded 5 points: [20,13,42] A student might have applied the operators in this wrong order: ((7+3)*1)*2 = 20. Therefore one student is rewarded 2 points: [20,13,42] The points for the students are: [2,5,0]. The sum of the points is 2+5+0=7. Example 2: Input: s = \"3+5*2\", answers = [13,0,10,13,13,16,16] Output: 19 Explanation: The correct answer of the expression is 13, therefore three students are rewarded 5 points each: [13,0,10,13,13,16,16] A student might have applied the operators in this wrong order: ((3+5)*2 = 16. Therefore two students are rewarded 2 points: [13,0,10,13,13,16,16] The points for the students are: [5,0,0,5,5,2,2]. The sum of the points is 5+0+0+5+5+2+2=19. Example 3: Input: s = \"6+0*1\", answers = [12,9,6,4,8,6] Output: 10 Explanation: The correct answer of the expression is 6. If a student had incorrectly done (6+0)*1, the answer would also be 6. By the rules of grading, the students will still be rewarded 5 points (as they got the correct answer), not 2 points. The points for the students are: [0,0,5,0,0,5]. The sum of the points is 10. Constraints: 3 <= s.length <= 31 s represents a valid expression that contains only digits 0-9, '+', and '*' only. All the integer operands in the expression are in the inclusive range [0, 9]. 1 <= The count of all operators ('+' and '*') in the math expression <= 15 Test data are generated such that the correct answer of the expression is in the range of [0, 1000]. n == answers.length 1 <= n <= 104 0 <= answers[i] <= 1000"}, {"role": "assistant", "content": "class Solution:\\n    def scoreOfStudents(self, s: str, answers: List[int]) -> int:\\n        \\n        @cache\\n        def fn(lo, hi): \\n            \"\"\"Return possible answers of s[lo:hi].\"\"\"\\n            if lo+1 == hi: return {int(s[lo])}\\n            ans = set()\\n            for mid in range(lo+1, hi, 2): \\n                for x in fn(lo, mid): \\n                    for y in fn(mid+1, hi): \\n                        if s[mid] == \"+\" and x + y <= 1000: ans.add(x + y)\\n                        elif s[mid] == \"*\" and x * y <= 1000: ans.add(x * y)\\n            return ans \\n                \\n        target = eval(s)\\n        cand = fn(0, len(s))\\n        ans = 0 \\n        for x in answers: \\n            if x == target: ans += 5\\n            elif x in cand: ans += 2\\n        return ans \\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: You are given a string s, an integer k, a letter letter, and an integer repetition. Return the lexicographically smallest subsequence of s of length k that has the letter letter appear at least repetition times. The test cases are generated so that the letter appears in s at least repetition times. A subsequence is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters. A string a is lexicographically smaller than a string b if in the first position where a and b differ, string a has a letter that appears earlier in the alphabet than the corresponding letter in b. Example 1: Input: s = \"leet\", k = 3, letter = \"e\", repetition = 1 Output: \"eet\" Explanation: There are four subsequences of length 3 that have the letter 'e' appear at least 1 time: - \"lee\" (from \"leet\") - \"let\" (from \"leet\") - \"let\" (from \"leet\") - \"eet\" (from \"leet\") The lexicographically smallest subsequence among them is \"eet\". Example 2: Input: s = \"leetcode\", k = 4, letter = \"e\", repetition = 2 Output: \"ecde\" Explanation: \"ecde\" is the lexicographically smallest subsequence of length 4 that has the letter \"e\" appear at least 2 times. Example 3: Input: s = \"bb\", k = 2, letter = \"b\", repetition = 2 Output: \"bb\" Explanation: \"bb\" is the only subsequence of length 2 that has the letter \"b\" appear at least 2 times. Constraints: 1 <= repetition <= k <= s.length <= 5 * 104 s consists of lowercase English letters. letter is a lowercase English letter, and appears in s at least repetition times."}, {"role": "assistant", "content": "class Solution:\\n    def smallestSubsequence(self, s: str, k: int, letter: str, repetition: int) -> str:\\n        counts,total = 0, 0\\n        n = len(s)\\n        for ch in s:\\n            if ch==letter:\\n                total +=1\\n        stack = []\\n        occ = 0\\n        for idx,ch in enumerate(s):\\n            if ch==letter:\\n                counts +=1\\n            while stack and stack[-1]>ch and  len(stack)+ (n-1-idx)>=k and (occ+total-counts-(stack[-1]==letter)+(ch==letter)>=repetition ): \\n                occ -= stack.pop()==letter\\n            if ch!=letter  and len(stack)< k-max(0,(repetition-occ)):\\n                stack.append(ch)\\n            elif ch==letter and len(stack)+(total-counts)<k:\\n                stack.append(ch)\\n                occ +=1\\n        return \\'\\'.join(stack)\\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: You are given an integer array nums of 2 * n integers. You need to partition nums into two arrays of length n to minimize the absolute difference of the sums of the arrays. To partition nums, put each element of nums into one of the two arrays. Return the minimum possible absolute difference. Example 1: Input: nums = [3,9,7,3] Output: 2 Explanation: One optimal partition is: [3,9] and [7,3]. The absolute difference between the sums of the arrays is abs((3 + 9) - (7 + 3)) = 2. Example 2: Input: nums = [-36,36] Output: 72 Explanation: One optimal partition is: [-36] and [36]. The absolute difference between the sums of the arrays is abs((-36) - (36)) = 72. Example 3: Input: nums = [2,-1,0,4,-2,-9] Output: 0 Explanation: One optimal partition is: [2,4,-9] and [-1,0,-2]. The absolute difference between the sums of the arrays is abs((2 + 4 + -9) - (-1 + 0 + -2)) = 0. Constraints: 1 <= n <= 15 nums.length == 2 * n -107 <= nums[i] <= 107"}, {"role": "assistant", "content": "class Solution:\\n    def minimumDifference(self, nums: List[int]) -> int:\\n        N = len(nums) // 2 # Note this is N/2, ie no. of elements required in each.\\n        \\n        def get_sums(nums): # generate all combinations sum of k elements\\n            ans = {}\\n            N = len(nums)\\n            for k in range(1, N+1): # takes k element for nums\\n                sums = []\\n                for comb in combinations(nums, k):\\n                    s = sum(comb)\\n                    sums.append(s)\\n                ans[k] = sums\\n            return ans\\n        \\n        left_part, right_part = nums[:N], nums[N:]\\n        left_sums, right_sums = get_sums(left_part), get_sums(right_part)\\n        ans = abs(sum(left_part) - sum(right_part)) # the case when taking all N from left_part for left_ans, and vice versa\\n        total = sum(nums) \\n        half = total // 2 # the best sum required for each, we have to find sum nearest to this\\n        for k in range(1, N):\\n            left = left_sums[k] # if taking k no. from left_sums\\n            right = right_sums[N-k] # then we have to take remaining N-k from right_sums.\\n            right.sort() # sorting, so that we can binary search the required value\\n            for x in left:\\n                r = half - x # required, how much we need to add in x to bring it closer to half.\\n                p = bisect.bisect_left(right, r) # we are finding index of value closest to r, present in right, using binary search\\n                for q in [p, p-1]:\\n                    if 0 <= q < len(right):\\n                        left_ans_sum = x + right[q]\\n                        right_ans_sum = total - left_ans_sum\\n                        diff = abs(left_ans_sum - right_ans_sum)\\n                        ans = min(ans, diff) \\n        return ans\\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: Given two sorted 0-indexed integer arrays nums1 and nums2 as well as an integer k, return the kth (1-based) smallest product of nums1[i] * nums2[j] where 0 <= i < nums1.length and 0 <= j < nums2.length. Example 1: Input: nums1 = [2,5], nums2 = [3,4], k = 2 Output: 8 Explanation: The 2 smallest products are: - nums1[0] * nums2[0] = 2 * 3 = 6 - nums1[0] * nums2[1] = 2 * 4 = 8 The 2nd smallest product is 8. Example 2: Input: nums1 = [-4,-2,0,3], nums2 = [2,4], k = 6 Output: 0 Explanation: The 6 smallest products are: - nums1[0] * nums2[1] = (-4) * 4 = -16 - nums1[0] * nums2[0] = (-4) * 2 = -8 - nums1[1] * nums2[1] = (-2) * 4 = -8 - nums1[1] * nums2[0] = (-2) * 2 = -4 - nums1[2] * nums2[0] = 0 * 2 = 0 - nums1[2] * nums2[1] = 0 * 4 = 0 The 6th smallest product is 0. Example 3: Input: nums1 = [-2,-1,0,1,2], nums2 = [-3,-1,2,4,5], k = 3 Output: -6 Explanation: The 3 smallest products are: - nums1[0] * nums2[4] = (-2) * 5 = -10 - nums1[0] * nums2[3] = (-2) * 4 = -8 - nums1[4] * nums2[0] = 2 * (-3) = -6 The 3rd smallest product is -6. Constraints: 1 <= nums1.length, nums2.length <= 5 * 104 -105 <= nums1[i], nums2[j] <= 105 1 <= k <= nums1.length * nums2.length nums1 and nums2 are sorted."}, {"role": "assistant", "content": "class Solution:\\n    def kthSmallestProduct(self, nums1: List[int], nums2: List[int], k: int) -> int:\\n        \\n        def fn(val):\\n            \"\"\"Return count of products <= val.\"\"\"\\n            ans = 0\\n            for x in nums1: \\n                if x < 0: ans += len(nums2) - bisect_left(nums2, ceil(val/x))\\n                elif x == 0: \\n                    if 0 <= val: ans += len(nums2)\\n                else: ans += bisect_right(nums2, floor(val/x))\\n            return ans \\n            \\n        lo, hi = -10**10, 10**10 + 1\\n        while lo < hi: \\n            mid = lo + hi >> 1\\n            if fn(mid) < k: lo = mid + 1\\n            else: hi = mid\\n        return lo \\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: A city is represented as a bi-directional connected graph with n vertices where each vertex is labeled from 1 to n (inclusive). The edges in the graph are represented as a 2D integer array edges, where each edges[i] = [ui, vi] denotes a bi-directional edge between vertex ui and vertex vi. Every vertex pair is connected by at most one edge, and no vertex has an edge to itself. The time taken to traverse any edge is time minutes. Each vertex has a traffic signal which changes its color from green to red and vice versa every change minutes. All signals change at the same time. You can enter a vertex at any time, but can leave a vertex only when the signal is green. You cannot wait at a vertex if the signal is green. The second minimum value is defined as the smallest value strictly larger than the minimum value. For example the second minimum value of [2, 3, 4] is 3, and the second minimum value of [2, 2, 4] is 4. Given n, edges, time, and change, return the second minimum time it will take to go from vertex 1 to vertex n. Notes: You can go through any vertex any number of times, including 1 and n. You can assume that when the journey starts, all signals have just turned green. Example 1: Input: n = 5, edges = [[1,2],[1,3],[1,4],[3,4],[4,5]], time = 3, change = 5 Output: 13 Explanation: The figure on the left shows the given graph. The blue path in the figure on the right is the minimum time path. The time taken is: - Start at 1, time elapsed=0 - 1 -> 4: 3 minutes, time elapsed=3 - 4 -> 5: 3 minutes, time elapsed=6 Hence the minimum time needed is 6 minutes. The red path shows the path to get the second minimum time. - Start at 1, time elapsed=0 - 1 -> 3: 3 minutes, time elapsed=3 - 3 -> 4: 3 minutes, time elapsed=6 - Wait at 4 for 4 minutes, time elapsed=10 - 4 -> 5: 3 minutes, time elapsed=13 Hence the second minimum time is 13 minutes. Example 2: Input: n = 2, edges = [[1,2]], time = 3, change = 2 Output: 11 Explanation: The minimum time path is 1 -> 2 with time = 3 minutes. The second minimum time path is 1 -> 2 -> 1 -> 2 with time = 11 minutes. Constraints: 2 <= n <= 104 n - 1 <= edges.length <= min(2 * 104, n * (n - 1) / 2) edges[i].length == 2 1 <= ui, vi <= n ui != vi There are no duplicate edges. Each vertex can be reached directly or indirectly from every other vertex. 1 <= time, change <= 103"}, {"role": "assistant", "content": "class Solution:\\n    def secondMinimum(self, n: int, edges: List[List[int]], time: int, change: int) -> int:\\n        graph = [[] for _ in range(n)]\\n        for u, v in edges: \\n            graph[u-1].append(v-1)\\n            graph[v-1].append(u-1)\\n        pq = [(0, 0)]\\n        seen = [[] for _ in range(n)]\\n        least = None\\n        while pq: \\n            t, u = heappop(pq)\\n            if u == n-1: \\n                if least is None: least = t\\n                elif least < t: return t \\n            if (t//change) & 1: t = (t//change+1)*change # waiting for green\\n            t += time\\n            for v in graph[u]: \\n                if not seen[v] or len(seen[v]) == 1 and seen[v][0] != t: \\n                    seen[v].append(t)\\n                    heappush(pq, (t, v))\\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: You are given an integer n, which indicates that there are n courses labeled from 1 to n. You are also given a 2D integer array relations where relations[j] = [prevCoursej, nextCoursej] denotes that course prevCoursej has to be completed before course nextCoursej (prerequisite relationship). Furthermore, you are given a 0-indexed integer array time where time[i] denotes how many months it takes to complete the (i+1)th course. You must find the minimum number of months needed to complete all the courses following these rules: You may start taking a course at any time if the prerequisites are met. Any number of courses can be taken at the same time. Return the minimum number of months needed to complete all the courses. Note: The test cases are generated such that it is possible to complete every course (i.e., the graph is a directed acyclic graph). Example 1: Input: n = 3, relations = [[1,3],[2,3]], time = [3,2,5] Output: 8 Explanation: The figure above represents the given graph and the time required to complete each course. We start course 1 and course 2 simultaneously at month 0. Course 1 takes 3 months and course 2 takes 2 months to complete respectively. Thus, the earliest time we can start course 3 is at month 3, and the total time required is 3 + 5 = 8 months. Example 2: Input: n = 5, relations = [[1,5],[2,5],[3,5],[3,4],[4,5]], time = [1,2,3,4,5] Output: 12 Explanation: The figure above represents the given graph and the time required to complete each course. You can start courses 1, 2, and 3 at month 0. You can complete them after 1, 2, and 3 months respectively. Course 4 can be taken only after course 3 is completed, i.e., after 3 months. It is completed after 3 + 4 = 7 months. Course 5 can be taken only after courses 1, 2, 3, and 4 have been completed, i.e., after max(1,2,3,7) = 7 months. Thus, the minimum time needed to complete all the courses is 7 + 5 = 12 months. Constraints: 1 <= n <= 5 * 104 0 <= relations.length <= min(n * (n - 1) / 2, 5 * 104) relations[j].length == 2 1 <= prevCoursej, nextCoursej <= n prevCoursej != nextCoursej All the pairs [prevCoursej, nextCoursej] are unique. time.length == n 1 <= time[i] <= 104 The given graph is a directed acyclic graph."}, {"role": "assistant", "content": "class Solution:\\n    def minimumTime(self, n: int, relations: List[List[int]], time: List[int]) -> int:\\n        graph = [[] for _ in range(n)]\\n\\n        for prev, next in relations:\\n            graph[prev - 1].append(next - 1)\\n\\n        memo = [-1] * n\\n\\n        def calculateTime(course):\\n            if memo[course] != -1:\\n                return memo[course]\\n\\n            if not graph[course]:\\n                memo[course] = time[course]\\n                return memo[course]\\n\\n            max_prerequisite_time = 0\\n            for prereq in graph[course]:\\n                max_prerequisite_time = max(max_prerequisite_time, calculateTime(prereq))\\n\\n            memo[course] = max_prerequisite_time + time[course]\\n            return memo[course]\\n\\n        overall_min_time = 0\\n        for course in range(n):\\n            overall_min_time = max(overall_min_time, calculateTime(course))\\n\\n        return overall_min_time\\n\\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: There is an 8 x 8 chessboard containing n pieces (rooks, queens, or bishops). You are given a string array pieces of length n, where pieces[i] describes the type (rook, queen, or bishop) of the ith piece. In addition, you are given a 2D integer array positions also of length n, where positions[i] = [ri, ci] indicates that the ith piece is currently at the 1-based coordinate (ri, ci) on the chessboard. When making a move for a piece, you choose a destination square that the piece will travel toward and stop on. A rook can only travel horizontally or vertically from (r, c) to the direction of (r+1, c), (r-1, c), (r, c+1), or (r, c-1). A queen can only travel horizontally, vertically, or diagonally from (r, c) to the direction of (r+1, c), (r-1, c), (r, c+1), (r, c-1), (r+1, c+1), (r+1, c-1), (r-1, c+1), (r-1, c-1). A bishop can only travel diagonally from (r, c) to the direction of (r+1, c+1), (r+1, c-1), (r-1, c+1), (r-1, c-1). You must make a move for every piece on the board simultaneously. A move combination consists of all the moves performed on all the given pieces. Every second, each piece will instantaneously travel one square towards their destination if they are not already at it. All pieces start traveling at the 0th second. A move combination is invalid if, at a given time, two or more pieces occupy the same square. Return the number of valid move combinations\u200b\u200b\u200b\u200b\u200b. Notes: No two pieces will start in the same square. You may choose the square a piece is already on as its destination. If two pieces are directly adjacent to each other, it is valid for them to move past each other and swap positions in one second. Example 1: Input: pieces = [\"rook\"], positions = [[1,1]] Output: 15 Explanation: The image above shows the possible squares the piece can move to. Example 2: Input: pieces = [\"queen\"], positions = [[1,1]] Output: 22 Explanation: The image above shows the possible squares the piece can move to. Example 3: Input: pieces = [\"bishop\"], positions = [[4,3]] Output: 12 Explanation: The image above shows the possible squares the piece can move to. Constraints: n == pieces.length n == positions.length 1 <= n <= 4 pieces only contains the strings \"rook\", \"queen\", and \"bishop\". There will be at most one queen on the chessboard. 1 <= xi, yi <= 8 Each positions[i] is distinct."}, {"role": "assistant", "content": "class Solution:\\n    BOARD_SIZE = 8\\n    \\n    def diag(self, r, c):\\n        # Return all diagonal indices except (r, c)\\n        # Diagonal indices has the same r - c\\n        inv = r - c\\n        result = []\\n        for ri in range(self.BOARD_SIZE):\\n            ci = ri - inv\\n            if 0 <= ci < self.BOARD_SIZE and ri != r:\\n                result.append((ri, ci))\\n\\n        return result\\n    \\n    def reverseDiag(self, r, c):\\n        # Return all reverse diagonal indices except (r, c)\\n        # Reverse diagonal indices has the same r + c\\n        inv = r + c\\n        result = []\\n        for ri in range(self.BOARD_SIZE):\\n            ci = inv - ri\\n            if 0 <= ci < self.BOARD_SIZE and ri != r:\\n                result.append((ri, ci))\\n\\n        return result\\n    \\n    def generatePossiblePositions(self, piece, start):\\n        # Generate list of possible positions for every figure\\n        rs, cs = start[0] - 1, start[1] - 1\\n\\n        # Start position\\n        result = [(rs, cs)]\\n\\n        # Straight\\n        if piece == \"rook\" or piece == \"queen\":\\n            result.extend([(r, cs) for r in range(self.BOARD_SIZE) if r != rs])\\n            result.extend([(rs, c) for c in range(self.BOARD_SIZE) if c != cs])\\n\\n        # Diagonal\\n        if piece == \"bishop\" or piece == \"queen\":\\n            result.extend(self.diag(rs, cs))\\n            result.extend(self.reverseDiag(rs, cs))\\n\\n        return result\\n    \\n    def collide(self, start1, end1, start2, end2):\\n        # Check if two figures will collide\\n        # Collision occures if: \\n        #  - two figures have the same end points\\n        #  - one figure stands on the way of second one\\n        #\\n        # For this purpose let\\'s model each step of two pieces \\n        # and compare their positions at every time step.\\n        \\n        def steps(start, end):\\n            # Total steps that should be done\\n            return abs(end - start)\\n\\n        def step(start, end):\\n            # Step direction -1, 0, 1\\n            if steps(start, end) == 0:\\n                return 0\\n            return (end - start) / steps(start, end)\\n\\n        (rstart1, cstart1), (rend1, cend1) = start1, end1\\n        (rstart2, cstart2), (rend2, cend2) = start2, end2\\n\\n        # Find step direction for each piece\\n        rstep1, cstep1 = step(rstart1, rend1), step(cstart1, cend1)\\n        rstep2, cstep2 = step(rstart2, rend2), step(cstart2, cend2)\\n\\n        # Find maximum number of steps for each piece\\n        max_step1 = max(steps(rstart1, rend1), steps(cstart1, cend1))\\n        max_step2 = max(steps(rstart2, rend2), steps(cstart2, cend2))\\n\\n        # Move pieces step by step and compare their positions\\n        for step_i in range(max(max_step1, max_step2) + 1):\\n            step_i1 = min(step_i, max_step1)\\n            r1 = rstart1 + step_i1 * rstep1\\n            c1 = cstart1 + step_i1 * cstep1\\n\\n            step_i2 = min(step_i, max_step2)\\n            r2 = rstart2 + step_i2 * rstep2\\n            c2 = cstart2 + step_i2 * cstep2\\n\\n            # If positions are the same then collision occures\\n            if r1 == r2 and c1 == c2:\\n                return True\\n\\n        return False\\n    \\n    def countCombinations(self, pieces: List[str], positions: List[List[int]]) -> int:\\n        if len(pieces) == 0:\\n            return 0\\n\\n        n = len(pieces)\\n        \\n        # Make zero-indexed\\n        start_positions = [[r - 1, c - 1] for r, c in positions]\\n        \\n        # All possible positions\\n        possible_positions = [\\n            self.generatePossiblePositions(piece, start) \\n            for piece, start in zip(pieces, positions)\\n        ]\\n        \\n        # Let\\'s use DFS with backtracking\\n        # For that we will keep set of already occupied coordinates\\n        # and current positions of pieces\\n        occupied = set()\\n        current_positions = [None] * n  # None means that we didn\\'t placed the piece\\n        \\n        def collision(start, end):\\n            # Helper to check if moving from start to end position will collide with someone\\n            for start2, end2 in zip(start_positions, current_positions):\\n                if end2 is not None and self.collide(start, end, start2, end2):\\n                    return True\\n            return False\\n\\n        def dfs(piece_i=0):\\n            # All pieces are placed\\n            if piece_i == n:\\n                return 1\\n\\n            result = 0\\n            for position in possible_positions[piece_i]:\\n                # If position already occupied of collides with other pieces then skip it\\n                if position in occupied or collision(start_positions[piece_i], position):\\n                    continue\\n                \\n                # Occupy the position\\n                occupied.add(position)\\n                current_positions[piece_i] = position\\n                \\n                # Run DFS for next piece\\n                result += dfs(piece_i + 1)\\n                \\n                # Release the position\\n                occupied.remove(position)\\n                current_positions[piece_i] = None\\n                \\n            return result\\n\\n        return dfs()\\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: An original string, consisting of lowercase English letters, can be encoded by the following steps: Arbitrarily split it into a sequence of some number of non-empty substrings. Arbitrarily choose some elements (possibly none) of the sequence, and replace each with its length (as a numeric string). Concatenate the sequence as the encoded string. For example, one way to encode an original string \"abcdefghijklmnop\" might be: Split it as a sequence: [\"ab\", \"cdefghijklmn\", \"o\", \"p\"]. Choose the second and third elements to be replaced by their lengths, respectively. The sequence becomes [\"ab\", \"12\", \"1\", \"p\"]. Concatenate the elements of the sequence to get the encoded string: \"ab121p\". Given two encoded strings s1 and s2, consisting of lowercase English letters and digits 1-9 (inclusive), return true if there exists an original string that could be encoded as both s1 and s2. Otherwise, return false. Note: The test cases are generated such that the number of consecutive digits in s1 and s2 does not exceed 3. Example 1: Input: s1 = \"internationalization\", s2 = \"i18n\" Output: true Explanation: It is possible that \"internationalization\" was the original string. - \"internationalization\" -> Split: [\"internationalization\"] -> Do not replace any element -> Concatenate: \"internationalization\", which is s1. - \"internationalization\" -> Split: [\"i\", \"nternationalizatio\", \"n\"] -> Replace: [\"i\", \"18\", \"n\"] -> Concatenate: \"i18n\", which is s2 Example 2: Input: s1 = \"l123e\", s2 = \"44\" Output: true Explanation: It is possible that \"leetcode\" was the original string. - \"leetcode\" -> Split: [\"l\", \"e\", \"et\", \"cod\", \"e\"] -> Replace: [\"l\", \"1\", \"2\", \"3\", \"e\"] -> Concatenate: \"l123e\", which is s1. - \"leetcode\" -> Split: [\"leet\", \"code\"] -> Replace: [\"4\", \"4\"] -> Concatenate: \"44\", which is s2. Example 3: Input: s1 = \"a5b\", s2 = \"c5b\" Output: false Explanation: It is impossible. - The original string encoded as s1 must start with the letter 'a'. - The original string encoded as s2 must start with the letter 'c'. Constraints: 1 <= s1.length, s2.length <= 40 s1 and s2 consist of digits 1-9 (inclusive), and lowercase English letters only. The number of consecutive digits in s1 and s2 does not exceed 3."}, {"role": "assistant", "content": "class Solution:\\n    def possiblyEquals(self, s1: str, s2: str) -> bool:\\n        \\n        def gg(s): \\n            \"\"\"Return possible length\"\"\"\\n            ans = [int(s)]\\n            if len(s) == 2: \\n                if s[1] != \\'0\\': ans.append(int(s[0]) + int(s[1]))\\n                return ans\\n            elif len(s) == 3: \\n                if s[1] != \\'0\\': ans.append(int(s[:1]) + int(s[1:]))\\n                if s[2] != \\'0\\': ans.append(int(s[:2]) + int(s[2:]))\\n                if s[1] != \\'0\\' and s[2] != \\'0\\': ans.append(int(s[0]) + int(s[1]) + int(s[2]))\\n            return ans \\n        \\n        @cache\\n        def fn(i, j, diff): \\n            \"\"\"Return True if s1[i:] matches s2[j:] with given differences.\"\"\"\\n            if i == len(s1) and j == len(s2): return diff == 0\\n            if i < len(s1) and s1[i].isdigit(): \\n                ii = i\\n                while ii < len(s1) and s1[ii].isdigit(): ii += 1\\n                for x in gg(s1[i:ii]): \\n                    if fn(ii, j, diff-x): return True \\n            elif j < len(s2) and s2[j].isdigit(): \\n                jj = j \\n                while jj < len(s2) and s2[jj].isdigit(): jj += 1\\n                for x in gg(s2[j:jj]): \\n                    if fn(i, jj, diff+x): return True \\n            elif diff == 0: \\n                if i == len(s1) or j == len(s2) or s1[i] != s2[j]: return False \\n                return fn(i+1, j+1, 0)\\n            elif diff > 0: \\n                if i == len(s1): return False \\n                return fn(i+1, j, diff-1)\\n            else: \\n                if j == len(s2): return False \\n                return fn(i, j+1, diff+1)\\n            \\n        return fn(0, 0, 0)\\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: There is an undirected graph with n nodes numbered from 0 to n - 1 (inclusive). You are given a 0-indexed integer array values where values[i] is the value of the ith node. You are also given a 0-indexed 2D integer array edges, where each edges[j] = [uj, vj, timej] indicates that there is an undirected edge between the nodes uj and vj, and it takes timej seconds to travel between the two nodes. Finally, you are given an integer maxTime. A valid path in the graph is any path that starts at node 0, ends at node 0, and takes at most maxTime seconds to complete. You may visit the same node multiple times. The quality of a valid path is the sum of the values of the unique nodes visited in the path (each node's value is added at most once to the sum). Return the maximum quality of a valid path. Note: There are at most four edges connected to each node. Example 1: Input: values = [0,32,10,43], edges = [[0,1,10],[1,2,15],[0,3,10]], maxTime = 49 Output: 75 Explanation: One possible path is 0 -> 1 -> 0 -> 3 -> 0. The total time taken is 10 + 10 + 10 + 10 = 40 <= 49. The nodes visited are 0, 1, and 3, giving a maximal path quality of 0 + 32 + 43 = 75. Example 2: Input: values = [5,10,15,20], edges = [[0,1,10],[1,2,10],[0,3,10]], maxTime = 30 Output: 25 Explanation: One possible path is 0 -> 3 -> 0. The total time taken is 10 + 10 = 20 <= 30. The nodes visited are 0 and 3, giving a maximal path quality of 5 + 20 = 25. Example 3: Input: values = [1,2,3,4], edges = [[0,1,10],[1,2,11],[2,3,12],[1,3,13]], maxTime = 50 Output: 7 Explanation: One possible path is 0 -> 1 -> 3 -> 1 -> 0. The total time taken is 10 + 13 + 13 + 10 = 46 <= 50. The nodes visited are 0, 1, and 3, giving a maximal path quality of 1 + 2 + 4 = 7. Constraints: n == values.length 1 <= n <= 1000 0 <= values[i] <= 108 0 <= edges.length <= 2000 edges[j].length == 3 0 <= uj < vj <= n - 1 10 <= timej, maxTime <= 100 All the pairs [uj, vj] are unique. There are at most four edges connected to each node. The graph may not be connected."}, {"role": "assistant", "content": "class Solution:\\n    def maximalPathQuality(self, values: List[int], edges: List[List[int]], maxTime: int) -> int:\\n        ans = 0\\n        graph = collections.defaultdict(dict)\\n        for u, v, t in edges:\\n            graph[u][v] = t\\n            graph[v][u] = t\\n        \\n        def dfs(curr, visited, score, cost):\\n            if curr == 0:\\n                nonlocal ans\\n                ans = max(ans, score)\\n            \\n            for nxt, time in graph[curr].items():\\n                if time <= cost:\\n                    dfs(nxt, visited|set([nxt]), score+values[nxt]*(nxt not in visited), cost-time)\\n        \\n        dfs(0, set([0]), values[0], maxTime)\\n        return ans\\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: You have n tasks and m workers. Each task has a strength requirement stored in a 0-indexed integer array tasks, with the ith task requiring tasks[i] strength to complete. The strength of each worker is stored in a 0-indexed integer array workers, with the jth worker having workers[j] strength. Each worker can only be assigned to a single task and must have a strength greater than or equal to the task's strength requirement (i.e., workers[j] >= tasks[i]). Additionally, you have pills magical pills that will increase a worker's strength by strength. You can decide which workers receive the magical pills, however, you may only give each worker at most one magical pill. Given the 0-indexed integer arrays tasks and workers and the integers pills and strength, return the maximum number of tasks that can be completed. Example 1: Input: tasks = [3,2,1], workers = [0,3,3], pills = 1, strength = 1 Output: 3 Explanation: We can assign the magical pill and tasks as follows: - Give the magical pill to worker 0. - Assign worker 0 to task 2 (0 + 1 >= 1) - Assign worker 1 to task 1 (3 >= 2) - Assign worker 2 to task 0 (3 >= 3) Example 2: Input: tasks = [5,4], workers = [0,0,0], pills = 1, strength = 5 Output: 1 Explanation: We can assign the magical pill and tasks as follows: - Give the magical pill to worker 0. - Assign worker 0 to task 0 (0 + 5 >= 5) Example 3: Input: tasks = [10,15,30], workers = [0,10,10,10,10], pills = 3, strength = 10 Output: 2 Explanation: We can assign the magical pills and tasks as follows: - Give the magical pill to worker 0 and worker 1. - Assign worker 0 to task 0 (0 + 10 >= 10) - Assign worker 1 to task 1 (10 + 10 >= 15) The last pill is not given because it will not make any worker strong enough for the last task. Constraints: n == tasks.length m == workers.length 1 <= n, m <= 5 * 104 0 <= pills <= m 0 <= tasks[i], workers[j], strength <= 109"}, {"role": "assistant", "content": "class Solution:\\n    def maxTaskAssign(self, tasks: List[int], workers: List[int], pills: int, strength: int) -> int:\\n        # workers sorted in reverse order, tasks sorted in normal order\\n        def can_assign(n):\\n            task_i = 0\\n            task_temp = deque()\\n            n_pills = pills\\n            for i in range(n-1,-1,-1):\\n                while task_i < n and tasks[task_i] <= workers[i]+strength:\\n                    task_temp.append(tasks[task_i])\\n                    task_i += 1\\n                \\n                if len(task_temp) == 0:\\n                    return False\\n                if workers[i] >= task_temp[0]:\\n                    task_temp.popleft()\\n                elif n_pills > 0:\\n                    task_temp.pop()\\n                    n_pills -= 1\\n                else:\\n                    return False\\n            return True\\n        \\n        tasks.sort()\\n        workers.sort(reverse = True)\\n        \\n        l = 0\\n        r = min(len(tasks), len(workers))\\n        res = -1\\n        while l <= r:\\n            m = (l+r)//2\\n            if can_assign(m):\\n                res = m\\n                l = m+1\\n            else:\\n                r = m-1\\n        return res\\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: You are given an integer n indicating the number of people in a network. Each person is labeled from 0 to n - 1. You are also given a 0-indexed 2D integer array restrictions, where restrictions[i] = [xi, yi] means that person xi and person yi cannot become friends, either directly or indirectly through other people. Initially, no one is friends with each other. You are given a list of friend requests as a 0-indexed 2D integer array requests, where requests[j] = [uj, vj] is a friend request between person uj and person vj. A friend request is successful if uj and vj can be friends. Each friend request is processed in the given order (i.e., requests[j] occurs before requests[j + 1]), and upon a successful request, uj and vj become direct friends for all future friend requests. Return a boolean array result, where each result[j] is true if the jth friend request is successful or false if it is not. Note: If uj and vj are already direct friends, the request is still successful. Example 1: Input: n = 3, restrictions = [[0,1]], requests = [[0,2],[2,1]] Output: [true,false] Explanation: Request 0: Person 0 and person 2 can be friends, so they become direct friends. Request 1: Person 2 and person 1 cannot be friends since person 0 and person 1 would be indirect friends (1--2--0). Example 2: Input: n = 3, restrictions = [[0,1]], requests = [[1,2],[0,2]] Output: [true,false] Explanation: Request 0: Person 1 and person 2 can be friends, so they become direct friends. Request 1: Person 0 and person 2 cannot be friends since person 0 and person 1 would be indirect friends (0--2--1). Example 3: Input: n = 5, restrictions = [[0,1],[1,2],[2,3]], requests = [[0,4],[1,2],[3,1],[3,4]] Output: [true,false,true,false] Explanation: Request 0: Person 0 and person 4 can be friends, so they become direct friends. Request 1: Person 1 and person 2 cannot be friends since they are directly restricted. Request 2: Person 3 and person 1 can be friends, so they become direct friends. Request 3: Person 3 and person 4 cannot be friends since person 0 and person 1 would be indirect friends (0--4--3--1). Constraints: 2 <= n <= 1000 0 <= restrictions.length <= 1000 restrictions[i].length == 2 0 <= xi, yi <= n - 1 xi != yi 1 <= requests.length <= 1000 requests[j].length == 2 0 <= uj, vj <= n - 1 uj != vj"}, {"role": "assistant", "content": "class Solution:\\n    def friendRequests(self, n: int, restrictions: List[List[int]], requests: List[List[int]]) -> List[bool]:        \\n        result = [False for _ in requests]\\n        \\n        connected_components = [{i} for i in range(n)]\\n        \\n        connected_comp_dict = {}\\n        for i in range(n):\\n            connected_comp_dict[i] = i\\n        \\n        banned_by_comps = [set() for i in range(n)]\\n        for res in restrictions:\\n            banned_by_comps[res[0]].add(res[1])\\n            banned_by_comps[res[1]].add(res[0])\\n        for i,r in enumerate(requests):\\n            n1, n2 = r[0], r[1]\\n            c1, c2 = connected_comp_dict[n1], connected_comp_dict[n2]\\n            if c1 == c2:\\n                result[i] = True\\n            else:\\n                if not (connected_components[c1].intersection(banned_by_comps[c2]) or connected_components[c2].intersection(banned_by_comps[c1])):\\n                    connected_components[c1].update(connected_components[c2])\\n                    banned_by_comps[c1].update(banned_by_comps[c2])\\n                    for node in connected_components[c2]:\\n                        connected_comp_dict[node] = c1\\n                    result[i] = True\\n                \\n        return result\\n\\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: A k-mirror number is a positive integer without leading zeros that reads the same both forward and backward in base-10 as well as in base-k. For example, 9 is a 2-mirror number. The representation of 9 in base-10 and base-2 are 9 and 1001 respectively, which read the same both forward and backward. On the contrary, 4 is not a 2-mirror number. The representation of 4 in base-2 is 100, which does not read the same both forward and backward. Given the base k and the number n, return the sum of the n smallest k-mirror numbers. Example 1: Input: k = 2, n = 5 Output: 25 Explanation: The 5 smallest 2-mirror numbers and their representations in base-2 are listed as follows: base-10 base-2 1 1 3 11 5 101 7 111 9 1001 Their sum = 1 + 3 + 5 + 7 + 9 = 25. Example 2: Input: k = 3, n = 7 Output: 499 Explanation: The 7 smallest 3-mirror numbers are and their representations in base-3 are listed as follows: base-10 base-3 1 1 2 2 4 11 8 22 121 11111 151 12121 212 21212 Their sum = 1 + 2 + 4 + 8 + 121 + 151 + 212 = 499. Example 3: Input: k = 7, n = 17 Output: 20379000 Explanation: The 17 smallest 7-mirror numbers are: 1, 2, 3, 4, 5, 6, 8, 121, 171, 242, 292, 16561, 65656, 2137312, 4602064, 6597956, 6958596 Constraints: 2 <= k <= 9 1 <= n <= 30"}, {"role": "assistant", "content": "class Solution:\\n    def kMirror(self, k: int, n: int) -> int:\\n        \\n        def fn(x):\\n            \"\"\"Return next k-symmetric number.\"\"\"\\n            n = len(x)//2\\n            for i in range(n, len(x)): \\n                if int(x[i])+1 < k: \\n                    x[i] = x[~i] = str(int(x[i])+1)\\n                    for ii in range(n, i): x[ii] = x[~ii] = \\'0\\'\\n                    return x\\n            return [\"1\"] + [\"0\"]*(len(x)-1) + [\"1\"]\\n                \\n        x = [\"0\"]\\n        ans = 0\\n        for _ in range(n): \\n            while True: \\n                x = fn(x)\\n                val = int(\"\".join(x), k)\\n                if str(val)[::-1] == str(val): break\\n            ans += val\\n        return ans \\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: A farmer has a rectangular grid of land with m rows and n columns that can be divided into unit cells. Each cell is either fertile (represented by a 1) or barren (represented by a 0). All cells outside the grid are considered barren. A pyramidal plot of land can be defined as a set of cells with the following criteria: The number of cells in the set has to be greater than 1 and all cells must be fertile. The apex of a pyramid is the topmost cell of the pyramid. The height of a pyramid is the number of rows it covers. Let (r, c) be the apex of the pyramid, and its height be h. Then, the plot comprises of cells (i, j) where r <= i <= r + h - 1 and c - (i - r) <= j <= c + (i - r). An inverse pyramidal plot of land can be defined as a set of cells with similar criteria: The number of cells in the set has to be greater than 1 and all cells must be fertile. The apex of an inverse pyramid is the bottommost cell of the inverse pyramid. The height of an inverse pyramid is the number of rows it covers. Let (r, c) be the apex of the pyramid, and its height be h. Then, the plot comprises of cells (i, j) where r - h + 1 <= i <= r and c - (r - i) <= j <= c + (r - i). Some examples of valid and invalid pyramidal (and inverse pyramidal) plots are shown below. Black cells indicate fertile cells. Given a 0-indexed m x n binary matrix grid representing the farmland, return the total number of pyramidal and inverse pyramidal plots that can be found in grid. Example 1: Input: grid = [[0,1,1,0],[1,1,1,1]] Output: 2 Explanation: The 2 possible pyramidal plots are shown in blue and red respectively. There are no inverse pyramidal plots in this grid. Hence total number of pyramidal and inverse pyramidal plots is 2 + 0 = 2. Example 2: Input: grid = [[1,1,1],[1,1,1]] Output: 2 Explanation: The pyramidal plot is shown in blue, and the inverse pyramidal plot is shown in red. Hence the total number of plots is 1 + 1 = 2. Example 3: Input: grid = [[1,1,1,1,0],[1,1,1,1,1],[1,1,1,1,1],[0,1,0,0,1]] Output: 13 Explanation: There are 7 pyramidal plots, 3 of which are shown in the 2nd and 3rd figures. There are 6 inverse pyramidal plots, 2 of which are shown in the last figure. The total number of plots is 7 + 6 = 13. Constraints: m == grid.length n == grid[i].length 1 <= m, n <= 1000 1 <= m * n <= 105 grid[i][j] is either 0 or 1."}, {"role": "assistant", "content": "class Solution:\\n    def countPyramids(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        vals = [[inf]*n for _ in range(m)]\\n        for i in range(m):\\n            for j in range(n): \\n                if grid[i][j] == 0: vals[i][j] = 0\\n                elif j == 0: vals[i][j] = 1\\n                else: vals[i][j] = min(vals[i][j], 1 + vals[i][j-1])\\n                if grid[i][~j] == 0: vals[i][~j] = 0\\n                elif j == 0: vals[i][~j] = 1\\n                else: vals[i][~j] = min(vals[i][~j], 1 + vals[i][~j+1])\\n        \\n        def fn(vals): \\n            \"\"\"Return count of pyramid in given grid.\"\"\"\\n            ans = 0 \\n            for j in range(n):\\n                width = 0\\n                for i in range(m): \\n                    if vals[i][j]: width = min(width+1, vals[i][j])\\n                    else: width = 0\\n                    ans += max(0, width-1)\\n            return ans \\n        \\n        return fn(vals) + fn(vals[::-1])\\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: You are given an integer n indicating there are n people numbered from 0 to n - 1. You are also given a 0-indexed 2D integer array meetings where meetings[i] = [xi, yi, timei] indicates that person xi and person yi have a meeting at timei. A person may attend multiple meetings at the same time. Finally, you are given an integer firstPerson. Person 0 has a secret and initially shares the secret with a person firstPerson at time 0. This secret is then shared every time a meeting takes place with a person that has the secret. More formally, for every meeting, if a person xi has the secret at timei, then they will share the secret with person yi, and vice versa. The secrets are shared instantaneously. That is, a person may receive the secret and share it with people in other meetings within the same time frame. Return a list of all the people that have the secret after all the meetings have taken place. You may return the answer in any order. Example 1: Input: n = 6, meetings = [[1,2,5],[2,3,8],[1,5,10]], firstPerson = 1 Output: [0,1,2,3,5] Explanation: At time 0, person 0 shares the secret with person 1. At time 5, person 1 shares the secret with person 2. At time 8, person 2 shares the secret with person 3. At time 10, person 1 shares the secret with person 5.\u200b\u200b\u200b\u200b Thus, people 0, 1, 2, 3, and 5 know the secret after all the meetings. Example 2: Input: n = 4, meetings = [[3,1,3],[1,2,2],[0,3,3]], firstPerson = 3 Output: [0,1,3] Explanation: At time 0, person 0 shares the secret with person 3. At time 2, neither person 1 nor person 2 know the secret. At time 3, person 3 shares the secret with person 0 and person 1. Thus, people 0, 1, and 3 know the secret after all the meetings. Example 3: Input: n = 5, meetings = [[3,4,2],[1,2,1],[2,3,1]], firstPerson = 1 Output: [0,1,2,3,4] Explanation: At time 0, person 0 shares the secret with person 1. At time 1, person 1 shares the secret with person 2, and person 2 shares the secret with person 3. Note that person 2 can share the secret at the same time as receiving it. At time 2, person 3 shares the secret with person 4. Thus, people 0, 1, 2, 3, and 4 know the secret after all the meetings. Constraints: 2 <= n <= 105 1 <= meetings.length <= 105 meetings[i].length == 3 0 <= xi, yi <= n - 1 xi != yi 1 <= timei <= 105 1 <= firstPerson <= n - 1"}, {"role": "assistant", "content": "class Solution:\\n    def findAllPeople(self, n: int, meetings: List[List[int]], firstPerson: int) -> List[int]:\\n        can = {0, firstPerson}\\n        for _, grp in groupby(sorted(meetings, key=lambda x: x[2]), key=lambda x: x[2]): \\n            queue = set()\\n            graph = defaultdict(list)\\n            for x, y, _ in grp: \\n                graph[x].append(y)\\n                graph[y].append(x)\\n                if x in can: queue.add(x)\\n                if y in can: queue.add(y)\\n                    \\n            queue = deque(queue)\\n            while queue: \\n                x = queue.popleft()\\n                for y in graph[x]: \\n                    if y not in can: \\n                        can.add(y)\\n                        queue.append(y)\\n        return can\\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: You are given a 0-indexed 2D integer array pairs where pairs[i] = [starti, endi]. An arrangement of pairs is valid if for every index i where 1 <= i < pairs.length, we have endi-1 == starti. Return any valid arrangement of pairs. Note: The inputs will be generated such that there exists a valid arrangement of pairs. Example 1: Input: pairs = [[5,1],[4,5],[11,9],[9,4]] Output: [[11,9],[9,4],[4,5],[5,1]] Explanation: This is a valid arrangement since endi-1 always equals starti. end0 = 9 == 9 = start1 end1 = 4 == 4 = start2 end2 = 5 == 5 = start3 Example 2: Input: pairs = [[1,3],[3,2],[2,1]] Output: [[1,3],[3,2],[2,1]] Explanation: This is a valid arrangement since endi-1 always equals starti. end0 = 3 == 3 = start1 end1 = 2 == 2 = start2 The arrangements [[2,1],[1,3],[3,2]] and [[3,2],[2,1],[1,3]] are also valid. Example 3: Input: pairs = [[1,2],[1,3],[2,1]] Output: [[1,2],[2,1],[1,3]] Explanation: This is a valid arrangement since endi-1 always equals starti. end0 = 2 == 2 = start1 end1 = 1 == 1 = start2 Constraints: 1 <= pairs.length <= 105 pairs[i].length == 2 0 <= starti, endi <= 109 starti != endi No two pairs are exactly the same. There exists a valid arrangement of pairs."}, {"role": "assistant", "content": "class Solution:\\n    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:\\n        graph = defaultdict(list)\\n        degree = defaultdict(int) # net out degree \\n        for x, y in pairs: \\n            graph[x].append(y)\\n            degree[x] += 1\\n            degree[y] -= 1\\n                \\n        for k in degree: \\n            if degree[k] == 1: \\n                x = k\\n                break \\n                \\n        ans = []\\n\\n        def fn(x): \\n            \"\"\"Return Eulerian path via dfs.\"\"\"\\n            while graph[x]: fn(graph[x].pop()) \\n            ans.append(x)\\n        \\n        fn(x)\\n        ans.reverse()\\n        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]\\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: Fruits are available at some positions on an infinite x-axis. You are given a 2D integer array fruits where fruits[i] = [positioni, amounti] depicts amounti fruits at the position positioni. fruits is already sorted by positioni in ascending order, and each positioni is unique. You are also given an integer startPos and an integer k. Initially, you are at the position startPos. From any position, you can either walk to the left or right. It takes one step to move one unit on the x-axis, and you can walk at most k steps in total. For every position you reach, you harvest all the fruits at that position, and the fruits will disappear from that position. Return the maximum total number of fruits you can harvest. Example 1: Input: fruits = [[2,8],[6,3],[8,6]], startPos = 5, k = 4 Output: 9 Explanation: The optimal way is to: - Move right to position 6 and harvest 3 fruits - Move right to position 8 and harvest 6 fruits You moved 3 steps and harvested 3 + 6 = 9 fruits in total. Example 2: Input: fruits = [[0,9],[4,1],[5,7],[6,2],[7,4],[10,9]], startPos = 5, k = 4 Output: 14 Explanation: You can move at most k = 4 steps, so you cannot reach position 0 nor 10. The optimal way is to: - Harvest the 7 fruits at the starting position 5 - Move left to position 4 and harvest 1 fruit - Move right to position 6 and harvest 2 fruits - Move right to position 7 and harvest 4 fruits You moved 1 + 3 = 4 steps and harvested 7 + 1 + 2 + 4 = 14 fruits in total. Example 3: Input: fruits = [[0,3],[6,4],[8,5]], startPos = 3, k = 2 Output: 0 Explanation: You can move at most k = 2 steps and cannot reach any position with fruits. Constraints: 1 <= fruits.length <= 105 fruits[i].length == 2 0 <= startPos, positioni <= 2 * 105 positioni-1 < positioni for any i > 0 (0-indexed) 1 <= amounti <= 104 0 <= k <= 2 * 105"}, {"role": "assistant", "content": "class Solution:\\n    def maxTotalFruits(self, fruits: List[List[int]], startPos: int, k: int) -> int:\\n    \\n        fruitMap = defaultdict(int)\\n        \\n        for position, amount in fruits:\\n            fruitMap[position] = amount\\n        \\n        \\n        if k == 0:\\n            return fruitMap[startPos]\\n        \\n        totalLeft = 0 # max sum if we go k steps to the left\\n        totalRight = 0 # max sum if we go k steps to the right\\n        inBetween = 0 # max sum if we go x steps to the left & k steps to the right (ensuring that we don\\'t move more than k steps in total)\\n        \\n        dp = dict()\\n        \\n        for i in range(startPos,startPos-k-1, -1):\\n            totalLeft += fruitMap[i]\\n            dp[i] = totalLeft\\n            \\n        for i in range(startPos,startPos+k+1):\\n            totalRight += fruitMap[i]\\n            dp[i] = totalRight\\n            \\n        \\n        leftSteps = 1\\n        rightSteps = k-2\\n        \\n        while rightSteps > 0:\\n            currAmount = 0\\n            \\n            # go right & collect\\n            currAmount += dp[startPos-leftSteps]\\n            # go left & collect\\n            currAmount += dp[startPos+rightSteps]\\n            \\n            \\n            inBetween = max(inBetween, currAmount-fruitMap[startPos])\\n            \\n            leftSteps += 1\\n            rightSteps -= 2\\n        \\n        \\n        leftSteps = k-2\\n        rightSteps = 1\\n        \\n        while leftSteps > 0:\\n            currAmount = 0\\n            \\n            # go right & collect\\n            currAmount += dp[startPos-leftSteps]\\n            # go left & collect\\n            currAmount += dp[startPos+rightSteps]\\n            \\n            inBetween = max(inBetween, currAmount-fruitMap[startPos])\\n            \\n            leftSteps -= 2\\n            rightSteps += 1\\n        \\n            \\n        return max(totalLeft, totalRight, inBetween)\\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: You are given a 0-indexed array arr consisting of n positive integers, and a positive integer k. The array arr is called K-increasing if arr[i-k] <= arr[i] holds for every index i, where k <= i <= n-1. For example, arr = [4, 1, 5, 2, 6, 2] is K-increasing for k = 2 because: arr[0] <= arr[2] (4 <= 5) arr[1] <= arr[3] (1 <= 2) arr[2] <= arr[4] (5 <= 6) arr[3] <= arr[5] (2 <= 2) However, the same arr is not K-increasing for k = 1 (because arr[0] > arr[1]) or k = 3 (because arr[0] > arr[3]). In one operation, you can choose an index i and change arr[i] into any positive integer. Return the minimum number of operations required to make the array K-increasing for the given k. Example 1: Input: arr = [5,4,3,2,1], k = 1 Output: 4 Explanation: For k = 1, the resultant array has to be non-decreasing. Some of the K-increasing arrays that can be formed are [5,6,7,8,9], [1,1,1,1,1], [2,2,3,4,4]. All of them require 4 operations. It is suboptimal to change the array to, for example, [6,7,8,9,10] because it would take 5 operations. It can be shown that we cannot make the array K-increasing in less than 4 operations. Example 2: Input: arr = [4,1,5,2,6,2], k = 2 Output: 0 Explanation: This is the same example as the one in the problem description. Here, for every index i where 2 <= i <= 5, arr[i-2] <= arr[i]. Since the given array is already K-increasing, we do not need to perform any operations. Example 3: Input: arr = [4,1,5,2,6,2], k = 3 Output: 2 Explanation: Indices 3 and 5 are the only ones not satisfying arr[i-3] <= arr[i] for 3 <= i <= 5. One of the ways we can make the array K-increasing is by changing arr[3] to 4 and arr[5] to 5. The array will now be [4,1,5,4,6,5]. Note that there can be other ways to make the array K-increasing, but none of them require less than 2 operations. Constraints: 1 <= arr.length <= 105 1 <= arr[i], k <= arr.length"}, {"role": "assistant", "content": "class Solution:\\n    def kIncreasing(self, arr: List[int], k: int) -> int:\\n        \\n        def fn(sub): \\n            \"\"\"Return ops to make sub non-decreasing.\"\"\"\\n            vals = []\\n            for x in sub: \\n                k = bisect_right(vals, x)\\n                if k == len(vals): vals.append(x)\\n                else: vals[k] = x\\n            return len(sub) - len(vals)\\n        \\n        return sum(fn(arr[i:len(arr):k]) for i in range(k))\\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: You are given two positive integers left and right with left <= right. Calculate the product of all integers in the inclusive range [left, right]. Since the product may be very large, you will abbreviate it following these steps: Count all trailing zeros in the product and remove them. Let us denote this count as C. For example, there are 3 trailing zeros in 1000, and there are 0 trailing zeros in 546. Denote the remaining number of digits in the product as d. If d > 10, then express the product as ... where denotes the first 5 digits of the product, and denotes the last 5 digits of the product after removing all trailing zeros. If d <= 10, we keep it unchanged. For example, we express 1234567654321 as 12345...54321, but 1234567 is represented as 1234567. Finally, represent the product as a string \"...eC\". For example, 12345678987600000 will be represented as \"12345...89876e5\". Return a string denoting the abbreviated product of all integers in the inclusive range [left, right]. Example 1: Input: left = 1, right = 4 Output: \"24e0\" Explanation: The product is 1 \u00d7 2 \u00d7 3 \u00d7 4 = 24. There are no trailing zeros, so 24 remains the same. The abbreviation will end with \"e0\". Since the number of digits is 2, which is less than 10, we do not have to abbreviate it further. Thus, the final representation is \"24e0\". Example 2: Input: left = 2, right = 11 Output: \"399168e2\" Explanation: The product is 39916800. There are 2 trailing zeros, which we remove to get 399168. The abbreviation will end with \"e2\". The number of digits after removing the trailing zeros is 6, so we do not abbreviate it further. Hence, the abbreviated product is \"399168e2\". Example 3: Input: left = 371, right = 375 Output: \"7219856259e3\" Explanation: The product is 7219856259000. Constraints: 1 <= left <= right <= 104"}, {"role": "assistant", "content": "class Solution:\\n    def abbreviateProduct(self, left: int, right: int) -> str:\\n        ans = prefix = suffix = 1\\n        trailing = 0 \\n        flag = False \\n        for x in range(left, right+1): \\n            if not flag: \\n                ans *= x\\n                while ans % 10 == 0: ans //= 10 \\n                if ans >= 1e10: flag = True \\n            prefix *= x\\n            suffix *= x\\n            while prefix >= 1e12: prefix //= 10 \\n            while suffix % 10 == 0: \\n                trailing += 1\\n                suffix //= 10 \\n            if suffix >= 1e10: suffix %= 10_000_000_000\\n        while prefix >= 100000: prefix //= 10 \\n        suffix %= 100000\\n        if flag: return f\"{prefix}...{suffix:>05}e{trailing}\"\\n        return f\"{ans}e{trailing}\"\\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: Alice had a 0-indexed array arr consisting of n positive integers. She chose an arbitrary positive integer k and created two new 0-indexed integer arrays lower and higher in the following manner: lower[i] = arr[i] - k, for every index i where 0 <= i < n higher[i] = arr[i] + k, for every index i where 0 <= i < n Unfortunately, Alice lost all three arrays. However, she remembers the integers that were present in the arrays lower and higher, but not the array each integer belonged to. Help Alice and recover the original array. Given an array nums consisting of 2n integers, where exactly n of the integers were present in lower and the remaining in higher, return the original array arr. In case the answer is not unique, return any valid array. Note: The test cases are generated such that there exists at least one valid array arr. Example 1: Input: nums = [2,10,6,4,8,12] Output: [3,7,11] Explanation: If arr = [3,7,11] and k = 1, we get lower = [2,6,10] and higher = [4,8,12]. Combining lower and higher gives us [2,6,10,4,8,12], which is a permutation of nums. Another valid possibility is that arr = [5,7,9] and k = 3. In that case, lower = [2,4,6] and higher = [8,10,12]. Example 2: Input: nums = [1,1,3,3] Output: [2,2] Explanation: If arr = [2,2] and k = 1, we get lower = [1,1] and higher = [3,3]. Combining lower and higher gives us [1,1,3,3], which is equal to nums. Note that arr cannot be [1,3] because in that case, the only possible way to obtain [1,1,3,3] is with k = 0. This is invalid since k must be positive. Example 3: Input: nums = [5,435] Output: [220] Explanation: The only possible combination is arr = [220] and k = 215. Using them, we get lower = [5] and higher = [435]. Constraints: 2 * n == nums.length 1 <= n <= 1000 1 <= nums[i] <= 109 The test cases are generated such that there exists at least one valid array arr."}, {"role": "assistant", "content": "class Solution:\\n    def recoverArray(self, nums: List[int]) -> List[int]:\\n        nums.sort()\\n        cnt = Counter(nums)\\n        for i in range(1, len(nums)): \\n            diff = nums[i] - nums[0]\\n            if diff and diff&1 == 0: \\n                ans = []\\n                freq = cnt.copy()\\n                for k, v in freq.items(): \\n                    if v: \\n                        if freq[k+diff] < v: break \\n                        ans.extend([k+diff//2]*v)\\n                        freq[k+diff] -= v\\n                else: return ans \\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: A company is organizing a meeting and has a list of n employees, waiting to be invited. They have arranged for a large circular table, capable of seating any number of employees. The employees are numbered from 0 to n - 1. Each employee has a favorite person and they will attend the meeting only if they can sit next to their favorite person at the table. The favorite person of an employee is not themself. Given a 0-indexed integer array favorite, where favorite[i] denotes the favorite person of the ith employee, return the maximum number of employees that can be invited to the meeting. Example 1: Input: favorite = [2,2,1,2] Output: 3 Explanation: The above figure shows how the company can invite employees 0, 1, and 2, and seat them at the round table. All employees cannot be invited because employee 2 cannot sit beside employees 0, 1, and 3, simultaneously. Note that the company can also invite employees 1, 2, and 3, and give them their desired seats. The maximum number of employees that can be invited to the meeting is 3. Example 2: Input: favorite = [1,2,0] Output: 3 Explanation: Each employee is the favorite person of at least one other employee, and the only way the company can invite them is if they invite every employee. The seating arrangement will be the same as that in the figure given in example 1: - Employee 0 will sit between employees 2 and 1. - Employee 1 will sit between employees 0 and 2. - Employee 2 will sit between employees 1 and 0. The maximum number of employees that can be invited to the meeting is 3. Example 3: Input: favorite = [3,0,1,4,1] Output: 4 Explanation: The above figure shows how the company will invite employees 0, 1, 3, and 4, and seat them at the round table. Employee 2 cannot be invited because the two spots next to their favorite employee 1 are taken. So the company leaves them out of the meeting. The maximum number of employees that can be invited to the meeting is 4. Constraints: n == favorite.length 2 <= n <= 105 0 <= favorite[i] <= n - 1 favorite[i] != i"}, {"role": "assistant", "content": "class Solution:\\n    def maximumInvitations(self, favorite: List[int]) -> int:\\n        n = len(favorite)\\n        graph = [[] for _ in range(n)]\\n        for i, x in enumerate(favorite): graph[x].append(i)\\n        \\n        def bfs(x, seen): \\n            \"\"\"Return longest arm of x.\"\"\"\\n            ans = 0 \\n            queue = deque([x])\\n            while queue: \\n                for _ in range(len(queue)): \\n                    u = queue.popleft()\\n                    for v in graph[u]: \\n                        if v not in seen: \\n                            seen.add(v)\\n                            queue.append(v)\\n                ans += 1\\n            return ans \\n        \\n        ans = 0 \\n        seen = [False]*n\\n        for i, x in enumerate(favorite): \\n            if favorite[x] == i and not seen[i]: \\n                seen[i] = seen[x] = True \\n                ans += bfs(i, {i, x}) + bfs(x, {i, x})\\n                \\n        dp = [0]*n\\n        for i, x in enumerate(favorite): \\n            if dp[i] == 0: \\n                ii, val = i, 0\\n                memo = {}\\n                while ii not in memo: \\n                    if dp[ii]: \\n                        cycle = dp[ii]\\n                        break\\n                    memo[ii] = val\\n                    val += 1\\n                    ii = favorite[ii]\\n                else: cycle = val - memo[ii]\\n                for k in memo: dp[k] = cycle\\n        return max(ans, max(dp))\\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: You are given an m x n binary matrix grid where each cell is either 0 (empty) or 1 (occupied). You are then given stamps of size stampHeight x stampWidth. We want to fit the stamps such that they follow the given restrictions and requirements: Cover all the empty cells. Do not cover any of the occupied cells. We can put as many stamps as we want. Stamps can overlap with each other. Stamps are not allowed to be rotated. Stamps must stay completely inside the grid. Return true if it is possible to fit the stamps while following the given restrictions and requirements. Otherwise, return false. Example 1: Input: grid = [[1,0,0,0],[1,0,0,0],[1,0,0,0],[1,0,0,0],[1,0,0,0]], stampHeight = 4, stampWidth = 3 Output: true Explanation: We have two overlapping stamps (labeled 1 and 2 in the image) that are able to cover all the empty cells. Example 2: Input: grid = [[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]], stampHeight = 2, stampWidth = 2 Output: false Explanation: There is no way to fit the stamps onto all the empty cells without the stamps going outside the grid. Constraints: m == grid.length n == grid[r].length 1 <= m, n <= 105 1 <= m * n <= 2 * 105 grid[r][c] is either 0 or 1. 1 <= stampHeight, stampWidth <= 105"}, {"role": "assistant", "content": "class Solution:\\n    def possibleToStamp(self, grid, H, W):\\n        def acc_2d(grid):\\n            dp = [[0] * (n+1) for _ in range(m+1)] \\n            for c, r in product(range(n), range(m)):\\n                dp[r+1][c+1] = dp[r+1][c] + dp[r][c+1] - dp[r][c] + grid[r][c]\\n            return dp\\n\\n        def sumRegion(r1, c1, r2, c2):\\n            return dp[r2+1][c2+1] - dp[r1][c2+1] - dp[r2+1][c1] + dp[r1][c1]  \\n\\n        m, n = len(grid), len(grid[0])\\n        dp = acc_2d(grid)\\n\\n        diff = [[0] * (n+1) for _ in range(m+1)] \\n        for c in range(n - W + 1):\\n            for r in range(m - H + 1):\\n                if sumRegion(r, c, r + H - 1, c + W - 1) == 0:\\n                    diff[r][c] += 1\\n                    diff[r][c+W] -= 1\\n                    diff[r+H][c] -= 1\\n                    diff[r+H][c+W] += 1\\n        \\n        dp2 = acc_2d(diff)\\n        for c, r in product(range(n), range(m)):\\n            if dp2[r+1][c+1] == 0 and grid[r][c] != 1: return False\\n\\n        return True\\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: You have n flower seeds. Every seed must be planted first before it can begin to grow, then bloom. Planting a seed takes time and so does the growth of a seed. You are given two 0-indexed integer arrays plantTime and growTime, of length n each: plantTime[i] is the number of full days it takes you to plant the ith seed. Every day, you can work on planting exactly one seed. You do not have to work on planting the same seed on consecutive days, but the planting of a seed is not complete until you have worked plantTime[i] days on planting it in total. growTime[i] is the number of full days it takes the ith seed to grow after being completely planted. After the last day of its growth, the flower blooms and stays bloomed forever. From the beginning of day 0, you can plant the seeds in any order. Return the earliest possible day where all seeds are blooming. Example 1: Input: plantTime = [1,4,3], growTime = [2,3,1] Output: 9 Explanation: The grayed out pots represent planting days, colored pots represent growing days, and the flower represents the day it blooms. One optimal way is: On day 0, plant the 0th seed. The seed grows for 2 full days and blooms on day 3. On days 1, 2, 3, and 4, plant the 1st seed. The seed grows for 3 full days and blooms on day 8. On days 5, 6, and 7, plant the 2nd seed. The seed grows for 1 full day and blooms on day 9. Thus, on day 9, all the seeds are blooming. Example 2: Input: plantTime = [1,2,3,2], growTime = [2,1,2,1] Output: 9 Explanation: The grayed out pots represent planting days, colored pots represent growing days, and the flower represents the day it blooms. One optimal way is: On day 1, plant the 0th seed. The seed grows for 2 full days and blooms on day 4. On days 0 and 3, plant the 1st seed. The seed grows for 1 full day and blooms on day 5. On days 2, 4, and 5, plant the 2nd seed. The seed grows for 2 full days and blooms on day 8. On days 6 and 7, plant the 3rd seed. The seed grows for 1 full day and blooms on day 9. Thus, on day 9, all the seeds are blooming. Example 3: Input: plantTime = [1], growTime = [1] Output: 2 Explanation: On day 0, plant the 0th seed. The seed grows for 1 full day and blooms on day 2. Thus, on day 2, all the seeds are blooming. Constraints: n == plantTime.length == growTime.length 1 <= n <= 105 1 <= plantTime[i], growTime[i] <= 104"}, {"role": "assistant", "content": "class Solution:\\n    def earliestFullBloom(self, plantTime: List[int], growTime: List[int]) -> int:\\n        res = 0\\n        for grow, plant in sorted(zip(growTime, plantTime)):\\n            res = max(res, grow) + plant\\n        return res\\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: You have n computers. You are given the integer n and a 0-indexed integer array batteries where the ith battery can run a computer for batteries[i] minutes. You are interested in running all n computers simultaneously using the given batteries. Initially, you can insert at most one battery into each computer. After that and at any integer time moment, you can remove a battery from a computer and insert another battery any number of times. The inserted battery can be a totally new battery or a battery from another computer. You may assume that the removing and inserting processes take no time. Note that the batteries cannot be recharged. Return the maximum number of minutes you can run all the n computers simultaneously. Example 1: Input: n = 2, batteries = [3,3,3] Output: 4 Explanation: Initially, insert battery 0 into the first computer and battery 1 into the second computer. After two minutes, remove battery 1 from the second computer and insert battery 2 instead. Note that battery 1 can still run for one minute. At the end of the third minute, battery 0 is drained, and you need to remove it from the first computer and insert battery 1 instead. By the end of the fourth minute, battery 1 is also drained, and the first computer is no longer running. We can run the two computers simultaneously for at most 4 minutes, so we return 4. Example 2: Input: n = 2, batteries = [1,1,1,1] Output: 2 Explanation: Initially, insert battery 0 into the first computer and battery 2 into the second computer. After one minute, battery 0 and battery 2 are drained so you need to remove them and insert battery 1 into the first computer and battery 3 into the second computer. After another minute, battery 1 and battery 3 are also drained so the first and second computers are no longer running. We can run the two computers simultaneously for at most 2 minutes, so we return 2. Constraints: 1 <= n <= batteries.length <= 105 1 <= batteries[i] <= 109"}, {"role": "assistant", "content": "class Solution:\\n    def maxRunTime(self, n: int, batteries: List[int]) -> int:\\n        batteries.sort()\\n        extra = sum(batteries[:-n])\\n        batteries = batteries[-n:]\\n        \\n        ans = prefix = 0 \\n        for i, x in enumerate(batteries): \\n            prefix += x \\n            if i+1 < len(batteries) and batteries[i+1]*(i+1) - prefix > extra: return (prefix + extra) // (i+1)\\n        return (prefix + extra) // n\\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: Along a long library corridor, there is a line of seats and decorative plants. You are given a 0-indexed string corridor of length n consisting of letters 'S' and 'P' where each 'S' represents a seat and each 'P' represents a plant. One room divider has already been installed to the left of index 0, and another to the right of index n - 1. Additional room dividers can be installed. For each position between indices i - 1 and i (1 <= i <= n - 1), at most one divider can be installed. Divide the corridor into non-overlapping sections, where each section has exactly two seats with any number of plants. There may be multiple ways to perform the division. Two ways are different if there is a position with a room divider installed in the first way but not in the second way. Return the number of ways to divide the corridor. Since the answer may be very large, return it modulo 109 + 7. If there is no way, return 0. Example 1: Input: corridor = \"SSPPSPS\" Output: 3 Explanation: There are 3 different ways to divide the corridor. The black bars in the above image indicate the two room dividers already installed. Note that in each of the ways, each section has exactly two seats. Example 2: Input: corridor = \"PPSPSP\" Output: 1 Explanation: There is only 1 way to divide the corridor, by not installing any additional dividers. Installing any would create some section that does not have exactly two seats. Example 3: Input: corridor = \"S\" Output: 0 Explanation: There is no way to divide the corridor because there will always be a section that does not have exactly two seats. Constraints: n == corridor.length 1 <= n <= 105 corridor[i] is either 'S' or 'P'."}, {"role": "assistant", "content": "class Solution:\\n    def numberOfWays(self, corridor):\\n        seat, res, plant = 0, 1, 0\\n        for i in corridor:\\n            if i==\\'S\\':\\n                seat += 1\\n            else:\\n                if seat == 2:\\n                    plant += 1\\n            if seat == 3:\\n                res = res*(plant+1) % (10**9 + 7)\\n                seat , plant = 1 , 0\\n        if seat != 2:\\n            return 0\\n        return res\\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: There are two types of persons: The good person: The person who always tells the truth. The bad person: The person who might tell the truth and might lie. You are given a 0-indexed 2D integer array statements of size n x n that represents the statements made by n people about each other. More specifically, statements[i][j] could be one of the following: 0 which represents a statement made by person i that person j is a bad person. 1 which represents a statement made by person i that person j is a good person. 2 represents that no statement is made by person i about person j. Additionally, no person ever makes a statement about themselves. Formally, we have that statements[i][i] = 2 for all 0 <= i < n. Return the maximum number of people who can be good based on the statements made by the n people. Example 1: Input: statements = [[2,1,2],[1,2,2],[2,0,2]] Output: 2 Explanation: Each person makes a single statement. - Person 0 states that person 1 is good. - Person 1 states that person 0 is good. - Person 2 states that person 1 is bad. Let's take person 2 as the key. - Assuming that person 2 is a good person: - Based on the statement made by person 2, person 1 is a bad person. - Now we know for sure that person 1 is bad and person 2 is good. - Based on the statement made by person 1, and since person 1 is bad, they could be: - telling the truth. There will be a contradiction in this case and this assumption is invalid. - lying. In this case, person 0 is also a bad person and lied in their statement. - Following that person 2 is a good person, there will be only one good person in the group. - Assuming that person 2 is a bad person: - Based on the statement made by person 2, and since person 2 is bad, they could be: - telling the truth. Following this scenario, person 0 and 1 are both bad as explained before. - Following that person 2 is bad but told the truth, there will be no good persons in the group. - lying. In this case person 1 is a good person. - Since person 1 is a good person, person 0 is also a good person. - Following that person 2 is bad and lied, there will be two good persons in the group. We can see that at most 2 persons are good in the best case, so we return 2. Note that there is more than one way to arrive at this conclusion. Example 2: Input: statements = [[2,0],[0,2]] Output: 1 Explanation: Each person makes a single statement. - Person 0 states that person 1 is bad. - Person 1 states that person 0 is bad. Let's take person 0 as the key. - Assuming that person 0 is a good person: - Based on the statement made by person 0, person 1 is a bad person and was lying. - Following that person 0 is a good person, there will be only one good person in the group. - Assuming that person 0 is a bad person: - Based on the statement made by person 0, and since person 0 is bad, they could be: - telling the truth. Following this scenario, person 0 and 1 are both bad. - Following that person 0 is bad but told the truth, there will be no good persons in the group. - lying. In this case person 1 is a good person. - Following that person 0 is bad and lied, there will be only one good person in the group. We can see that at most, one person is good in the best case, so we return 1. Note that there is more than one way to arrive at this conclusion. Constraints: n == statements.length == statements[i].length 2 <= n <= 15 statements[i][j] is either 0, 1, or 2. statements[i][i] == 2"}, {"role": "assistant", "content": "class Solution:        \\n    def maximumGood(self, statements: List[List[int]]) -> int:\\n        \\n        n = len(statements)\\n        res = 0\\n        \\n        def checkGood(person, mask):\\n            if (mask>>person) & 1:\\n                return True\\n            return False\\n        \\n        def validateStatement(mask):\\n            for i in range(n):\\n                if checkGood(i, mask):\\n                    for j in range(n):\\n                        statement = statements[i][j]\\n                        \\n                        if (statement==0 and checkGood(j, mask)) or (statement==1 and not checkGood(j, mask)):\\n                            return False\\n            return True\\n        \\n        for i in range(1,1<<n): \\n            if validateStatement(i):\\n                res = max(res, bin(i).count(\\'1\\'))\\n        return res\\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: The hash of a 0-indexed string s of length k, given integers p and m, is computed using the following function: hash(s, p, m) = (val(s[0]) * p0 + val(s[1]) * p1 + ... + val(s[k-1]) * pk-1) mod m. Where val(s[i]) represents the index of s[i] in the alphabet from val('a') = 1 to val('z') = 26. You are given a string s and the integers power, modulo, k, and hashValue. Return sub, the first substring of s of length k such that hash(sub, power, modulo) == hashValue. The test cases will be generated such that an answer always exists. A substring is a contiguous non-empty sequence of characters within a string. Example 1: Input: s = \"leetcode\", power = 7, modulo = 20, k = 2, hashValue = 0 Output: \"ee\" Explanation: The hash of \"ee\" can be computed to be hash(\"ee\", 7, 20) = (5 * 1 + 5 * 7) mod 20 = 40 mod 20 = 0. \"ee\" is the first substring of length 2 with hashValue 0. Hence, we return \"ee\". Example 2: Input: s = \"fbxzaad\", power = 31, modulo = 100, k = 3, hashValue = 32 Output: \"fbx\" Explanation: The hash of \"fbx\" can be computed to be hash(\"fbx\", 31, 100) = (6 * 1 + 2 * 31 + 24 * 312) mod 100 = 23132 mod 100 = 32. The hash of \"bxz\" can be computed to be hash(\"bxz\", 31, 100) = (2 * 1 + 24 * 31 + 26 * 312) mod 100 = 25732 mod 100 = 32. \"fbx\" is the first substring of length 3 with hashValue 32. Hence, we return \"fbx\". Note that \"bxz\" also has a hash of 32 but it appears later than \"fbx\". Constraints: 1 <= k <= s.length <= 2 * 104 1 <= power, modulo <= 109 0 <= hashValue < modulo s consists of lowercase English letters only. The test cases are generated such that an answer always exists."}, {"role": "assistant", "content": "class Solution:\\n\\t\\tdef subStrHash(self, s: str, power: int, modulo: int, k: int, hashValue: int) -> str:\\n\\n\\t\\t\\tsc=0\\n\\t\\t\\ti=len(s)-1\\n\\t\\t\\ta=0\\n\\t\\t\\tm = (power**k)%modulo\\n\\n\\t\\t\\twhile i>-1:\\n\\n\\t\\t\\t\\tsc=(sc*power + ord(s[i])-97+1)%modulo\\n\\n\\t\\t\\t\\tif i+k<len(s):\\n\\t\\t\\t\\t\\tsc=(sc-((ord(s[i+k])-97+1)*m))%modulo\\n\\n\\t\\t\\t\\tif sc==hashValue:\\n\\t\\t\\t\\t\\ta=i\\n\\t\\t\\t\\ti=i-1\\n\\n\\t\\t\\treturn s[a:a+k]\\n\\n\\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: You are given a 0-indexed array of strings words. Each string consists of lowercase English letters only. No letter occurs more than once in any string of words. Two strings s1 and s2 are said to be connected if the set of letters of s2 can be obtained from the set of letters of s1 by any one of the following operations: Adding exactly one letter to the set of the letters of s1. Deleting exactly one letter from the set of the letters of s1. Replacing exactly one letter from the set of the letters of s1 with any letter, including itself. The array words can be divided into one or more non-intersecting groups. A string belongs to a group if any one of the following is true: It is connected to at least one other string of the group. It is the only string present in the group. Note that the strings in words should be grouped in such a manner that a string belonging to a group cannot be connected to a string present in any other group. It can be proved that such an arrangement is always unique. Return an array ans of size 2 where: ans[0] is the maximum number of groups words can be divided into, and ans[1] is the size of the largest group. Example 1: Input: words = [\"a\",\"b\",\"ab\",\"cde\"] Output: [2,3] Explanation: - words[0] can be used to obtain words[1] (by replacing 'a' with 'b'), and words[2] (by adding 'b'). So words[0] is connected to words[1] and words[2]. - words[1] can be used to obtain words[0] (by replacing 'b' with 'a'), and words[2] (by adding 'a'). So words[1] is connected to words[0] and words[2]. - words[2] can be used to obtain words[0] (by deleting 'b'), and words[1] (by deleting 'a'). So words[2] is connected to words[0] and words[1]. - words[3] is not connected to any string in words. Thus, words can be divided into 2 groups [\"a\",\"b\",\"ab\"] and [\"cde\"]. The size of the largest group is 3. Example 2: Input: words = [\"a\",\"ab\",\"abc\"] Output: [1,3] Explanation: - words[0] is connected to words[1]. - words[1] is connected to words[0] and words[2]. - words[2] is connected to words[1]. Since all strings are connected to each other, they should be grouped together. Thus, the size of the largest group is 3. Constraints: 1 <= words.length <= 2 * 104 1 <= words[i].length <= 26 words[i] consists of lowercase English letters only. No letter occurs more than once in words[i]."}, {"role": "assistant", "content": "class Solution:\\n    def groupStrings(self, words: List[str]) -> List[int]:\\n        n = len(words)\\n        uf = UnionFind(n)\\n        seen = {}\\n        for i, word in enumerate(words): \\n            m = reduce(or_, (1<<ord(ch)-97 for ch in word))\\n            if m in seen: uf.union(i, seen[m])\\n            for k in range(26): \\n                if m ^ 1<<k in seen: uf.union(i, seen[m ^ 1<<k])\\n                if m & 1<<k: \\n                    mm = m ^ 1<<k ^ 1<<26\\n                    if mm in seen: uf.union(i, seen[mm])\\n                    seen[mm] = i\\n            seen[m] = i \\n        freq = Counter(uf.find(i) for i in range(n))\\n        return [len(freq), max(freq.values())]\\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: You are given a 0-indexed integer array nums consisting of 3 * n elements. You are allowed to remove any subsequence of elements of size exactly n from nums. The remaining 2 * n elements will be divided into two equal parts: The first n elements belonging to the first part and their sum is sumfirst. The next n elements belonging to the second part and their sum is sumsecond. The difference in sums of the two parts is denoted as sumfirst - sumsecond. For example, if sumfirst = 3 and sumsecond = 2, their difference is 1. Similarly, if sumfirst = 2 and sumsecond = 3, their difference is -1. Return the minimum difference possible between the sums of the two parts after the removal of n elements. Example 1: Input: nums = [3,1,2] Output: -1 Explanation: Here, nums has 3 elements, so n = 1. Thus we have to remove 1 element from nums and divide the array into two equal parts. - If we remove nums[0] = 3, the array will be [1,2]. The difference in sums of the two parts will be 1 - 2 = -1. - If we remove nums[1] = 1, the array will be [3,2]. The difference in sums of the two parts will be 3 - 2 = 1. - If we remove nums[2] = 2, the array will be [3,1]. The difference in sums of the two parts will be 3 - 1 = 2. The minimum difference between sums of the two parts is min(-1,1,2) = -1. Example 2: Input: nums = [7,9,5,8,1,3] Output: 1 Explanation: Here n = 2. So we must remove 2 elements and divide the remaining array into two parts containing two elements each. If we remove nums[2] = 5 and nums[3] = 8, the resultant array will be [7,9,1,3]. The difference in sums will be (7+9) - (1+3) = 12. To obtain the minimum difference, we should remove nums[1] = 9 and nums[4] = 1. The resultant array becomes [7,5,8,3]. The difference in sums of the two parts is (7+5) - (8+3) = 1. It can be shown that it is not possible to obtain a difference smaller than 1. Constraints: nums.length == 3 * n 1 <= n <= 105 1 <= nums[i] <= 105"}, {"role": "assistant", "content": "class Solution:\\n    def minimumDifference(self, nums: List[int]) -> int:\\n        n = len(nums) // 3\\n\\n        # calculate max_sum using min_heap for second part\\n        min_heap = nums[(2 * n) :]\\n        heapq.heapify(min_heap)\\n\\n        max_sum = [0] * (n + 2)\\n        max_sum[n + 1] = sum(min_heap)\\n        for i in range((2 * n) - 1, n - 1, -1):\\n            # push current\\n            heapq.heappush(min_heap, nums[i])\\n            # popout minimum from heap\\n            val = heapq.heappop(min_heap)\\n            # max_sum for this partition\\n            max_sum[i - n + 1] = max_sum[i - n + 2] - val + nums[i]\\n\\n\\n        # calculate min_sum using max_heap for first part\\n        max_heap = [-x for x in nums[:n]]\\n        heapq.heapify(max_heap)\\n\\n        min_sum = [0] * (n + 2)\\n        min_sum[0] = -sum(max_heap)\\n        for i in range(n, (2 * n)):\\n            # push current\\n            heapq.heappush(max_heap, -nums[i])\\n            # popout maximum from heap\\n            val = -heapq.heappop(max_heap)\\n            # min_sum for this partition\\n            min_sum[i - n + 1] = min_sum[i - n] - val + nums[i]\\n\\n\\n        # find min difference bw second part (max_sum) and first part (min_sum)\\n        ans = math.inf\\n        for i in range(0, n + 1):\\n            print(i, min_sum[i], max_sum[i])\\n            ans = min((min_sum[i] - max_sum[i + 1]), ans)\\n\\n        return ans\\n\\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: You are given a 0-indexed binary string s which represents a sequence of train cars. s[i] = '0' denotes that the ith car does not contain illegal goods and s[i] = '1' denotes that the ith car does contain illegal goods. As the train conductor, you would like to get rid of all the cars containing illegal goods. You can do any of the following three operations any number of times: Remove a train car from the left end (i.e., remove s[0]) which takes 1 unit of time. Remove a train car from the right end (i.e., remove s[s.length - 1]) which takes 1 unit of time. Remove a train car from anywhere in the sequence which takes 2 units of time. Return the minimum time to remove all the cars containing illegal goods. Note that an empty sequence of cars is considered to have no cars containing illegal goods. Example 1: Input: s = \"1100101\" Output: 5 Explanation: One way to remove all the cars containing illegal goods from the sequence is to - remove a car from the left end 2 times. Time taken is 2 * 1 = 2. - remove a car from the right end. Time taken is 1. - remove the car containing illegal goods found in the middle. Time taken is 2. This obtains a total time of 2 + 1 + 2 = 5. An alternative way is to - remove a car from the left end 2 times. Time taken is 2 * 1 = 2. - remove a car from the right end 3 times. Time taken is 3 * 1 = 3. This also obtains a total time of 2 + 3 = 5. 5 is the minimum time taken to remove all the cars containing illegal goods. There are no other ways to remove them with less time. Example 2: Input: s = \"0010\" Output: 2 Explanation: One way to remove all the cars containing illegal goods from the sequence is to - remove a car from the left end 3 times. Time taken is 3 * 1 = 3. This obtains a total time of 3. Another way to remove all the cars containing illegal goods from the sequence is to - remove the car containing illegal goods found in the middle. Time taken is 2. This obtains a total time of 2. Another way to remove all the cars containing illegal goods from the sequence is to - remove a car from the right end 2 times. Time taken is 2 * 1 = 2. This obtains a total time of 2. 2 is the minimum time taken to remove all the cars containing illegal goods. There are no other ways to remove them with less time. Constraints: 1 <= s.length <= 2 * 105 s[i] is either '0' or '1'."}, {"role": "assistant", "content": "class Solution:\\n    def minimumTime(self, s):\\n        left, res, n = 0, len(s), len(s)\\n        lefts = []\\n        for i,c in enumerate(s):\\n            left = min(left + (c == \\'1\\') * 2, i + 1)\\n            lefts.append(left)\\n        right = 0\\n        rights = []\\n        for i,c in enumerate(s[::-1]):\\n            right = min(right + (c == \\'1\\') * 2, i + 1)\\n            rights.append(right)   \\n        rights = rights[::-1]\\n        res = rights[0]\\n        for i in range(n-1):\\n            res = min(res,lefts[i]+rights[i+1])        \\n        res = min(res,lefts[n-1])\\n        return res\\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: You are given an integer array nums of length n and an integer numSlots such that 2 * numSlots >= n. There are numSlots slots numbered from 1 to numSlots. You have to place all n integers into the slots such that each slot contains at most two numbers. The AND sum of a given placement is the sum of the bitwise AND of every number with its respective slot number. For example, the AND sum of placing the numbers [1, 3] into slot 1 and [4, 6] into slot 2 is equal to (1 AND 1) + (3 AND 1) + (4 AND 2) + (6 AND 2) = 1 + 1 + 0 + 2 = 4. Return the maximum possible AND sum of nums given numSlots slots. Example 1: Input: nums = [1,2,3,4,5,6], numSlots = 3 Output: 9 Explanation: One possible placement is [1, 4] into slot 1, [2, 6] into slot 2, and [3, 5] into slot 3. This gives the maximum AND sum of (1 AND 1) + (4 AND 1) + (2 AND 2) + (6 AND 2) + (3 AND 3) + (5 AND 3) = 1 + 0 + 2 + 2 + 3 + 1 = 9. Example 2: Input: nums = [1,3,10,4,7,1], numSlots = 9 Output: 24 Explanation: One possible placement is [1, 1] into slot 1, [3] into slot 3, [4] into slot 4, [7] into slot 7, and [10] into slot 9. This gives the maximum AND sum of (1 AND 1) + (1 AND 1) + (3 AND 3) + (4 AND 4) + (7 AND 7) + (10 AND 9) = 1 + 1 + 3 + 4 + 7 + 8 = 24. Note that slots 2, 5, 6, and 8 are empty which is permitted. Constraints: n == nums.length 1 <= numSlots <= 9 1 <= n <= 2 * numSlots 1 <= nums[i] <= 15"}, {"role": "assistant", "content": "class Solution:\\n    def maximumANDSum(self, nums: List[int], numSlots: int) -> int:\\n        \\n        @cache\\n        def fn(k, m): \\n            \"\"\"Return max AND sum.\"\"\"\\n            if k == len(nums): return 0 \\n            ans = 0 \\n            for i in range(numSlots): \\n                if m & 1<<2*i == 0 or m & 1<<2*i+1 == 0: \\n                    if m & 1<<2*i == 0: mm = m ^ 1<<2*i\\n                    else: mm = m ^ 1<<2*i+1\\n                    ans = max(ans, (nums[k] & i+1) + fn(k+1, mm))\\n            return ans \\n        \\n        return fn(0, 0)\\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: You are given two 0-indexed arrays nums1 and nums2 of length n, both of which are permutations of [0, 1, ..., n - 1]. A good triplet is a set of 3 distinct values which are present in increasing order by position both in nums1 and nums2. In other words, if we consider pos1v as the index of the value v in nums1 and pos2v as the index of the value v in nums2, then a good triplet will be a set (x, y, z) where 0 <= x, y, z <= n - 1, such that pos1x < pos1y < pos1z and pos2x < pos2y < pos2z. Return the total number of good triplets. Example 1: Input: nums1 = [2,0,1,3], nums2 = [0,1,2,3] Output: 1 Explanation: There are 4 triplets (x,y,z) such that pos1x < pos1y < pos1z. They are (2,0,1), (2,0,3), (2,1,3), and (0,1,3). Out of those triplets, only the triplet (0,1,3) satisfies pos2x < pos2y < pos2z. Hence, there is only 1 good triplet. Example 2: Input: nums1 = [4,0,1,3,2], nums2 = [4,1,0,2,3] Output: 4 Explanation: The 4 good triplets are (4,0,3), (4,0,2), (4,1,3), and (4,1,2). Constraints: n == nums1.length == nums2.length 3 <= n <= 105 0 <= nums1[i], nums2[i] <= n - 1 nums1 and nums2 are permutations of [0, 1, ..., n - 1]."}, {"role": "assistant", "content": "class Solution:\\n    def goodTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        n = len(nums1)\\n        hashmap2 = {}\\n        for i in range(n):\\n            hashmap2[nums2[i]] = i\\n        indices = []\\n        for num in nums1:\\n            indices.append(hashmap2[num])\\n        from sortedcontainers import SortedList\\n        left, right = SortedList(), SortedList()\\n        leftCount, rightCount = [], []\\n        for i in range(n):\\n            leftCount.append(left.bisect_left(indices[i]))\\n            left.add(indices[i])\\n        for i in range(n - 1, -1, -1):\\n            rightCount.append(len(right) - right.bisect_right(indices[i]))\\n            right.add(indices[i])\\n        count = 0\\n        for i in range(n):\\n            count += leftCount[i] * rightCount[n - 1 - i]\\n        return count\\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: Given a 0-indexed integer array nums of length n and an integer k, return the number of pairs (i, j) such that: 0 <= i < j <= n - 1 and nums[i] * nums[j] is divisible by k. Example 1: Input: nums = [1,2,3,4,5], k = 2 Output: 7 Explanation: The 7 pairs of indices whose corresponding products are divisible by 2 are (0, 1), (0, 3), (1, 2), (1, 3), (1, 4), (2, 3), and (3, 4). Their products are 2, 4, 6, 8, 10, 12, and 20 respectively. Other pairs such as (0, 2) and (2, 4) have products 3 and 15 respectively, which are not divisible by 2. Example 2: Input: nums = [1,2,3,4], k = 5 Output: 0 Explanation: There does not exist any pair of indices whose corresponding product is divisible by 5. Constraints: 1 <= nums.length <= 105 1 <= nums[i], k <= 105"}, {"role": "assistant", "content": "class Solution:\\n    def countPairs(self, nums: List[int], k: int) -> int:\\n        counter = Counter() #hashmap dicitionary of python\\n        ans = 0\\n        n = len(nums)\\n        \\n        for i in range(n):\\n            x = math.gcd(k,nums[i]) #ex: 10 = k and we have nums[i] as 12 so gcd will be 2\\n            want = k // x #what do we want from upper ex: we need 5\\n            for num in counter:\\n                if num % want == 0: #so if we find a number that is divisible by 5 then we can multiply it to 12 and make it a factor of 10 for ex we find 20 so it will be 240 which is divisible by 10 hence we will add it to answer\\n                    ans += counter[num] #we are adding the freq as we can find no of numbers that have same factor\\n            counter[x] += 1 #here we are increasing the freq of 2 so that if we find 5 next time we can add these to the answer\\n        return ans\\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: You are given a 0-indexed 2D integer array tires where tires[i] = [fi, ri] indicates that the ith tire can finish its xth successive lap in fi * ri(x-1) seconds. For example, if fi = 3 and ri = 2, then the tire would finish its 1st lap in 3 seconds, its 2nd lap in 3 * 2 = 6 seconds, its 3rd lap in 3 * 22 = 12 seconds, etc. You are also given an integer changeTime and an integer numLaps. The race consists of numLaps laps and you may start the race with any tire. You have an unlimited supply of each tire and after every lap, you may change to any given tire (including the current tire type) if you wait changeTime seconds. Return the minimum time to finish the race. Example 1: Input: tires = [[2,3],[3,4]], changeTime = 5, numLaps = 4 Output: 21 Explanation: Lap 1: Start with tire 0 and finish the lap in 2 seconds. Lap 2: Continue with tire 0 and finish the lap in 2 * 3 = 6 seconds. Lap 3: Change tires to a new tire 0 for 5 seconds and then finish the lap in another 2 seconds. Lap 4: Continue with tire 0 and finish the lap in 2 * 3 = 6 seconds. Total time = 2 + 6 + 5 + 2 + 6 = 21 seconds. The minimum time to complete the race is 21 seconds. Example 2: Input: tires = [[1,10],[2,2],[3,4]], changeTime = 6, numLaps = 5 Output: 25 Explanation: Lap 1: Start with tire 1 and finish the lap in 2 seconds. Lap 2: Continue with tire 1 and finish the lap in 2 * 2 = 4 seconds. Lap 3: Change tires to a new tire 1 for 6 seconds and then finish the lap in another 2 seconds. Lap 4: Continue with tire 1 and finish the lap in 2 * 2 = 4 seconds. Lap 5: Change tires to tire 0 for 6 seconds then finish the lap in another 1 second. Total time = 2 + 4 + 6 + 2 + 4 + 6 + 1 = 25 seconds. The minimum time to complete the race is 25 seconds. Constraints: 1 <= tires.length <= 105 tires[i].length == 2 1 <= fi, changeTime <= 105 2 <= ri <= 105 1 <= numLaps <= 1000"}, {"role": "assistant", "content": "class Solution:\\n    def minimumFinishTime(self, tires: List[List[int]], changeTime: int, numLaps: int) -> int:\\n        tires.sort()\\n        newTires = []\\n        minTime = [changeTime*(i-1) + tires[0][0]*i for i in range(numLaps+1)]\\n        minTime[0] = 0\\n        maxi = 0\\n        for f,r in tires:\\n            if not newTires or f>newTires[-1][0] and r<newTires[-1][1]:\\n                newTires.append([f,r])\\n                t = f\\n                i = 1\\n                while i<numLaps and t*(r-1)<changeTime:\\n                    t = t*r + f\\n                    i += 1\\n                    if minTime[i]>t:\\n                        minTime[i]=t\\n                        maxi = max(i,maxi)\\n        for lap in range(numLaps+1):\\n            for run in range(min(lap,maxi+1)):\\n                minTime[lap] = min(minTime[lap],minTime[lap-run]+changeTime+minTime[run])\\n        return minTime[numLaps]\\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: You are given a string s consisting only of lowercase English letters. In one move, you can select any two adjacent characters of s and swap them. Return the minimum number of moves needed to make s a palindrome. Note that the input will be generated such that s can always be converted to a palindrome. Example 1: Input: s = \"aabb\" Output: 2 Explanation: We can obtain two palindromes from s, \"abba\" and \"baab\". - We can obtain \"abba\" from s in 2 moves: \"aabb\" -> \"abab\" -> \"abba\". - We can obtain \"baab\" from s in 2 moves: \"aabb\" -> \"abab\" -> \"baab\". Thus, the minimum number of moves needed to make s a palindrome is 2. Example 2: Input: s = \"letelt\" Output: 2 Explanation: One of the palindromes we can obtain from s in 2 moves is \"lettel\". One of the ways we can obtain it is \"letelt\" -> \"letetl\" -> \"lettel\". Other palindromes such as \"tleelt\" can also be obtained in 2 moves. It can be shown that it is not possible to obtain a palindrome in less than 2 moves. Constraints: 1 <= s.length <= 2000 s consists only of lowercase English letters. s can be converted to a palindrome using a finite number of moves."}, {"role": "assistant", "content": "class Solution:\\n\\t\\tdef minMovesToMakePalindrome(self, s: str) -> int:\\n\\t\\t\\ts = list(s) #makes it easy for assignment op\\n\\n\\t\\t\\tres = 0\\n\\t\\t\\tleft, right = 0, len(s) - 1\\n\\n\\t\\t\\twhile left < right:\\n\\t\\t\\t\\tl, r = left, right\\n\\n\\t\\t\\t\\t#find matching char\\n\\t\\t\\t\\twhile s[l] != s[r]:\\n\\t\\t\\t\\t\\tr -= 1\\n\\n\\t\\t\\t\\t# if index dont match then swap\\n\\t\\t\\t\\tif l != r:\\n\\t\\t\\t\\t\\t# swap one by one\\n\\t\\t\\t\\t\\twhile r < right:\\n\\t\\t\\t\\t\\t\\ts[r], s[r + 1] = s[r + 1], s[r]\\n\\t\\t\\t\\t\\t\\tres += 1\\n\\t\\t\\t\\t\\t\\tr += 1\\n\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\ts[r], s[r + 1] = s[r + 1], s[r]\\n\\t\\t\\t\\t\\tres += 1\\n\\t\\t\\t\\t\\tcontinue # get outside the main while loop\\n\\n\\t\\t\\t\\tleft += 1\\n\\t\\t\\t\\tright -= 1\\n\\n\\t\\t\\treturn res"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: You are given an array of integers nums. Perform the following steps: Find any two adjacent numbers in nums that are non-coprime. If no such numbers are found, stop the process. Otherwise, delete the two numbers and replace them with their LCM (Least Common Multiple). Repeat this process as long as you keep finding two adjacent non-coprime numbers. Return the final modified array. It can be shown that replacing adjacent non-coprime numbers in any arbitrary order will lead to the same result. The test cases are generated such that the values in the final array are less than or equal to 108. Two values x and y are non-coprime if GCD(x, y) > 1 where GCD(x, y) is the Greatest Common Divisor of x and y. Example 1: Input: nums = [6,4,3,2,7,6,2] Output: [12,7,6] Explanation: - (6, 4) are non-coprime with LCM(6, 4) = 12. Now, nums = [12,3,2,7,6,2]. - (12, 3) are non-coprime with LCM(12, 3) = 12. Now, nums = [12,2,7,6,2]. - (12, 2) are non-coprime with LCM(12, 2) = 12. Now, nums = [12,7,6,2]. - (6, 2) are non-coprime with LCM(6, 2) = 6. Now, nums = [12,7,6]. There are no more adjacent non-coprime numbers in nums. Thus, the final modified array is [12,7,6]. Note that there are other ways to obtain the same resultant array. Example 2: Input: nums = [2,2,1,1,3,3,3] Output: [2,1,1,3] Explanation: - (3, 3) are non-coprime with LCM(3, 3) = 3. Now, nums = [2,2,1,1,3,3]. - (3, 3) are non-coprime with LCM(3, 3) = 3. Now, nums = [2,2,1,1,3]. - (2, 2) are non-coprime with LCM(2, 2) = 2. Now, nums = [2,1,1,3]. There are no more adjacent non-coprime numbers in nums. Thus, the final modified array is [2,1,1,3]. Note that there are other ways to obtain the same resultant array. Constraints: 1 <= nums.length <= 105 1 <= nums[i] <= 105 The test cases are generated such that the values in the final array are less than or equal to 108."}, {"role": "assistant", "content": "class Solution:\\n    def replaceNonCoprimes(self, nums: List[int]) -> List[int]:\\n        stack = []\\n        for i in nums:\\n            toBeAppended = i\\n            while stack and gcd(stack[-1], toBeAppended) > 1:\\n                toBeAppended = lcm(toBeAppended, stack.pop())\\n            stack.append(toBeAppended)\\n        return stack        \\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: You are given an integer n denoting the number of nodes of a weighted directed graph. The nodes are numbered from 0 to n - 1. You are also given a 2D integer array edges where edges[i] = [fromi, toi, weighti] denotes that there exists a directed edge from fromi to toi with weight weighti. Lastly, you are given three distinct integers src1, src2, and dest denoting three distinct nodes of the graph. Return the minimum weight of a subgraph of the graph such that it is possible to reach dest from both src1 and src2 via a set of edges of this subgraph. In case such a subgraph does not exist, return -1. A subgraph is a graph whose vertices and edges are subsets of the original graph. The weight of a subgraph is the sum of weights of its constituent edges. Example 1: Input: n = 6, edges = [[0,2,2],[0,5,6],[1,0,3],[1,4,5],[2,1,1],[2,3,3],[2,3,4],[3,4,2],[4,5,1]], src1 = 0, src2 = 1, dest = 5 Output: 9 Explanation: The above figure represents the input graph. The blue edges represent one of the subgraphs that yield the optimal answer. Note that the subgraph [[1,0,3],[0,5,6]] also yields the optimal answer. It is not possible to get a subgraph with less weight satisfying all the constraints. Example 2: Input: n = 3, edges = [[0,1,1],[2,1,1]], src1 = 0, src2 = 1, dest = 2 Output: -1 Explanation: The above figure represents the input graph. It can be seen that there does not exist any path from node 1 to node 2, hence there are no subgraphs satisfying all the constraints. Constraints: 3 <= n <= 105 0 <= edges.length <= 105 edges[i].length == 3 0 <= fromi, toi, src1, src2, dest <= n - 1 fromi != toi src1, src2, and dest are pairwise distinct. 1 <= weight[i] <= 105"}, {"role": "assistant", "content": "class Solution:\\n    def minimumWeight(self, n: int, edges: List[List[int]], src1: int, src2: int, dest: int) -> int:\\n        g1 = collections.defaultdict(list)\\n        g2 = collections.defaultdict(list)\\n        for u, v , w in edges:\\n            g1[u].append((v, w))\\n            g2[v].append((u, w))\\n\\n        def get_distance(node: int, g: dict) -> List[float | int]:\\n            distance = [float(\\'inf\\') for _ in range(n)]\\n            distance[node] = 0\\n            q = [(0, node)]\\n            while q:\\n                d, u = heapq.heappop(q)\\n                if d > distance[u]: continue\\n                for v, w in g[u]:\\n                    if d + w < distance[v]:\\n                        distance[v] = d + w\\n                        heapq.heappush(q, (distance[v], v))\\n            return distance\\n        \\n        l1, l2, l3 = get_distance(src1, g1), get_distance(src2, g1), get_distance(dest, g2)\\n        ans = float(\"inf\")\\n        for i in range(n):\\n            ans = min(ans, l1[i] + l2[i] + l3[i])\\n        \\n        return ans if ans != float(\"inf\") else -1\\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: You are given a 0-indexed binary string floor, which represents the colors of tiles on a floor: floor[i] = '0' denotes that the ith tile of the floor is colored black. On the other hand, floor[i] = '1' denotes that the ith tile of the floor is colored white. You are also given numCarpets and carpetLen. You have numCarpets black carpets, each of length carpetLen tiles. Cover the tiles with the given carpets such that the number of white tiles still visible is minimum. Carpets may overlap one another. Return the minimum number of white tiles still visible. Example 1: Input: floor = \"10110101\", numCarpets = 2, carpetLen = 2 Output: 2 Explanation: The figure above shows one way of covering the tiles with the carpets such that only 2 white tiles are visible. No other way of covering the tiles with the carpets can leave less than 2 white tiles visible. Example 2: Input: floor = \"11111\", numCarpets = 2, carpetLen = 3 Output: 0 Explanation: The figure above shows one way of covering the tiles with the carpets such that no white tiles are visible. Note that the carpets are able to overlap one another. Constraints: 1 <= carpetLen <= floor.length <= 1000 floor[i] is either '0' or '1'. 1 <= numCarpets <= 1000"}, {"role": "assistant", "content": "class Solution:\\n    def minimumWhiteTiles(self, floor: str, numCarpets: int, carpetLen: int) -> int:\\n        \\n        @cache\\n        def fn(i, n):\\n            \"\"\"Return min while tiles at k with n carpets left.\"\"\"\\n            if n < 0: return inf \\n            if i >= len(floor): return 0 \\n            if floor[i] == \\'1\\': return min(fn(i+carpetLen, n-1), 1 + fn(i+1, n))\\n            return fn(i+1, n)\\n        \\n        return fn(0, numCarpets)\\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: You are given a 0-indexed string s. You are also given a 0-indexed string queryCharacters of length k and a 0-indexed array of integer indices queryIndices of length k, both of which are used to describe k queries. The ith query updates the character in s at index queryIndices[i] to the character queryCharacters[i]. Return an array lengths of length k where lengths[i] is the length of the longest substring of s consisting of only one repeating character after the ith query is performed. Example 1: Input: s = \"babacc\", queryCharacters = \"bcb\", queryIndices = [1,3,3] Output: [3,3,4] Explanation: - 1st query updates s = \"bbbacc\". The longest substring consisting of one repeating character is \"bbb\" with length 3. - 2nd query updates s = \"bbbccc\". The longest substring consisting of one repeating character can be \"bbb\" or \"ccc\" with length 3. - 3rd query updates s = \"bbbbcc\". The longest substring consisting of one repeating character is \"bbbb\" with length 4. Thus, we return [3,3,4]. Example 2: Input: s = \"abyzz\", queryCharacters = \"aa\", queryIndices = [2,1] Output: [2,3] Explanation: - 1st query updates s = \"abazz\". The longest substring consisting of one repeating character is \"zz\" with length 2. - 2nd query updates s = \"aaazz\". The longest substring consisting of one repeating character is \"aaa\" with length 3. Thus, we return [2,3]. Constraints: 1 <= s.length <= 105 s consists of lowercase English letters. k == queryCharacters.length == queryIndices.length 1 <= k <= 105 queryCharacters consists of lowercase English letters. 0 <= queryIndices[i] < s.length"}, {"role": "assistant", "content": "class Solution:\\n    def longestRepeating(self, s: str, queryCharacters: str, queryIndices: List[int]) -> List[int]:\\n        \\n        s = list(s)\\n        loc = defaultdict(lambda: SortedList()) # segment offsets (start, end) stored by character\\n        max_len = SortedList() # segment length stored by character\\n\\n        i = 0\\n        while i < len(s):\\n            j = i\\n            while j < len(s) and s[i] == s[j]:\\n                j += 1\\n            loc[s[i]].add((i, j-1))\\n            max_len.add(j - i)\\n            i = j\\n            \\n        # helper function to remove segment\\n        def del_seg(w, old_l, old_r):\\n            loc[w].remove((old_l, old_r))\\n            max_len.remove(old_r - old_l + 1)\\n        \\n        # helper function to add segment\\n        def add_seg(w, new_l, new_r):\\n            loc[w].add((new_l, new_r))\\n            max_len.add(new_r - new_l + 1)\\n\\n        ans = [0] * len(queryIndices)\\n        for k in range(len(queryIndices)):\\n            old, new = s[queryIndices[k]], queryCharacters[k]\\n            s[queryIndices[k]] = new\\n            pos = (queryIndices[k], queryIndices[k])\\n\\n            # old segment delete\\n            if pos in loc[old]:\\n                del_seg(old, *pos)\\n            else:\\n                l1 = bisect.bisect_left(loc[old], pos)\\n                if l1 == 0:\\n                    old_pos = loc[old][l1]\\n                    l, r = old_pos\\n                    del_seg(old, *old_pos)\\n                    add_seg(old, l + 1, r)\\n                elif l1 == len(loc[old]):\\n                    old_pos = loc[old][l1-1]\\n                    l, r = old_pos\\n                    del_seg(old, *old_pos)\\n                    if pos[0] == r:\\n                        add_seg(old, l, r-1)\\n                    else:\\n                        add_seg(old, l, pos[0]-1)\\n                        add_seg(old, pos[0] + 1, r)\\n                else:\\n                    a, b = loc[old][l1 - 1]\\n                    c, d = loc[old][l1]\\n                    if pos[0] == b:\\n                        del_seg(old, a, b)\\n                        add_seg(old, a, b-1)\\n                    elif pos[0] == c:\\n                        del_seg(old, c, d)\\n                        add_seg(old, c+1, d)\\n                    elif pos[0] < b:\\n                        del_seg(old, a, b)\\n                        add_seg(old, a, pos[0]-1)\\n                        add_seg(old, pos[0]+1, b)\\n                    elif pos[0] > c:\\n                        del_seg(old, c, d)\\n                        add_seg(old, c, pos[0]-1)\\n                        add_seg(old, pos[0]+1, d)\\n\\n            # new segment insert\\n            if not loc[new]:\\n                add_seg(new, *pos)\\n                ans[k] = max_len[-1]\\n                continue\\n            l2 = bisect.bisect_left(loc[new], pos)\\n            if l2 == 0:\\n                l, r = loc[new][l2]\\n                if l - pos[0] > 1:\\n                    add_seg(new, *pos)\\n                else:\\n                    del_seg(new, l, r)\\n                    add_seg(new, pos[0], r)\\n\\n            elif l2 == len(loc[new]):\\n                l, r = loc[new][l2 - 1]\\n                if pos[0] - r > 1:\\n                    add_seg(new, *pos)\\n                else:\\n                    del_seg(new, l, r)\\n                    add_seg(new, l, pos[0])\\n            else:\\n                a, b = loc[new][l2 - 1]\\n                c, d = loc[new][l2]\\n                if pos[0] - b == 1 and c - pos[0] == 1:\\n                    del_seg(new, a, b)\\n                    del_seg(new, c, d)\\n                    add_seg(new, a, d)\\n                elif pos[0] - b == 1:\\n                    del_seg(new, a, b)\\n                    add_seg(new, a, pos[0])\\n                elif c - pos[0] == 1:\\n                    del_seg(new, c, d)\\n                    add_seg(new, pos[0], d)\\n                else:\\n                    add_seg(new, *pos)\\n            ans[k] = max_len[-1]\\n        return ans\\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: There are n piles of coins on a table. Each pile consists of a positive number of coins of assorted denominations. In one move, you can choose any coin on top of any pile, remove it, and add it to your wallet. Given a list piles, where piles[i] is a list of integers denoting the composition of the ith pile from top to bottom, and a positive integer k, return the maximum total value of coins you can have in your wallet if you choose exactly k coins optimally. Example 1: Input: piles = [[1,100,3],[7,8,9]], k = 2 Output: 101 Explanation: The above diagram shows the different ways we can choose k coins. The maximum total we can obtain is 101. Example 2: Input: piles = [[100],[100],[100],[100],[100],[100],[1,1,1,1,1,1,700]], k = 7 Output: 706 Explanation: The maximum total can be obtained if we choose all coins from the last pile. Constraints: n == piles.length 1 <= n <= 1000 1 <= piles[i][j] <= 105 1 <= k <= sum(piles[i].length) <= 2000"}, {"role": "assistant", "content": "class Solution:\\n    def maxValueOfCoins(self, piles: List[List[int]], k: int) -> int:\\n        \\n        @functools.lru_cache(None)\\n        def _search(rest_k: int, pile_pos: int) -> int:\\n            \"\"\"Searches for best accumulated coin value starting from pile at position `pile_pos`.\\n            \\n            Args:\\n              - rest_k: The rest of coins we could pick.\\n              - pile_pos: The starting position of pile we are working on.\\n            \"\"\"\\n            if rest_k == 0 or pile_pos == len(piles): return 0\\n\\n            # Ignore the current pile and moving to next pile\\n            current_mv_found = _search(rest_k, pile_pos+1)\\n\\n            # Start looking solution with current pile being involved\\n            current_pile = piles[pile_pos]\\n            accum_coin_value = 0\\n            for i in range(min(rest_k, len(current_pile))):\\n                # Accumulate the coins\\n                accum_coin_value += current_pile[i]\\n\\n                # Moving to next pile with accumulated coin value in current pile\\n                current_mv_found = max(\\n                    current_mv_found, \\n                    accum_coin_value + _search(rest_k-i-1, pile_pos+1))\\n\\n            # Return the maximum accumulated coin value found from current pile.\\n            return current_mv_found\\n\\n        # Start searching with initial `k` and first pile\\n        return _search(k, 0)\\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: You are building a string s of length n one character at a time, prepending each new character to the front of the string. The strings are labeled from 1 to n, where the string with length i is labeled si. For example, for s = \"abaca\", s1 == \"a\", s2 == \"ca\", s3 == \"aca\", etc. The score of si is the length of the longest common prefix between si and sn (Note that s == sn). Given the final string s, return the sum of the score of every si. Example 1: Input: s = \"babab\" Output: 9 Explanation: For s1 == \"b\", the longest common prefix is \"b\" which has a score of 1. For s2 == \"ab\", there is no common prefix so the score is 0. For s3 == \"bab\", the longest common prefix is \"bab\" which has a score of 3. For s4 == \"abab\", there is no common prefix so the score is 0. For s5 == \"babab\", the longest common prefix is \"babab\" which has a score of 5. The sum of the scores is 1 + 0 + 3 + 0 + 5 = 9, so we return 9. Example 2: Input: s = \"azbazbzaz\" Output: 14 Explanation: For s2 == \"az\", the longest common prefix is \"az\" which has a score of 2. For s6 == \"azbzaz\", the longest common prefix is \"azb\" which has a score of 3. For s9 == \"azbazbzaz\", the longest common prefix is \"azbazbzaz\" which has a score of 9. For all other si, the score is 0. The sum of the scores is 2 + 3 + 9 = 14, so we return 14. Constraints: 1 <= s.length <= 105 s consists of lowercase English letters."}, {"role": "assistant", "content": "class Solution:\\n    def sumScores(self, s: str) -> int:\\n        mod = 119_218_851_371\\n        hs = 0 \\n        vals = [0]\\n        for i, ch in enumerate(s): \\n            hs = (hs * 26 + ord(ch) - 97) % mod\\n            vals.append(hs)\\n        \\n        p26 = [1]\\n        for _ in range(len(s)): p26.append(p26[-1] * 26 % mod)\\n        \\n        ans = 0 \\n        for i in range(len(s)): \\n            if s[0] == s[i]: \\n                lo, hi = i, len(s)\\n                while lo < hi: \\n                    mid = lo + hi + 1 >> 1\\n                    hs = (vals[mid] - vals[i]*p26[mid-i]) % mod\\n                    if hs == vals[mid-i]: lo = mid\\n                    else: hi = mid - 1\\n                ans += lo - i \\n        return ans \\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: You are given a floating-point number hour, representing the amount of time you have to reach the office. To commute to the office, you must take n trains in sequential order. You are also given an integer array dist of length n, where dist[i] describes the distance (in kilometers) of the ith train ride. Each train can only depart at an integer hour, so you may need to wait in between each train ride. For example, if the 1st train ride takes 1.5 hours, you must wait for an additional 0.5 hours before you can depart on the 2nd train ride at the 2 hour mark. Return the minimum positive integer speed (in kilometers per hour) that all the trains must travel at for you to reach the office on time, or -1 if it is impossible to be on time. Tests are generated such that the answer will not exceed 107 and hour will have at most two digits after the decimal point. Example 1: Input: dist = [1,3,2], hour = 6 Output: 1 Explanation: At speed 1: - The first train ride takes 1/1 = 1 hour. - Since we are already at an integer hour, we depart immediately at the 1 hour mark. The second train takes 3/1 = 3 hours. - Since we are already at an integer hour, we depart immediately at the 4 hour mark. The third train takes 2/1 = 2 hours. - You will arrive at exactly the 6 hour mark. Example 2: Input: dist = [1,3,2], hour = 2.7 Output: 3 Explanation: At speed 3: - The first train ride takes 1/3 = 0.33333 hours. - Since we are not at an integer hour, we wait until the 1 hour mark to depart. The second train ride takes 3/3 = 1 hour. - Since we are already at an integer hour, we depart immediately at the 2 hour mark. The third train takes 2/3 = 0.66667 hours. - You will arrive at the 2.66667 hour mark. Example 3: Input: dist = [1,3,2], hour = 1.9 Output: -1 Explanation: It is impossible because the earliest the third train can depart is at the 2 hour mark. Constraints: n == dist.length 1 <= n <= 105 1 <= dist[i] <= 105 1 <= hour <= 109 There will be at most two digits after the decimal point in hour."}, {"role": "assistant", "content": "class Solution:\\n    def minSpeedOnTime(self, dist, hour):\\n        n = len(dist)  # Get the size of the input list \\'dist\\' (number of distances to travel)\\n        minSpeed, maxSpeed = 1, 10**7 + 1  # Initialize the minimum and maximum possible speeds\\n        answer = -1  # Initialize the variable to store the final answer\\n\\n        while minSpeed < maxSpeed:  # Binary search loop to find the minimum required speed\\n            midSpeed = minSpeed + (maxSpeed - minSpeed) // 2  # Calculate the middle speed\\n\\n            totalHours = 0.0  # Initialize total travel time to 0\\n\\n            # Calculate the total hours required to travel each distance at the current middle speed\\n            for i in range(n - 1):\\n                # Add the time taken to travel distance at index i using current midSpeed to totalHours\\n                totalHours += (dist[i] + midSpeed - 1) // midSpeed\\n\\n            # Add the time taken to travel the last distance using current midSpeed to totalHours\\n            totalHours += dist[n - 1] / midSpeed\\n\\n            if totalHours > hour:\\n                # If the total hours exceed the given hour, update minSpeed to consider higher speeds\\n                minSpeed = midSpeed + 1\\n            else:\\n                # If the total hours are within the given hour, update the answer to the current speed\\n                # and search for a potentially smaller speed in the lower half of the range.\\n                answer = midSpeed\\n                maxSpeed = midSpeed\\n\\n        return answer  # Return the minimum speed required to reach the destination on time\\n\\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: The pair sum of a pair (a,b) is equal to a + b. The maximum pair sum is the largest pair sum in a list of pairs. For example, if we have pairs (1,5), (2,3), and (4,4), the maximum pair sum would be max(1+5, 2+3, 4+4) = max(6, 5, 8) = 8. Given an array nums of even length n, pair up the elements of nums into n / 2 pairs such that: Each element of nums is in exactly one pair, and The maximum pair sum is minimized. Return the minimized maximum pair sum after optimally pairing up the elements. Example 1: Input: nums = [3,5,2,3] Output: 7 Explanation: The elements can be paired up into pairs (3,3) and (5,2). The maximum pair sum is max(3+3, 5+2) = max(6, 7) = 7. Example 2: Input: nums = [3,5,4,2,4,6] Output: 8 Explanation: The elements can be paired up into pairs (3,5), (4,4), and (6,2). The maximum pair sum is max(3+5, 4+4, 6+2) = max(8, 8, 8) = 8. Constraints: n == nums.length 2 <= n <= 105 n is even. 1 <= nums[i] <= 105"}, {"role": "assistant", "content": "class Solution:\\n    def minPairSum(self, nums: List[int]) -> int:\\n        nums.sort()\\n\\n        n = len(nums)\\n        min_max_sum = 0\\n\\n        for i in range(n // 2):\\n            min_max_sum = max(min_max_sum, nums[i] + nums[n - 1 - i])\\n\\n        return min_max_sum        \\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: You are given an m x n integer matrix grid\u200b\u200b\u200b. A rhombus sum is the sum of the elements that form the border of a regular rhombus shape in grid\u200b\u200b\u200b. The rhombus must have the shape of a square rotated 45 degrees with each of the corners centered in a grid cell. Below is an image of four valid rhombus shapes with the corresponding colored cells that should be included in each rhombus sum: Note that the rhombus can have an area of 0, which is depicted by the purple rhombus in the bottom right corner. Return the biggest three distinct rhombus sums in the grid in descending order. If there are less than three distinct values, return all of them. Example 1: Input: grid = [[3,4,5,1,3],[3,3,4,2,3],[20,30,200,40,10],[1,5,5,4,1],[4,3,2,2,5]] Output: [228,216,211] Explanation: The rhombus shapes for the three biggest distinct rhombus sums are depicted above. - Blue: 20 + 3 + 200 + 5 = 228 - Red: 200 + 2 + 10 + 4 = 216 - Green: 5 + 200 + 4 + 2 = 211 Example 2: Input: grid = [[1,2,3],[4,5,6],[7,8,9]] Output: [20,9,8] Explanation: The rhombus shapes for the three biggest distinct rhombus sums are depicted above. - Blue: 4 + 2 + 6 + 8 = 20 - Red: 9 (area 0 rhombus in the bottom right corner) - Green: 8 (area 0 rhombus in the bottom middle) Example 3: Input: grid = [[7,7,7]] Output: [7] Explanation: All three possible rhombus sums are the same, so return [7]. Constraints: m == grid.length n == grid[i].length 1 <= m, n <= 50 1 <= grid[i][j] <= 105"}, {"role": "assistant", "content": "class Solution:\\n    def getBiggestThree(self, grid: List[List[int]]) -> List[int]:\\n        \\n        def calc(l,r,u,d):\\n            sc=0\\n            c1=c2=(l+r)//2\\n            expand=True\\n            for row in range(u,d+1):\\n                if c1==c2:\\n                    sc+=grid[row][c1]\\n                else:\\n                    sc+=grid[row][c1]+grid[row][c2]\\n                \\n                if c1==l:\\n                    expand=False\\n                \\n                if expand:\\n                    c1-=1\\n                    c2+=1\\n                else:\\n                    c1+=1\\n                    c2-=1\\n            return sc\\n            \\n        \\n        m=len(grid)\\n        n=len(grid[0])\\n        heap=[]\\n        for i in range(m):\\n            for j in range(n):\\n                l=r=j\\n                d=i\\n                while l>=0 and r<=n-1 and d<=m-1:\\n                    sc=calc(l,r,i,d)\\n                    l-=1\\n                    r+=1\\n                    d+=2\\n                    if len(heap)<3:\\n                        if sc not in heap:\\n                            heapq.heappush(heap,sc)\\n                    else:\\n                        if sc not in heap and sc>heap[0]:\\n                            heapq.heappop(heap)\\n                            heapq.heappush(heap,sc)\\n        \\n        heap.sort(reverse=True)\\n        return heap\\n\\nThank You\\nif you liked please **Upvote** !!"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: You are given two 0-indexed integer arrays servers and tasks of lengths n\u200b\u200b\u200b\u200b\u200b\u200b and m\u200b\u200b\u200b\u200b\u200b\u200b respectively. servers[i] is the weight of the i\u200b\u200b\u200b\u200b\u200b\u200bth\u200b\u200b\u200b\u200b server, and tasks[j] is the time needed to process the j\u200b\u200b\u200b\u200b\u200b\u200bth\u200b\u200b\u200b\u200b task in seconds. Tasks are assigned to the servers using a task queue. Initially, all servers are free, and the queue is empty. At second j, the jth task is inserted into the queue (starting with the 0th task being inserted at second 0). As long as there are free servers and the queue is not empty, the task in the front of the queue will be assigned to a free server with the smallest weight, and in case of a tie, it is assigned to a free server with the smallest index. If there are no free servers and the queue is not empty, we wait until a server becomes free and immediately assign the next task. If multiple servers become free at the same time, then multiple tasks from the queue will be assigned in order of insertion following the weight and index priorities above. A server that is assigned task j at second t will be free again at second t + tasks[j]. Build an array ans\u200b\u200b\u200b\u200b of length m, where ans[j] is the index of the server the j\u200b\u200b\u200b\u200b\u200b\u200bth task will be assigned to. Return the array ans\u200b\u200b\u200b\u200b. Example 1: Input: servers = [3,3,2], tasks = [1,2,3,2,1,2] Output: [2,2,0,2,1,2] Explanation: Events in chronological order go as follows: - At second 0, task 0 is added and processed using server 2 until second 1. - At second 1, server 2 becomes free. Task 1 is added and processed using server 2 until second 3. - At second 2, task 2 is added and processed using server 0 until second 5. - At second 3, server 2 becomes free. Task 3 is added and processed using server 2 until second 5. - At second 4, task 4 is added and processed using server 1 until second 5. - At second 5, all servers become free. Task 5 is added and processed using server 2 until second 7. Example 2: Input: servers = [5,1,4,3,2], tasks = [2,1,2,4,5,2,1] Output: [1,4,1,4,1,3,2] Explanation: Events in chronological order go as follows: - At second 0, task 0 is added and processed using server 1 until second 2. - At second 1, task 1 is added and processed using server 4 until second 2. - At second 2, servers 1 and 4 become free. Task 2 is added and processed using server 1 until second 4. - At second 3, task 3 is added and processed using server 4 until second 7. - At second 4, server 1 becomes free. Task 4 is added and processed using server 1 until second 9. - At second 5, task 5 is added and processed using server 3 until second 7. - At second 6, task 6 is added and processed using server 2 until second 7. Constraints: servers.length == n tasks.length == m 1 <= n, m <= 2 * 105 1 <= servers[i], tasks[j] <= 2 * 105"}, {"role": "assistant", "content": "class Solution:\\n    def assignTasks(self, servers: List[int], tasks: List[int]) -> List[int]:\\n        res, unavailable, time = [], [], 0\\n        available = [(weight, id) for id, weight in enumerate(servers)]\\n        heapify(available)\\n\\n        for task in tasks:\\n            while unavailable and unavailable[0][0] == time:\\n                _, weight, id = heappop(unavailable)\\n                heappush(available, (weight, id))\\n\\n            if len(available) > 0:\\n                weight, id = heappop(available)\\n                heappush(unavailable, (time + task, weight, id))\\n                res.append(id)\\n            else:\\n                finishTime, weight, id = heappop(unavailable)\\n                heappush(unavailable, (finishTime + task, weight, id))\\n                res.append(id)\\n            time +=1\\n\\n        return res\\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: You are given two identical eggs and you have access to a building with n floors labeled from 1 to n. You know that there exists a floor f where 0 <= f <= n such that any egg dropped at a floor higher than f will break, and any egg dropped at or below floor f will not break. In each move, you may take an unbroken egg and drop it from any floor x (where 1 <= x <= n). If the egg breaks, you can no longer use it. However, if the egg does not break, you may reuse it in future moves. Return the minimum number of moves that you need to determine with certainty what the value of f is. Example 1: Input: n = 2 Output: 2 Explanation: We can drop the first egg from floor 1 and the second egg from floor 2. If the first egg breaks, we know that f = 0. If the second egg breaks but the first egg didn't, we know that f = 1. Otherwise, if both eggs survive, we know that f = 2. Example 2: Input: n = 100 Output: 14 Explanation: One optimal strategy is: - Drop the 1st egg at floor 9. If it breaks, we know f is between 0 and 8. Drop the 2nd egg starting from floor 1 and going up one at a time to find f within 8 more drops. Total drops is 1 + 8 = 9. - If the 1st egg does not break, drop the 1st egg again at floor 22. If it breaks, we know f is between 9 and 21. Drop the 2nd egg starting from floor 10 and going up one at a time to find f within 12 more drops. Total drops is 2 + 12 = 14. - If the 1st egg does not break again, follow a similar process dropping the 1st egg from floors 34, 45, 55, 64, 72, 79, 85, 90, 94, 97, 99, and 100. Regardless of the outcome, it takes at most 14 drops to determine f. Constraints: 1 <= n <= 1000"}, {"role": "assistant", "content": "class Solution:\\n    @cache\\n    def twoEggDrop(self, n: int) -> int:\\n        return min((1 + max(i - 1, self.twoEggDrop(n - i)) for i in range (1, n)), default = 1)\\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: Given an integer array nums, your goal is to make all elements in nums equal. To complete one operation, follow these steps: Find the largest value in nums. Let its index be i (0-indexed) and its value be largest. If there are multiple elements with the largest value, pick the smallest i. Find the next largest value in nums strictly smaller than largest. Let its value be nextLargest. Reduce nums[i] to nextLargest. Return the number of operations to make all elements in nums equal. Example 1: Input: nums = [5,1,3] Output: 3 Explanation: It takes 3 operations to make all elements in nums equal: 1. largest = 5 at index 0. nextLargest = 3. Reduce nums[0] to 3. nums = [3,1,3]. 2. largest = 3 at index 0. nextLargest = 1. Reduce nums[0] to 1. nums = [1,1,3]. 3. largest = 3 at index 2. nextLargest = 1. Reduce nums[2] to 1. nums = [1,1,1]. Example 2: Input: nums = [1,1,1] Output: 0 Explanation: All elements in nums are already equal. Example 3: Input: nums = [1,1,2,2,3] Output: 4 Explanation: It takes 4 operations to make all elements in nums equal: 1. largest = 3 at index 4. nextLargest = 2. Reduce nums[4] to 2. nums = [1,1,2,2,2]. 2. largest = 2 at index 2. nextLargest = 1. Reduce nums[2] to 1. nums = [1,1,1,2,2]. 3. largest = 2 at index 3. nextLargest = 1. Reduce nums[3] to 1. nums = [1,1,1,1,2]. 4. largest = 2 at index 4. nextLargest = 1. Reduce nums[4] to 1. nums = [1,1,1,1,1]. Constraints: 1 <= nums.length <= 5 * 104 1 <= nums[i] <= 5 * 104"}, {"role": "assistant", "content": "class Solution:\\n    def reductionOperations(self, nums: List[int]) -> int:\\n        ans = val = 0\\n        nums.sort()\\n        for i in range(1, len(nums)): \\n            if nums[i-1] < nums[i]: val += 1\\n            ans += val\\n        return ans \\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: You are given a binary string s. You are allowed to perform two types of operations on the string in any sequence: Type-1: Remove the character at the start of the string s and append it to the end of the string. Type-2: Pick any character in s and flip its value, i.e., if its value is '0' it becomes '1' and vice-versa. Return the minimum number of type-2 operations you need to perform such that s becomes alternating. The string is called alternating if no two adjacent characters are equal. For example, the strings \"010\" and \"1010\" are alternating, while the string \"0100\" is not. Example 1: Input: s = \"111000\" Output: 2 Explanation: Use the first operation two times to make s = \"100011\". Then, use the second operation on the third and sixth elements to make s = \"101010\". Example 2: Input: s = \"010\" Output: 0 Explanation: The string is already alternating. Example 3: Input: s = \"1110\" Output: 1 Explanation: Use the second operation on the second element to make s = \"1010\". Constraints: 1 <= s.length <= 105 s[i] is either '0' or '1'."}, {"role": "assistant", "content": "class Solution:\\n    def minFlips(self, s: str) -> int:\\n        prev = 0\\n        start_1, start_0, start_1_odd, start_0_odd = 0,0,sys.maxsize,sys.maxsize\\n        odd = len(s)%2\\n        for val in s:\\n            val = int(val)\\n            if val == prev:\\n                if odd:\\n                    start_0_odd = min(start_0_odd, start_1)\\n                    start_1_odd += 1\\n                start_1 += 1\\n            else:\\n                if odd:\\n                    start_1_odd = min(start_1_odd, start_0)\\n                    start_0_odd += 1\\n                start_0 += 1\\n            prev = 1 - prev\\n        return min([start_1, start_0, start_1_odd, start_0_odd])\\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: There are n students in a class numbered from 0 to n - 1. The teacher will give each student a problem starting with the student number 0, then the student number 1, and so on until the teacher reaches the student number n - 1. After that, the teacher will restart the process, starting with the student number 0 again. You are given a 0-indexed integer array chalk and an integer k. There are initially k pieces of chalk. When the student number i is given a problem to solve, they will use chalk[i] pieces of chalk to solve that problem. However, if the current number of chalk pieces is strictly less than chalk[i], then the student number i will be asked to replace the chalk. Return the index of the student that will replace the chalk pieces. Example 1: Input: chalk = [5,1,5], k = 22 Output: 0 Explanation: The students go in turns as follows: - Student number 0 uses 5 chalk, so k = 17. - Student number 1 uses 1 chalk, so k = 16. - Student number 2 uses 5 chalk, so k = 11. - Student number 0 uses 5 chalk, so k = 6. - Student number 1 uses 1 chalk, so k = 5. - Student number 2 uses 5 chalk, so k = 0. Student number 0 does not have enough chalk, so they will have to replace it. Example 2: Input: chalk = [3,4,1,2], k = 25 Output: 1 Explanation: The students go in turns as follows: - Student number 0 uses 3 chalk so k = 22. - Student number 1 uses 4 chalk so k = 18. - Student number 2 uses 1 chalk so k = 17. - Student number 3 uses 2 chalk so k = 15. - Student number 0 uses 3 chalk so k = 12. - Student number 1 uses 4 chalk so k = 8. - Student number 2 uses 1 chalk so k = 7. - Student number 3 uses 2 chalk so k = 5. - Student number 0 uses 3 chalk so k = 2. Student number 1 does not have enough chalk, so they will have to replace it. Constraints: chalk.length == n 1 <= n <= 105 1 <= chalk[i] <= 105 1 <= k <= 109"}, {"role": "assistant", "content": "class Solution:\\n    def chalkReplacer(self, chalk: List[int], k: int) -> int:\\n        prefix_sum = [0 for i in range(len(chalk))]\\n        prefix_sum[0] = chalk[0]\\n        for i in range(1,len(chalk)):\\n            prefix_sum[i] = prefix_sum[i-1] + chalk[i]\\n        remainder = k % prefix_sum[-1]\\n        \\n        #apply binary search on prefix_sum array, target = remainder \\n        start = 0\\n        end = len(prefix_sum) - 1\\n        while start <= end:\\n            mid = start + (end - start) // 2\\n            if remainder == prefix_sum[mid]:\\n                return mid + 1\\n            elif remainder < prefix_sum[mid]:\\n                end = mid - 1\\n            else:\\n                start = mid + 1\\n        return start \\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: A k x k magic square is a k x k grid filled with integers such that every row sum, every column sum, and both diagonal sums are all equal. The integers in the magic square do not have to be distinct. Every 1 x 1 grid is trivially a magic square. Given an m x n integer grid, return the size (i.e., the side length k) of the largest magic square that can be found within this grid. Example 1: Input: grid = [[7,1,4,5,6],[2,5,1,6,4],[1,5,4,3,2],[1,2,7,3,4]] Output: 3 Explanation: The largest magic square has a size of 3. Every row sum, column sum, and diagonal sum of this magic square is equal to 12. - Row sums: 5+1+6 = 5+4+3 = 2+7+3 = 12 - Column sums: 5+5+2 = 1+4+7 = 6+3+3 = 12 - Diagonal sums: 5+4+3 = 6+4+2 = 12 Example 2: Input: grid = [[5,1,3,1],[9,3,3,1],[1,3,3,8]] Output: 2 Constraints: m == grid.length n == grid[i].length 1 <= m, n <= 50 1 <= grid[i][j] <= 106"}, {"role": "assistant", "content": "class Solution:\\n    def largestMagicSquare(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0]) # dimensions \\n        rows = [[0]*(n+1) for _ in range(m)] # prefix sum along row\\n        cols = [[0]*n for _ in range(m+1)] # prefix sum along column\\n        \\n        for i in range(m):\\n            for j in range(n): \\n                rows[i][j+1] = grid[i][j] + rows[i][j]\\n                cols[i+1][j] = grid[i][j] + cols[i][j]\\n        \\n        ans = 1\\n        for i in range(m): \\n            for j in range(n): \\n                diag = grid[i][j]\\n                for k in range(min(i, j)): \\n                    ii, jj = i-k-1, j-k-1\\n                    diag += grid[ii][jj]\\n                    ss = {diag}\\n                    for r in range(ii, i+1): ss.add(rows[r][j+1] - rows[r][jj])\\n                    for c in range(jj, j+1): ss.add(cols[i+1][c] - cols[ii][c])\\n                    ss.add(sum(grid[ii+kk][j-kk] for kk in range(k+2))) # anti-diagonal\\n                    if len(ss) == 1: ans = max(ans, k+2)\\n        return ans \\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: You are given two strings s and p where p is a subsequence of s. You are also given a distinct 0-indexed integer array removable containing a subset of indices of s (s is also 0-indexed). You want to choose an integer k (0 <= k <= removable.length) such that, after removing k characters from s using the first k indices in removable, p is still a subsequence of s. More formally, you will mark the character at s[removable[i]] for each 0 <= i < k, then remove all marked characters and check if p is still a subsequence. Return the maximum k you can choose such that p is still a subsequence of s after the removals. A subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters. Example 1: Input: s = \"abcacb\", p = \"ab\", removable = [3,1,0] Output: 2 Explanation: After removing the characters at indices 3 and 1, \"abcacb\" becomes \"accb\". \"ab\" is a subsequence of \"accb\". If we remove the characters at indices 3, 1, and 0, \"abcacb\" becomes \"ccb\", and \"ab\" is no longer a subsequence. Hence, the maximum k is 2. Example 2: Input: s = \"abcbddddd\", p = \"abcd\", removable = [3,2,1,4,5,6] Output: 1 Explanation: After removing the character at index 3, \"abcbddddd\" becomes \"abcddddd\". \"abcd\" is a subsequence of \"abcddddd\". Example 3: Input: s = \"abcab\", p = \"abc\", removable = [0,1,2,3,4] Output: 0 Explanation: If you remove the first index in the array removable, \"abc\" is no longer a subsequence. Constraints: 1 <= p.length <= s.length <= 105 0 <= removable.length < s.length 0 <= removable[i] < s.length p is a subsequence of s. s and p both consist of lowercase English letters. The elements in removable are distinct."}, {"role": "assistant", "content": "class Solution:\\n    def maximumRemovals(self, s: str, p: str, removable: List[int]) -> int:\\n        mp = {x: i for i, x in enumerate(removable)}\\n        \\n        def fn(x):\\n            \"\"\"Return True if p is a subseq of s after x removals.\"\"\"\\n            k = 0 \\n            for i, ch in enumerate(s): \\n                if mp.get(i, inf) < x: continue \\n                if k < len(p) and ch == p[k]: k += 1\\n            return k == len(p)\\n        \\n        lo, hi = -1, len(removable)\\n        while lo < hi: \\n            mid = lo + hi + 1 >> 1\\n            if fn(mid): lo = mid\\n            else: hi = mid - 1\\n        return lo \\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: A triplet is an array of three integers. You are given a 2D integer array triplets, where triplets[i] = [ai, bi, ci] describes the ith triplet. You are also given an integer array target = [x, y, z] that describes the triplet you want to obtain. To obtain target, you may apply the following operation on triplets any number of times (possibly zero): Choose two indices (0-indexed) i and j (i != j) and update triplets[j] to become [max(ai, aj), max(bi, bj), max(ci, cj)]. For example, if triplets[i] = [2, 5, 3] and triplets[j] = [1, 7, 5], triplets[j] will be updated to [max(2, 1), max(5, 7), max(3, 5)] = [2, 7, 5]. Return true if it is possible to obtain the target triplet [x, y, z] as an element of triplets, or false otherwise. Example 1: Input: triplets = [[2,5,3],[1,8,4],[1,7,5]], target = [2,7,5] Output: true Explanation: Perform the following operations: - Choose the first and last triplets [[2,5,3],[1,8,4],[1,7,5]]. Update the last triplet to be [max(2,1), max(5,7), max(3,5)] = [2,7,5]. triplets = [[2,5,3],[1,8,4],[2,7,5]] The target triplet [2,7,5] is now an element of triplets. Example 2: Input: triplets = [[3,4,5],[4,5,6]], target = [3,2,5] Output: false Explanation: It is impossible to have [3,2,5] as an element because there is no 2 in any of the triplets. Example 3: Input: triplets = [[2,5,3],[2,3,4],[1,2,5],[5,2,3]], target = [5,5,5] Output: true Explanation: Perform the following operations: - Choose the first and third triplets [[2,5,3],[2,3,4],[1,2,5],[5,2,3]]. Update the third triplet to be [max(2,1), max(5,2), max(3,5)] = [2,5,5]. triplets = [[2,5,3],[2,3,4],[2,5,5],[5,2,3]]. - Choose the third and fourth triplets [[2,5,3],[2,3,4],[2,5,5],[5,2,3]]. Update the fourth triplet to be [max(2,5), max(5,2), max(5,3)] = [5,5,5]. triplets = [[2,5,3],[2,3,4],[2,5,5],[5,5,5]]. The target triplet [5,5,5] is now an element of triplets. Constraints: 1 <= triplets.length <= 105 triplets[i].length == target.length == 3 1 <= ai, bi, ci, x, y, z <= 1000"}, {"role": "assistant", "content": "class Solution:\\n    def mergeTriplets(self, triplets: List[List[int]], target: List[int]) -> bool:\\n        \\n        a, b, c = 0, 0, 0\\n        for i, (x, y, z) in enumerate(triplets):\\n                if not(  x > target[0] or y > target[1] or z > target[2]):\\n                     a, b, c = max(a, x), max(b, y), max(c, z)\\n                        \\n        return [a, b, c] == target\\n            \\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: A peak element in a 2D grid is an element that is strictly greater than all of its adjacent neighbors to the left, right, top, and bottom. Given a 0-indexed m x n matrix mat where no two adjacent cells are equal, find any peak element mat[i][j] and return the length 2 array [i,j]. You may assume that the entire matrix is surrounded by an outer perimeter with the value -1 in each cell. You must write an algorithm that runs in O(m log(n)) or O(n log(m)) time. Example 1: Input: mat = [[1,4],[3,2]] Output: [0,1] Explanation: Both 3 and 4 are peak elements so [1,0] and [0,1] are both acceptable answers. Example 2: Input: mat = [[10,20,15],[21,30,14],[7,16,32]] Output: [1,1] Explanation: Both 30 and 32 are peak elements so [1,1] and [2,2] are both acceptable answers. Constraints: m == mat.length n == mat[i].length 1 <= m, n <= 500 1 <= mat[i][j] <= 105 No two adjacent cells are equal."}, {"role": "assistant", "content": "class Solution:\\n    def findPeakGrid(self, mat: List[List[int]]) -> List[int]:\\n        m, n = len(mat), len(mat[0])\\n        l, r = 0, n\\n        while l <= r:\\n            mid = (l + r) // 2\\n            cur_max, left = 0, False\\n            for i in range(m):\\n                if i > 0 and mat[i-1][mid] >= mat[i][mid]:\\n                    continue\\n                if i+1 < m and mat[i+1][mid] >= mat[i][mid]:   \\n                    continue\\n                if mid+1 < n and mat[i][mid+1] >= mat[i][mid]:   \\n                    cur_max, left = mat[i][mid], not mat[i][mid] > cur_max\\n                    continue\\n                if mid > 0 and mat[i][mid-1] >= mat[i][mid]:   \\n                    cur_max, left = mat[i][mid], mat[i][mid] > cur_max\\n                    continue\\n                return [i, mid]\\n            if left:\\n                r = mid-1\\n            else:\\n                l = mid+1\\n        return []\\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: You are participating in an online chess tournament. There is a chess round that starts every 15 minutes. The first round of the day starts at 00:00, and after every 15 minutes, a new round starts. For example, the second round starts at 00:15, the fourth round starts at 00:45, and the seventh round starts at 01:30. You are given two strings loginTime and logoutTime where: loginTime is the time you will login to the game, and logoutTime is the time you will logout from the game. If logoutTime is earlier than loginTime, this means you have played from loginTime to midnight and from midnight to logoutTime. Return the number of full chess rounds you have played in the tournament. Note: All the given times follow the 24-hour clock. That means the first round of the day starts at 00:00 and the last round of the day starts at 23:45. Example 1: Input: loginTime = \"09:31\", logoutTime = \"10:14\" Output: 1 Explanation: You played one full round from 09:45 to 10:00. You did not play the full round from 09:30 to 09:45 because you logged in at 09:31 after it began. You did not play the full round from 10:00 to 10:15 because you logged out at 10:14 before it ended. Example 2: Input: loginTime = \"21:30\", logoutTime = \"03:00\" Output: 22 Explanation: You played 10 full rounds from 21:30 to 00:00 and 12 full rounds from 00:00 to 03:00. 10 + 12 = 22. Constraints: loginTime and logoutTime are in the format hh:mm. 00 <= hh <= 23 00 <= mm <= 59 loginTime and logoutTime are not equal."}, {"role": "assistant", "content": "class Solution:\\n    def numberOfRounds(self, startTime: str, finishTime: str) -> int:\\n        hs, ms = (int(x) for x in startTime.split(\":\"))\\n        ts = 60 * hs + ms\\n        hf, mf = (int(x) for x in finishTime.split(\":\"))\\n        tf = 60 * hf + mf\\n        if 0 <= tf - ts < 15: return 0 # edge case \\n        return tf//15 - (ts+14)//15 + (ts>tf)*96\\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: You are given two m x n binary matrices grid1 and grid2 containing only 0's (representing water) and 1's (representing land). An island is a group of 1's connected 4-directionally (horizontal or vertical). Any cells outside of the grid are considered water cells. An island in grid2 is considered a sub-island if there is an island in grid1 that contains all the cells that make up this island in grid2. Return the number of islands in grid2 that are considered sub-islands. Example 1: Input: grid1 = [[1,1,1,0,0],[0,1,1,1,1],[0,0,0,0,0],[1,0,0,0,0],[1,1,0,1,1]], grid2 = [[1,1,1,0,0],[0,0,1,1,1],[0,1,0,0,0],[1,0,1,1,0],[0,1,0,1,0]] Output: 3 Explanation: In the picture above, the grid on the left is grid1 and the grid on the right is grid2. The 1s colored red in grid2 are those considered to be part of a sub-island. There are three sub-islands. Example 2: Input: grid1 = [[1,0,1,0,1],[1,1,1,1,1],[0,0,0,0,0],[1,1,1,1,1],[1,0,1,0,1]], grid2 = [[0,0,0,0,0],[1,1,1,1,1],[0,1,0,1,0],[0,1,0,1,0],[1,0,0,0,1]] Output: 2 Explanation: In the picture above, the grid on the left is grid1 and the grid on the right is grid2. The 1s colored red in grid2 are those considered to be part of a sub-island. There are two sub-islands. Constraints: m == grid1.length == grid2.length n == grid1[i].length == grid2[i].length 1 <= m, n <= 500 grid1[i][j] and grid2[i][j] are either 0 or 1."}, {"role": "assistant", "content": "class Solution:\\n    def countSubIslands(self, grid1: List[List[int]], grid2: List[List[int]]) -> int:\\n        \\n        m=len(grid1)\\n        n=len(grid1[0])\\n        \\n        def dfs(i,j):\\n            if i<0 or i>=m or j<0 or j>=n or grid2[i][j]==0:\\n                return\\n            \\n            grid2[i][j]=0\\n            dfs(i+1,j)\\n            dfs(i,j+1)\\n            dfs(i,j-1)\\n            dfs(i-1,j)\\n            \\n        # removing all the non-common sub-islands\\n        for i in range(m):\\n            for j in range(n):\\n                if grid2[i][j]==1 and grid1[i][j]==0:\\n                    dfs(i,j)\\n        \\n        c=0\\n\\t\\t# counting sub-islands\\n        for i in range(m):\\n            for j in range(n):\\n                if grid2[i][j]==1:\\n                    dfs(i,j)\\n                    c+=1\\n        return c\\n\\t\\t\\nIf you have any doubt ......... please feel free to ask !!!\\nThank You \\uD83E\\uDD1E"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: The minimum absolute difference of an array a is defined as the minimum value of |a[i] - a[j]|, where 0 <= i < j < a.length and a[i] != a[j]. If all elements of a are the same, the minimum absolute difference is -1. For example, the minimum absolute difference of the array [5,2,3,7,2] is |2 - 3| = 1. Note that it is not 0 because a[i] and a[j] must be different. You are given an integer array nums and the array queries where queries[i] = [li, ri]. For each query i, compute the minimum absolute difference of the subarray nums[li...ri] containing the elements of nums between the 0-based indices li and ri (inclusive). Return an array ans where ans[i] is the answer to the ith query. A subarray is a contiguous sequence of elements in an array. The value of |x| is defined as: x if x >= 0. -x if x < 0. Example 1: Input: nums = [1,3,4,8], queries = [[0,1],[1,2],[2,3],[0,3]] Output: [2,1,4,1] Explanation: The queries are processed as follows: - queries[0] = [0,1]: The subarray is [1,3] and the minimum absolute difference is |1-3| = 2. - queries[1] = [1,2]: The subarray is [3,4] and the minimum absolute difference is |3-4| = 1. - queries[2] = [2,3]: The subarray is [4,8] and the minimum absolute difference is |4-8| = 4. - queries[3] = [0,3]: The subarray is [1,3,4,8] and the minimum absolute difference is |3-4| = 1. Example 2: Input: nums = [4,5,2,2,7,10], queries = [[2,3],[0,2],[0,5],[3,5]] Output: [-1,1,1,3] Explanation: The queries are processed as follows: - queries[0] = [2,3]: The subarray is [2,2] and the minimum absolute difference is -1 because all the elements are the same. - queries[1] = [0,2]: The subarray is [4,5,2] and the minimum absolute difference is |4-5| = 1. - queries[2] = [0,5]: The subarray is [4,5,2,2,7,10] and the minimum absolute difference is |4-5| = 1. - queries[3] = [3,5]: The subarray is [2,7,10] and the minimum absolute difference is |7-10| = 3. Constraints: 2 <= nums.length <= 105 1 <= nums[i] <= 100 1 <= queries.length <= 2 * 104 0 <= li < ri < nums.length"}, {"role": "assistant", "content": "class Solution:\\n    def minDifference(self, nums: List[int], queries: List[List[int]]) -> List[int]:\\n        loc = {}\\n        for i, x in enumerate(nums): loc.setdefault(x, []).append(i)\\n        keys = sorted(loc)\\n        \\n        ans = []\\n        for l, r in queries: \\n            prev, val = 0, inf\\n            for x in keys: \\n                i = bisect_left(loc[x], l)\\n                if i < len(loc[x]) and loc[x][i] <= r: \\n                    if prev: val = min(val, x - prev)\\n                    prev = x \\n            ans.append(val if val < inf else -1)\\n        return ans\\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: Given two strings s and part, perform the following operation on s until all occurrences of the substring part are removed: Find the leftmost occurrence of the substring part and remove it from s. Return s after removing all occurrences of part. A substring is a contiguous sequence of characters in a string. Example 1: Input: s = \"daabcbaabcbc\", part = \"abc\" Output: \"dab\" Explanation: The following operations are done: - s = \"daabcbaabcbc\", remove \"abc\" starting at index 2, so s = \"dabaabcbc\". - s = \"dabaabcbc\", remove \"abc\" starting at index 4, so s = \"dababc\". - s = \"dababc\", remove \"abc\" starting at index 3, so s = \"dab\". Now s has no occurrences of \"abc\". Example 2: Input: s = \"axxxxyyyyb\", part = \"xy\" Output: \"ab\" Explanation: The following operations are done: - s = \"axxxxyyyyb\", remove \"xy\" starting at index 4 so s = \"axxxyyyb\". - s = \"axxxyyyb\", remove \"xy\" starting at index 3 so s = \"axxyyb\". - s = \"axxyyb\", remove \"xy\" starting at index 2 so s = \"axyb\". - s = \"axyb\", remove \"xy\" starting at index 1 so s = \"ab\". Now s has no occurrences of \"xy\". Constraints: 1 <= s.length <= 1000 1 <= part.length <= 1000 s\u200b\u200b\u200b\u200b\u200b\u200b and part consists of lowercase English letters."}, {"role": "assistant", "content": "class Solution:\\n    def removeOccurrences(self, s: str, part: str) -> str:\\n        lps = [0]\\n        k = 0 \\n        for i in range(1, len(part)): \\n            while k and part[k] != part[i]: k = lps[k-1]\\n            if part[k] == part[i]: k += 1\\n            lps.append(k)\\n        \\n        stack = [(\"\", 0)]\\n        for ch in s: \\n            k = stack[-1][1]\\n            while k and part[k] != ch: k = lps[k-1]\\n            if part[k] == ch: k += 1\\n            stack.append((ch, k))\\n            if k == len(part): \\n                for _ in range(len(part)): stack.pop()\\n        return \"\".join(x for x, _ in stack)\\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: The alternating sum of a 0-indexed array is defined as the sum of the elements at even indices minus the sum of the elements at odd indices. For example, the alternating sum of [4,2,5,3] is (4 + 5) - (2 + 3) = 4. Given an array nums, return the maximum alternating sum of any subsequence of nums (after reindexing the elements of the subsequence). A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements' relative order. For example, [2,7,4] is a subsequence of [4,2,3,7,2,1,4] (the underlined elements), while [2,4,2] is not. Example 1: Input: nums = [4,2,5,3] Output: 7 Explanation: It is optimal to choose the subsequence [4,2,5] with alternating sum (4 + 5) - 2 = 7. Example 2: Input: nums = [5,6,7,8] Output: 8 Explanation: It is optimal to choose the subsequence [8] with alternating sum 8. Example 3: Input: nums = [6,2,1,2,4,5] Output: 10 Explanation: It is optimal to choose the subsequence [6,1,5] with alternating sum (6 + 5) - 1 = 10. Constraints: 1 <= nums.length <= 105 1 <= nums[i] <= 105"}, {"role": "assistant", "content": "class Solution:\\n    def maxAlternatingSum(self, nums: List[int]) -> int:\\n        n = len(nums)   \\n        dp = [[0,0] for _ in range(n)] # initialize dp\\n        dp[0][0] = nums[0] # pre-define\\n        dp[0][1] = 0 # pre-define\\n\\n        for i in range(1, n): # iterate through nums starting from index 1\\n            dp[i][0] = max(nums[i] + dp[i-1][1], dp[i-1][0]) # find which value is higher between choosing or not choosing when the last value is plus.\\n            dp[i][1] = max(-nums[i] + dp[i-1][0], dp[i-1][1]) # find which value is higher between choosing or not choosing when the last value is minus.\\n        \\n        return max(dp[-1]) # find the maximum of the last array of dp of whether the last value is plus or minus, this will be our answer.\\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: You are given an m x n integer matrix grid\u200b\u200b\u200b, where m and n are both even integers, and an integer k. The matrix is composed of several layers, which is shown in the below image, where each color is its own layer: A cyclic rotation of the matrix is done by cyclically rotating each layer in the matrix. To cyclically rotate a layer once, each element in the layer will take the place of the adjacent element in the counter-clockwise direction. An example rotation is shown below: Return the matrix after applying k cyclic rotations to it. Example 1: Input: grid = [[40,10],[30,20]], k = 1 Output: [[10,20],[40,30]] Explanation: The figures above represent the grid at every state. Example 2: Input: grid = [[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]], k = 2 Output: [[3,4,8,12],[2,11,10,16],[1,7,6,15],[5,9,13,14]] Explanation: The figures above represent the grid at every state. Constraints: m == grid.length n == grid[i].length 2 <= m, n <= 50 Both m and n are even integers. 1 <= grid[i][j] <= 5000 1 <= k <= 109"}, {"role": "assistant", "content": "class Solution:\\n    def rotateGrid(self, grid: List[List[int]], k: int) -> List[List[int]]:\\n        m, n = len(grid), len(grid[0]) # dimensions \\n        \\n        for r in range(min(m, n)//2): \\n            i = j = r\\n            vals = []\\n            for jj in range(j, n-j-1):     vals.append(grid[i][jj])\\n            for ii in range(i, m-i-1):     vals.append(grid[ii][n-j-1])\\n            for jj in range(n-j-1, j, -1): vals.append(grid[m-i-1][jj])\\n            for ii in range(m-i-1, i, -1): vals.append(grid[ii][j])\\n                \\n            kk = k % len(vals)\\n            vals = vals[kk:] + vals[:kk]\\n            \\n            x = 0  \\n            for jj in range(j, n-j-1):     grid[i][jj] = vals[x]; x += 1\\n            for ii in range(i, m-i-1):     grid[ii][n-j-1] = vals[x]; x += 1\\n            for jj in range(n-j-1, j, -1): grid[m-i-1][jj] = vals[x]; x += 1\\n            for ii in range(m-i-1, i, -1): grid[ii][j] = vals[x]; x += 1\\n        return grid\\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: A wonderful string is a string where at most one letter appears an odd number of times. For example, \"ccjjc\" and \"abab\" are wonderful, but \"ab\" is not. Given a string word that consists of the first ten lowercase English letters ('a' through 'j'), return the number of wonderful non-empty substrings in word. If the same substring appears multiple times in word, then count each occurrence separately. A substring is a contiguous sequence of characters in a string. Example 1: Input: word = \"aba\" Output: 4 Explanation: The four wonderful substrings are underlined below: - \"aba\" -> \"a\" - \"aba\" -> \"b\" - \"aba\" -> \"a\" - \"aba\" -> \"aba\" Example 2: Input: word = \"aabb\" Output: 9 Explanation: The nine wonderful substrings are underlined below: - \"aabb\" -> \"a\" - \"aabb\" -> \"aa\" - \"aabb\" -> \"aab\" - \"aabb\" -> \"aabb\" - \"aabb\" -> \"a\" - \"aabb\" -> \"abb\" - \"aabb\" -> \"b\" - \"aabb\" -> \"bb\" - \"aabb\" -> \"b\" Example 3: Input: word = \"he\" Output: 2 Explanation: The two wonderful substrings are underlined below: - \"he\" -> \"h\" - \"he\" -> \"e\" Constraints: 1 <= word.length <= 105 word consists of lowercase English letters from 'a' to 'j'."}, {"role": "assistant", "content": "class Solution:\\n    def wonderfulSubstrings(self, word: str) -> int:\\n        ans = mask = 0\\n        freq = defaultdict(int, {0: 1})\\n        for ch in word: \\n            mask ^= 1 << ord(ch)-97\\n            ans += freq[mask]\\n            for i in range(10): ans += freq[mask ^ 1 << i]\\n            freq[mask] += 1\\n        return ans \\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: You are playing a video game where you are defending your city from a group of n monsters. You are given a 0-indexed integer array dist of size n, where dist[i] is the initial distance in kilometers of the ith monster from the city. The monsters walk toward the city at a constant speed. The speed of each monster is given to you in an integer array speed of size n, where speed[i] is the speed of the ith monster in kilometers per minute. You have a weapon that, once fully charged, can eliminate a single monster. However, the weapon takes one minute to charge. The weapon is fully charged at the very start. You lose when any monster reaches your city. If a monster reaches the city at the exact moment the weapon is fully charged, it counts as a loss, and the game ends before you can use your weapon. Return the maximum number of monsters that you can eliminate before you lose, or n if you can eliminate all the monsters before they reach the city. Example 1: Input: dist = [1,3,4], speed = [1,1,1] Output: 3 Explanation: In the beginning, the distances of the monsters are [1,3,4]. You eliminate the first monster. After a minute, the distances of the monsters are [X,2,3]. You eliminate the second monster. After a minute, the distances of the monsters are [X,X,2]. You eliminate the third monster. All 3 monsters can be eliminated. Example 2: Input: dist = [1,1,2,3], speed = [1,1,1,1] Output: 1 Explanation: In the beginning, the distances of the monsters are [1,1,2,3]. You eliminate the first monster. After a minute, the distances of the monsters are [X,0,1,2], so you lose. You can only eliminate 1 monster. Example 3: Input: dist = [3,2,4], speed = [5,3,2] Output: 1 Explanation: In the beginning, the distances of the monsters are [3,2,4]. You eliminate the first monster. After a minute, the distances of the monsters are [X,0,2], so you lose. You can only eliminate 1 monster. Constraints: n == dist.length == speed.length 1 <= n <= 105 1 <= dist[i], speed[i] <= 105"}, {"role": "assistant", "content": "class Solution:\\n    def eliminateMaximum(self, dist: List[int], speed: List[int]) -> int:\\n        heap = []\\n        for i in range(len(dist)):\\n            heapq.heappush(heap, dist[i] / speed[i])\\n        \\n        res = 0\\n\\n        while heap:\\n            if heapq.heappop(heap) <= res:\\n                break\\n            res += 1\\n        \\n        return res        \\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: Alice and Bob take turns playing a game, with Alice starting first. You are given a string num of even length consisting of digits and '?' characters. On each turn, a player will do the following if there is still at least one '?' in num: Choose an index i where num[i] == '?'. Replace num[i] with any digit between '0' and '9'. The game ends when there are no more '?' characters in num. For Bob to win, the sum of the digits in the first half of num must be equal to the sum of the digits in the second half. For Alice to win, the sums must not be equal. For example, if the game ended with num = \"243801\", then Bob wins because 2+4+3 = 8+0+1. If the game ended with num = \"243803\", then Alice wins because 2+4+3 != 8+0+3. Assuming Alice and Bob play optimally, return true if Alice will win and false if Bob will win. Example 1: Input: num = \"5023\" Output: false Explanation: There are no moves to be made. The sum of the first half is equal to the sum of the second half: 5 + 0 = 2 + 3. Example 2: Input: num = \"25??\" Output: true Explanation: Alice can replace one of the '?'s with '9' and it will be impossible for Bob to make the sums equal. Example 3: Input: num = \"?3295???\" Output: false Explanation: It can be proven that Bob will always win. One possible outcome is: - Alice replaces the first '?' with '9'. num = \"93295???\". - Bob replaces one of the '?' in the right half with '9'. num = \"932959??\". - Alice replaces one of the '?' in the right half with '2'. num = \"9329592?\". - Bob replaces the last '?' in the right half with '7'. num = \"93295927\". Bob wins because 9 + 3 + 2 + 9 = 5 + 9 + 2 + 7. Constraints: 2 <= num.length <= 105 num.length is even. num consists of only digits and '?'."}, {"role": "assistant", "content": "class Solution:\\n    def sumGame(self, num: str) -> bool:\\n        n = len(num)\\n        q_cnt_1 = s1 = 0\\n        for i in range(n//2):    # get digit sum and question mark count for the first half of `num`\\n            if num[i] == \\'?\\':\\n                q_cnt_1 += 1\\n            else:    \\n                s1 += int(num[i])\\n        q_cnt_2 = s2 = 0\\t\\t\\t\\t\\n        for i in range(n//2, n): # get digit sum and question mark count for the second half of `num`\\n            if num[i] == \\'?\\':\\n                q_cnt_2 += 1\\n            else:    \\n                s2 += int(num[i])\\n        s_diff = s1 - s2         # calculate sum difference and question mark difference\\n        q_diff = q_cnt_2 - q_cnt_1\\n        return not (q_diff % 2 == 0 and q_diff // 2 * 9 == s_diff) # When Bob can\\'t win, Alice wins\\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: Given a string s, return the number of unique palindromes of length three that are a subsequence of s. Note that even if there are multiple ways to obtain the same subsequence, it is still only counted once. A palindrome is a string that reads the same forwards and backwards. A subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters. For example, \"ace\" is a subsequence of \"abcde\". Example 1: Input: s = \"aabca\" Output: 3 Explanation: The 3 palindromic subsequences of length 3 are: - \"aba\" (subsequence of \"aabca\") - \"aaa\" (subsequence of \"aabca\") - \"aca\" (subsequence of \"aabca\") Example 2: Input: s = \"adc\" Output: 0 Explanation: There are no palindromic subsequences of length 3 in \"adc\". Example 3: Input: s = \"bbcbaba\" Output: 4 Explanation: The 4 palindromic subsequences of length 3 are: - \"bbb\" (subsequence of \"bbcbaba\") - \"bcb\" (subsequence of \"bbcbaba\") - \"bab\" (subsequence of \"bbcbaba\") - \"aba\" (subsequence of \"bbcbaba\") Constraints: 3 <= s.length <= 105 s consists of only lowercase English letters."}, {"role": "assistant", "content": "class Solution:\\n    def countPalindromicSubsequence(self, inputString):\\n        # Arrays to store the minimum and maximum occurrences of each character in the input string\\n        min_exist = [float(\\'inf\\')] * 26\\n        max_exist = [float(\\'-inf\\')] * 26\\n\\n        # Populate min_exist and max_exist arrays\\n        for i in range(len(inputString)):\\n            char_index = ord(inputString[i]) - ord(\\'a\\')\\n            min_exist[char_index] = min(min_exist[char_index], i)\\n            max_exist[char_index] = max(max_exist[char_index], i)\\n\\n        # Variable to store the final count of unique palindromic subsequences\\n        unique_count = 0\\n\\n        # Iterate over each character in the alphabet\\n        for char_index in range(26):\\n            # Check if the character has occurred in the input string\\n            if min_exist[char_index] == float(\\'inf\\') or max_exist[char_index] == float(\\'-inf\\'):\\n                continue  # No occurrences, move to the next character\\n\\n            # Set to store unique characters between the minimum and maximum occurrences\\n            unique_chars_between = set()\\n\\n            # Iterate over the characters between the minimum and maximum occurrences\\n            for j in range(min_exist[char_index] + 1, max_exist[char_index]):\\n                unique_chars_between.add(inputString[j])\\n\\n            # Add the count of unique characters between the occurrences to the final count\\n            unique_count += len(unique_chars_between)\\n\\n        # Return the total count of unique palindromic subsequences\\n        return unique_count\\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: You are given a strictly increasing integer array rungs that represents the height of rungs on a ladder. You are currently on the floor at height 0, and you want to reach the last rung. You are also given an integer dist. You can only climb to the next highest rung if the distance between where you are currently at (the floor or on a rung) and the next rung is at most dist. You are able to insert rungs at any positive integer height if a rung is not already there. Return the minimum number of rungs that must be added to the ladder in order for you to climb to the last rung. Example 1: Input: rungs = [1,3,5,10], dist = 2 Output: 2 Explanation: You currently cannot reach the last rung. Add rungs at heights 7 and 8 to climb this ladder. The ladder will now have rungs at [1,3,5,7,8,10]. Example 2: Input: rungs = [3,6,8,10], dist = 3 Output: 0 Explanation: This ladder can be climbed without adding additional rungs. Example 3: Input: rungs = [3,4,6,7], dist = 2 Output: 1 Explanation: You currently cannot reach the first rung from the ground. Add a rung at height 1 to climb this ladder. The ladder will now have rungs at [1,3,4,6,7]. Constraints: 1 <= rungs.length <= 105 1 <= rungs[i] <= 109 1 <= dist <= 109 rungs is strictly increasing."}, {"role": "assistant", "content": "class Solution:\\n    def addRungs(self, rungs: List[int], dist: int) -> int:\\n        return sum((a - b - 1) // dist for a, b in zip(rungs, [0] + rungs))\\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: You are given an m x n integer matrix points (0-indexed). Starting with 0 points, you want to maximize the number of points you can get from the matrix. To gain points, you must pick one cell in each row. Picking the cell at coordinates (r, c) will add points[r][c] to your score. However, you will lose points if you pick a cell too far from the cell that you picked in the previous row. For every two adjacent rows r and r + 1 (where 0 <= r < m - 1), picking cells at coordinates (r, c1) and (r + 1, c2) will subtract abs(c1 - c2) from your score. Return the maximum number of points you can achieve. abs(x) is defined as: x for x >= 0. -x for x < 0. Example 1: Input: points = [[1,2,3],[1,5,1],[3,1,1]] Output: 9 Explanation: The blue cells denote the optimal cells to pick, which have coordinates (0, 2), (1, 1), and (2, 0). You add 3 + 5 + 3 = 11 to your score. However, you must subtract abs(2 - 1) + abs(1 - 0) = 2 from your score. Your final score is 11 - 2 = 9. Example 2: Input: points = [[1,5],[2,3],[4,2]] Output: 11 Explanation: The blue cells denote the optimal cells to pick, which have coordinates (0, 1), (1, 1), and (2, 0). You add 5 + 3 + 4 = 12 to your score. However, you must subtract abs(1 - 1) + abs(1 - 0) = 1 from your score. Your final score is 12 - 1 = 11. Constraints: m == points.length n == points[r].length 1 <= m, n <= 105 1 <= m * n <= 105 0 <= points[r][c] <= 105"}, {"role": "assistant", "content": "class Solution:\\n    def maxPoints(self, points: List[List[int]]) -> int:\\n        m, n = len(points), len(points[0])\\n        \\n        dp = points[0]\\n        \\n        left = [0] * n ## left side contribution\\n        right = [0] * n ## right side contribution\\n        \\n        for r in range(1, m):\\n            for c in range(n):\\n                if c == 0:\\n                    left[c] = dp[c]\\n                else:\\n                    left[c] = max(left[c - 1] - 1, dp[c])\\n            \\n            for c in range(n - 1, -1, -1):\\n                if c == n-1:\\n                    right[c] = dp[c]\\n                else:\\n                    right[c] = max(right[c + 1] - 1, dp[c])\\n                    \\n            for c in range(n):\\n                dp[c] = points[r][c] + max(left[c], right[c])\\n                \\n        return max(dp)\\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: There is a party where n friends numbered from 0 to n - 1 are attending. There is an infinite number of chairs in this party that are numbered from 0 to infinity. When a friend arrives at the party, they sit on the unoccupied chair with the smallest number. For example, if chairs 0, 1, and 5 are occupied when a friend comes, they will sit on chair number 2. When a friend leaves the party, their chair becomes unoccupied at the moment they leave. If another friend arrives at that same moment, they can sit in that chair. You are given a 0-indexed 2D integer array times where times[i] = [arrivali, leavingi], indicating the arrival and leaving times of the ith friend respectively, and an integer targetFriend. All arrival times are distinct. Return the chair number that the friend numbered targetFriend will sit on. Example 1: Input: times = [[1,4],[2,3],[4,6]], targetFriend = 1 Output: 1 Explanation: - Friend 0 arrives at time 1 and sits on chair 0. - Friend 1 arrives at time 2 and sits on chair 1. - Friend 1 leaves at time 3 and chair 1 becomes empty. - Friend 0 leaves at time 4 and chair 0 becomes empty. - Friend 2 arrives at time 4 and sits on chair 0. Since friend 1 sat on chair 1, we return 1. Example 2: Input: times = [[3,10],[1,5],[2,6]], targetFriend = 0 Output: 2 Explanation: - Friend 1 arrives at time 1 and sits on chair 0. - Friend 2 arrives at time 2 and sits on chair 1. - Friend 0 arrives at time 3 and sits on chair 2. - Friend 1 leaves at time 5 and chair 0 becomes empty. - Friend 2 leaves at time 6 and chair 1 becomes empty. - Friend 0 leaves at time 10 and chair 2 becomes empty. Since friend 0 sat on chair 2, we return 2. Constraints: n == times.length 2 <= n <= 104 times[i].length == 2 1 <= arrivali < leavingi <= 105 0 <= targetFriend <= n - 1 Each arrivali time is distinct."}, {"role": "assistant", "content": "class Solution:\\n    def smallestChair(self, times: List[List[int]], targetFriend: int) -> int:\\n        vals = []\\n        for i, (arrival, leaving) in enumerate(times): \\n            vals.append((arrival, 1, i))\\n            vals.append((leaving, 0, i))\\n        \\n        k = 0 \\n        pq = [] # available seats \\n        mp = {} # player-to-seat mapping \\n        for _, arrival, i in sorted(vals): \\n            if arrival: \\n                if pq: s = heappop(pq)\\n                else: \\n                    s = k\\n                    k += 1\\n                if i == targetFriend: return s\\n                mp[i] = s\\n            else: heappush(pq, mp[i]) # new seat available\\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: There is a long and thin painting that can be represented by a number line. The painting was painted with multiple overlapping segments where each segment was painted with a unique color. You are given a 2D integer array segments, where segments[i] = [starti, endi, colori] represents the half-closed segment [starti, endi) with colori as the color. The colors in the overlapping segments of the painting were mixed when it was painted. When two or more colors mix, they form a new color that can be represented as a set of mixed colors. For example, if colors 2, 4, and 6 are mixed, then the resulting mixed color is {2,4,6}. For the sake of simplicity, you should only output the sum of the elements in the set rather than the full set. You want to describe the painting with the minimum number of non-overlapping half-closed segments of these mixed colors. These segments can be represented by the 2D array painting where painting[j] = [leftj, rightj, mixj] describes a half-closed segment [leftj, rightj) with the mixed color sum of mixj. For example, the painting created with segments = [[1,4,5],[1,7,7]] can be described by painting = [[1,4,12],[4,7,7]] because: [1,4) is colored {5,7} (with a sum of 12) from both the first and second segments. [4,7) is colored {7} from only the second segment. Return the 2D array painting describing the finished painting (excluding any parts that are not painted). You may return the segments in any order. A half-closed segment [a, b) is the section of the number line between points a and b including point a and not including point b. Example 1: Input: segments = [[1,4,5],[4,7,7],[1,7,9]] Output: [[1,4,14],[4,7,16]] Explanation: The painting can be described as follows: - [1,4) is colored {5,9} (with a sum of 14) from the first and third segments. - [4,7) is colored {7,9} (with a sum of 16) from the second and third segments. Example 2: Input: segments = [[1,7,9],[6,8,15],[8,10,7]] Output: [[1,6,9],[6,7,24],[7,8,15],[8,10,7]] Explanation: The painting can be described as follows: - [1,6) is colored 9 from the first segment. - [6,7) is colored {9,15} (with a sum of 24) from the first and second segments. - [7,8) is colored 15 from the second segment. - [8,10) is colored 7 from the third segment. Example 3: Input: segments = [[1,4,5],[1,4,7],[4,7,1],[4,7,11]] Output: [[1,4,12],[4,7,12]] Explanation: The painting can be described as follows: - [1,4) is colored {5,7} (with a sum of 12) from the first and second segments. - [4,7) is colored {1,11} (with a sum of 12) from the third and fourth segments. Note that returning a single segment [1,7) is incorrect because the mixed color sets are different. Constraints: 1 <= segments.length <= 2 * 104 segments[i].length == 3 1 <= starti < endi <= 105 1 <= colori <= 109 Each colori is distinct."}, {"role": "assistant", "content": "class Solution:\\n    def splitPainting(self, segments: List[List[int]]) -> List[List[int]]:\\n\\t\\t# via this mapping, we can easily know which coordinates should be took into consideration.\\n        mapping = defaultdict(int)\\n        for s, e, c in segments:\\n            mapping[s] += c\\n            mapping[e] -= c\\n        \\n        res = []\\n        prev, color = None, 0\\n        for now in sorted(mapping):\\n            if color: # if color == 0, it means this part isn\\'t painted.\\n                res.append((prev, now, color))\\n            \\n            color += mapping[now]\\n            prev = now\\n            \\n        return res\\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: You are given a string num, which represents a large integer. You are also given a 0-indexed integer array change of length 10 that maps each digit 0-9 to another digit. More formally, digit d maps to digit change[d]. You may choose to mutate a single substring of num. To mutate a substring, replace each digit num[i] with the digit it maps to in change (i.e. replace num[i] with change[num[i]]). Return a string representing the largest possible integer after mutating (or choosing not to) a single substring of num. A substring is a contiguous sequence of characters within the string. Example 1: Input: num = \"132\", change = [9,8,5,0,3,6,4,2,6,8] Output: \"832\" Explanation: Replace the substring \"1\": - 1 maps to change[1] = 8. Thus, \"132\" becomes \"832\". \"832\" is the largest number that can be created, so return it. Example 2: Input: num = \"021\", change = [9,4,3,5,7,2,1,9,0,6] Output: \"934\" Explanation: Replace the substring \"021\": - 0 maps to change[0] = 9. - 2 maps to change[2] = 3. - 1 maps to change[1] = 4. Thus, \"021\" becomes \"934\". \"934\" is the largest number that can be created, so return it. Example 3: Input: num = \"5\", change = [1,4,7,5,3,2,5,6,9,4] Output: \"5\" Explanation: \"5\" is already the largest number that can be created, so return it. Constraints: 1 <= num.length <= 105 num consists of only digits 0-9. change.length == 10 0 <= change[d] <= 9"}, {"role": "assistant", "content": "class Solution:\\n    def maximumNumber(self, num: str, change: List[int]) -> str:\\n        num = list(num)\\n        on = False \\n        for i, ch in enumerate(num): \\n            x = int(ch)\\n            if x < change[x]: \\n                on = True\\n                num[i] = str(change[x])\\n            elif x > change[x] and on: break\\n        return \"\".join(num)\\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: There is a survey that consists of n questions where each question's answer is either 0 (no) or 1 (yes). The survey was given to m students numbered from 0 to m - 1 and m mentors numbered from 0 to m - 1. The answers of the students are represented by a 2D integer array students where students[i] is an integer array that contains the answers of the ith student (0-indexed). The answers of the mentors are represented by a 2D integer array mentors where mentors[j] is an integer array that contains the answers of the jth mentor (0-indexed). Each student will be assigned to one mentor, and each mentor will have one student assigned to them. The compatibility score of a student-mentor pair is the number of answers that are the same for both the student and the mentor. For example, if the student's answers were [1, 0, 1] and the mentor's answers were [0, 0, 1], then their compatibility score is 2 because only the second and the third answers are the same. You are tasked with finding the optimal student-mentor pairings to maximize the sum of the compatibility scores. Given students and mentors, return the maximum compatibility score sum that can be achieved. Example 1: Input: students = [[1,1,0],[1,0,1],[0,0,1]], mentors = [[1,0,0],[0,0,1],[1,1,0]] Output: 8 Explanation: We assign students to mentors in the following way: - student 0 to mentor 2 with a compatibility score of 3. - student 1 to mentor 0 with a compatibility score of 2. - student 2 to mentor 1 with a compatibility score of 3. The compatibility score sum is 3 + 2 + 3 = 8. Example 2: Input: students = [[0,0],[0,0],[0,0]], mentors = [[1,1],[1,1],[1,1]] Output: 0 Explanation: The compatibility score of any student-mentor pair is 0. Constraints: m == students.length == mentors.length n == students[i].length == mentors[j].length 1 <= m, n <= 8 students[i][k] is either 0 or 1. mentors[j][k] is either 0 or 1."}, {"role": "assistant", "content": "class Solution:\\n    def maxCompatibilitySum(self, students: List[List[int]], mentors: List[List[int]]) -> int:\\n        m = len(students)\\n        \\n        score = [[0]*m for _ in range(m)]\\n        for i in range(m): \\n            for j in range(m): \\n                score[i][j] = sum(x == y for x, y in zip(students[i], mentors[j]))\\n        \\n        ans = 0 \\n        for perm in permutations(range(m)): \\n            ans = max(ans, sum(score[i][j] for i, j in zip(perm, range(m))))\\n        return ans \\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: There are n projects numbered from 0 to n - 1. You are given an integer array milestones where each milestones[i] denotes the number of milestones the ith project has. You can work on the projects following these two rules: Every week, you will finish exactly one milestone of one project. You must work every week. You cannot work on two milestones from the same project for two consecutive weeks. Once all the milestones of all the projects are finished, or if the only milestones that you can work on will cause you to violate the above rules, you will stop working. Note that you may not be able to finish every project's milestones due to these constraints. Return the maximum number of weeks you would be able to work on the projects without violating the rules mentioned above. Example 1: Input: milestones = [1,2,3] Output: 6 Explanation: One possible scenario is: \u200b\u200b\u200b\u200b- During the 1st week, you will work on a milestone of project 0. - During the 2nd week, you will work on a milestone of project 2. - During the 3rd week, you will work on a milestone of project 1. - During the 4th week, you will work on a milestone of project 2. - During the 5th week, you will work on a milestone of project 1. - During the 6th week, you will work on a milestone of project 2. The total number of weeks is 6. Example 2: Input: milestones = [5,2,1] Output: 7 Explanation: One possible scenario is: - During the 1st week, you will work on a milestone of project 0. - During the 2nd week, you will work on a milestone of project 1. - During the 3rd week, you will work on a milestone of project 0. - During the 4th week, you will work on a milestone of project 1. - During the 5th week, you will work on a milestone of project 0. - During the 6th week, you will work on a milestone of project 2. - During the 7th week, you will work on a milestone of project 0. The total number of weeks is 7. Note that you cannot work on the last milestone of project 0 on 8th week because it would violate the rules. Thus, one milestone in project 0 will remain unfinished. Constraints: n == milestones.length 1 <= n <= 105 1 <= milestones[i] <= 109"}, {"role": "assistant", "content": "class Solution:\\n    def numberOfWeeks(self, milestones: List[int]) -> int:\\n        _sum, _max = sum(milestones), max(milestones)\\n\\t\\t# (_sum - _max) is the sum of milestones from (2) the rest of projects, if True, we can form another project with the same amount of milestones as (1)\\n\\t\\t# can refer to the section `Why the greedy strategy works?` for the proof\\n        if _sum - _max >= _max:  \\n            return _sum\\n        return 2 * (_sum - _max) + 1  # start from the project with most milestones (_sum - _max + 1) and work on the the rest of milestones (_sum - _max)\\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: You are currently designing a dynamic array. You are given a 0-indexed integer array nums, where nums[i] is the number of elements that will be in the array at time i. In addition, you are given an integer k, the maximum number of times you can resize the array (to any size). The size of the array at time t, sizet, must be at least nums[t] because there needs to be enough space in the array to hold all the elements. The space wasted at time t is defined as sizet - nums[t], and the total space wasted is the sum of the space wasted across every time t where 0 <= t < nums.length. Return the minimum total space wasted if you can resize the array at most k times. Note: The array can have any size at the start and does not count towards the number of resizing operations. Example 1: Input: nums = [10,20], k = 0 Output: 10 Explanation: size = [20,20]. We can set the initial size to be 20. The total wasted space is (20 - 10) + (20 - 20) = 10. Example 2: Input: nums = [10,20,30], k = 1 Output: 10 Explanation: size = [20,20,30]. We can set the initial size to be 20 and resize to 30 at time 2. The total wasted space is (20 - 10) + (20 - 20) + (30 - 30) = 10. Example 3: Input: nums = [10,20,15,30,20], k = 2 Output: 15 Explanation: size = [10,20,20,30,30]. We can set the initial size to 10, resize to 20 at time 1, and resize to 30 at time 3. The total wasted space is (10 - 10) + (20 - 20) + (20 - 15) + (30 - 30) + (30 - 20) = 15. Constraints: 1 <= nums.length <= 200 1 <= nums[i] <= 106 0 <= k <= nums.length - 1"}, {"role": "assistant", "content": "class Solution:\\n    def minSpaceWastedKResizing(self, nums: List[int], k: int) -> int:\\n        \\n        @cache\\n        def fn(i, k): \\n            \"\"\"Return min waste from i with k ops.\"\"\"\\n            if i == len(nums): return 0\\n            if k < 0: return inf \\n            ans = inf\\n            rmx = rsm = 0\\n            for j in range(i, len(nums)): \\n                rmx = max(rmx, nums[j])\\n                rsm += nums[j]\\n                ans = min(ans, rmx*(j-i+1) - rsm + fn(j+1, k-1))\\n            return ans \\n        \\n        return fn(0, k)\\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: You are given a 0-indexed integer array piles, where piles[i] represents the number of stones in the ith pile, and an integer k. You should apply the following operation exactly k times: Choose any piles[i] and remove floor(piles[i] / 2) stones from it. Notice that you can apply the operation on the same pile more than once. Return the minimum possible total number of stones remaining after applying the k operations. floor(x) is the greatest integer that is smaller than or equal to x (i.e., rounds x down). Example 1: Input: piles = [5,4,9], k = 2 Output: 12 Explanation: Steps of a possible scenario are: - Apply the operation on pile 2. The resulting piles are [5,4,5]. - Apply the operation on pile 0. The resulting piles are [3,4,5]. The total number of stones in [3,4,5] is 12. Example 2: Input: piles = [4,3,6,7], k = 3 Output: 12 Explanation: Steps of a possible scenario are: - Apply the operation on pile 2. The resulting piles are [4,3,3,7]. - Apply the operation on pile 3. The resulting piles are [4,3,3,4]. - Apply the operation on pile 0. The resulting piles are [2,3,3,4]. The total number of stones in [2,3,3,4] is 12. Constraints: 1 <= piles.length <= 105 1 <= piles[i] <= 104 1 <= k <= 105"}, {"role": "assistant", "content": "class Solution:\\n    def minStoneSum(self, piles: List[int], k: int) -> int:\\n        pq = [-x for x in piles]\\n        heapify(pq)\\n        for _ in range(k): heapreplace(pq, pq[0]//2)\\n        return -sum(pq)\\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: You are given a 0-indexed array nums of distinct integers. You want to rearrange the elements in the array such that every element in the rearranged array is not equal to the average of its neighbors. More formally, the rearranged array should have the property such that for every i in the range 1 <= i < nums.length - 1, (nums[i-1] + nums[i+1]) / 2 is not equal to nums[i]. Return any rearrangement of nums that meets the requirements. Example 1: Input: nums = [1,2,3,4,5] Output: [1,2,4,5,3] Explanation: When i=1, nums[i] = 2, and the average of its neighbors is (1+4) / 2 = 2.5. When i=2, nums[i] = 4, and the average of its neighbors is (2+5) / 2 = 3.5. When i=3, nums[i] = 5, and the average of its neighbors is (4+3) / 2 = 3.5. Example 2: Input: nums = [6,2,0,9,7] Output: [9,7,6,2,0] Explanation: When i=1, nums[i] = 7, and the average of its neighbors is (9+6) / 2 = 7.5. When i=2, nums[i] = 6, and the average of its neighbors is (7+2) / 2 = 4.5. When i=3, nums[i] = 2, and the average of its neighbors is (6+0) / 2 = 3. Constraints: 3 <= nums.length <= 105 0 <= nums[i] <= 105"}, {"role": "assistant", "content": "class Solution:\\n    def rearrangeArray(self, nums: List[int]) -> List[int]:\\n        nums.sort()\\n        res = []\\n        i= 0 \\n        j=len(nums)-1\\n        while i<j:\\n            res.append(nums[i])\\n            res.append(nums[j])\\n            i+=1\\n            j-=1\\n        if len(res) != len(nums):\\n            res.append(nums[i])\\n        return res\\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: You are given an n x n integer matrix. You can do the following operation any number of times: Choose any two adjacent elements of matrix and multiply each of them by -1. Two elements are considered adjacent if and only if they share a border. Your goal is to maximize the summation of the matrix's elements. Return the maximum sum of the matrix's elements using the operation mentioned above. Example 1: Input: matrix = [[1,-1],[-1,1]] Output: 4 Explanation: We can follow the following steps to reach sum equals 4: - Multiply the 2 elements in the first row by -1. - Multiply the 2 elements in the first column by -1. Example 2: Input: matrix = [[1,2,3],[-1,-2,-3],[1,2,3]] Output: 16 Explanation: We can follow the following step to reach sum equals 16: - Multiply the 2 last elements in the second row by -1. Constraints: n == matrix.length == matrix[i].length 2 <= n <= 250 -105 <= matrix[i][j] <= 105"}, {"role": "assistant", "content": "class Solution:\\n    def maxMatrixSum(self, matrix: List[List[int]]) -> int:\\n        ans = mult = 0\\n        val = inf \\n        for i in range(len(matrix)): \\n            for j in range(len(matrix)):\\n                ans += abs(matrix[i][j])\\n                val = min(val, abs(matrix[i][j]))\\n                if matrix[i][j] < 0: mult ^= 1\\n        return ans - 2*mult*val\\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: You are in a city that consists of n intersections numbered from 0 to n - 1 with bi-directional roads between some intersections. The inputs are generated such that you can reach any intersection from any other intersection and that there is at most one road between any two intersections. You are given an integer n and a 2D integer array roads where roads[i] = [ui, vi, timei] means that there is a road between intersections ui and vi that takes timei minutes to travel. You want to know in how many ways you can travel from intersection 0 to intersection n - 1 in the shortest amount of time. Return the number of ways you can arrive at your destination in the shortest amount of time. Since the answer may be large, return it modulo 109 + 7. Example 1: Input: n = 7, roads = [[0,6,7],[0,1,2],[1,2,3],[1,3,3],[6,3,3],[3,5,1],[6,5,1],[2,5,1],[0,4,5],[4,6,2]] Output: 4 Explanation: The shortest amount of time it takes to go from intersection 0 to intersection 6 is 7 minutes. The four ways to get there in 7 minutes are: - 0 \u279d 6 - 0 \u279d 4 \u279d 6 - 0 \u279d 1 \u279d 2 \u279d 5 \u279d 6 - 0 \u279d 1 \u279d 3 \u279d 5 \u279d 6 Example 2: Input: n = 2, roads = [[1,0,10]] Output: 1 Explanation: There is only one way to go from intersection 0 to intersection 1, and it takes 10 minutes. Constraints: 1 <= n <= 200 n - 1 <= roads.length <= n * (n - 1) / 2 roads[i].length == 3 0 <= ui, vi <= n - 1 1 <= timei <= 109 ui != vi There is at most one road connecting any two intersections. You can reach any intersection from any other intersection."}, {"role": "assistant", "content": "class Solution:\\n    def countPaths(self, n: int, roads: List[List[int]]) -> int:\\n        # create adjacency list\\n        adj_list = defaultdict(list)\\n        for i,j,k in roads:\\n            adj_list[i].append((j,k))\\n            adj_list[j].append((i,k))\\n            \\n        start = 0\\n        end = n-1\\n        \\n        # set minimum distance of all nodes but start to infinity.\\n        # min_dist[i] = [minimum time from start, number of ways to get to node i in min time]\\n        min_dist = {i:[float(\\'inf\\'),0] for i in adj_list.keys()}\\n        min_dist[start] = [0,1]\\n             \\n        # Heap nodes in the format (elapsed time to get to that node, node index)\\n        # This is done so as to allow the heap to pop node with lowest time first\\n        # Push first node to heap.\\n        heap = [(0, start)]\\n        while heap:\\n            elapsed_time, node = heappop(heap)\\n            # if nodes getting popped have a higher elapsed time than minimum time required\\n            # to reach end node, means we have exhausted all possibilities\\n            # Note: we can do this only because time elapsed cannot be negetive\\n            if elapsed_time > min_dist[end][0]:\\n                break\\n            for neighbor, time in adj_list[node]:\\n                # check most expected condition first. Reduce check time for if statement\\n                if (elapsed_time + time) > min_dist[neighbor][0]:\\n                    continue\\n                # if time is equal to minimum time to node, add the ways to get to node to\\n                # the next node in minimum time\\n                elif (elapsed_time + time) == min_dist[neighbor][0]:\\n                    min_dist[neighbor][1] += min_dist[node][1]\\n                else: # node has not been visited before. Set minimum time \\n                    min_dist[neighbor][0] = elapsed_time + time\\n                    min_dist[neighbor][1] = min_dist[node][1]\\n                    heappush(heap, (elapsed_time+time,neighbor))\\n\\n        return min_dist[end][1]%(pow(10,9)+7)\\n        \\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: Given an array of strings nums containing n unique binary strings each of length n, return a binary string of length n that does not appear in nums. If there are multiple answers, you may return any of them. Example 1: Input: nums = [\"01\",\"10\"] Output: \"11\" Explanation: \"11\" does not appear in nums. \"00\" would also be correct. Example 2: Input: nums = [\"00\",\"01\"] Output: \"11\" Explanation: \"11\" does not appear in nums. \"10\" would also be correct. Example 3: Input: nums = [\"111\",\"011\",\"001\"] Output: \"101\" Explanation: \"101\" does not appear in nums. \"000\", \"010\", \"100\", and \"110\" would also be correct. Constraints: n == nums.length 1 <= n <= 16 nums[i].length == n nums[i] is either '0' or '1'. All the strings of nums are unique."}, {"role": "assistant", "content": "class Solution:\\n    def findDifferentBinaryString(self, nums: List[str]) -> str:\\n        size = len(nums)  # Number of binary strings in the input list\\n\\n        # Sort the input list in lexicographical order\\n        nums.sort()\\n\\n        pointer = 0  # Pointer to track the expected decimal value for the next binary string\\n\\n        # Iterate through the sorted binary strings\\n        for i in range(size):\\n            # Convert the current binary string to decimal\\n            decimal_value = int(nums[i], 2)\\n\\n            # Check if the decimal value matches the expected value\\n            if decimal_value == pointer:\\n                pointer += 1\\n            else:\\n                # If not, return the binary representation of the expected value with appropriate length\\n                return format(pointer, f\\'0{size}b\\')\\n\\n        # If no unique binary string is found, return the binary representation of the next expected value\\n        return format(pointer, f\\'0{size}b\\')\\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: You are given an m x n integer matrix mat and an integer target. Choose one integer from each row in the matrix such that the absolute difference between target and the sum of the chosen elements is minimized. Return the minimum absolute difference. The absolute difference between two numbers a and b is the absolute value of a - b. Example 1: Input: mat = [[1,2,3],[4,5,6],[7,8,9]], target = 13 Output: 0 Explanation: One possible choice is to: - Choose 1 from the first row. - Choose 5 from the second row. - Choose 7 from the third row. The sum of the chosen elements is 13, which equals the target, so the absolute difference is 0. Example 2: Input: mat = [[1],[2],[3]], target = 100 Output: 94 Explanation: The best possible choice is to: - Choose 1 from the first row. - Choose 2 from the second row. - Choose 3 from the third row. The sum of the chosen elements is 6, and the absolute difference is 94. Example 3: Input: mat = [[1,2,9,8,7]], target = 6 Output: 1 Explanation: The best choice is to choose 7 from the first row. The absolute difference is 1. Constraints: m == mat.length n == mat[i].length 1 <= m, n <= 70 1 <= mat[i][j] <= 70 1 <= target <= 800"}, {"role": "assistant", "content": "class Solution:\\n    def minimizeTheDifference(self, mat: List[List[int]], target: int) -> int:\\n        \\n        # store the mxn size of the matrix\\n        m = len(mat)\\n        n = len(mat[0])\\n        \\n        dp = defaultdict(defaultdict)\\n        \\n        # Sorting each row of the array for more efficient pruning\\n        # Note:this purely based on the observation on problem constraints (although interesting :))\\n        for i in range(m):\\n            mat[i] = sorted(mat[i])\\n        \\n        # returns minimum absolute starting from from row i to n-1 for the target\\n        globalMin = float(\"inf\")\\n        def findMinAbsDiff(i,prevSum):\\n            nonlocal globalMin\\n            if i == m:\\n                globalMin = min(globalMin, abs(prevSum-target))\\n                return abs(prevSum-target)\\n            \\n            # pruning step 1\\n            # because the array is increasing & prevSum & target will always be positive\\n            if prevSum-target > globalMin:\\n                return float(\"inf\")\\n            \\n            \\n            if (i in dp) and (prevSum in dp[i]):\\n                return dp[i][prevSum]\\n            \\n            minDiff = float(\"inf\")\\n            # for each candidate select that and backtrack\\n            for j in range(n):\\n                diff = findMinAbsDiff(i+1, prevSum+mat[i][j])\\n                # pruning step 2 - break if we found minDiff 0 --> VERY CRTICIAL\\n                if diff == 0:\\n                    minDiff = 0\\n                    break\\n                minDiff = min(minDiff, diff)\\n            \\n            dp[i][prevSum] = minDiff\\n            return minDiff\\n        \\n        return findMinAbsDiff(0, 0)\\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: You are given an array of strings nums and an integer k. Each string in nums represents an integer without leading zeros. Return the string that represents the kth largest integer in nums. Note: Duplicate numbers should be counted distinctly. For example, if nums is [\"1\",\"2\",\"2\"], \"2\" is the first largest integer, \"2\" is the second-largest integer, and \"1\" is the third-largest integer. Example 1: Input: nums = [\"3\",\"6\",\"7\",\"10\"], k = 4 Output: \"3\" Explanation: The numbers in nums sorted in non-decreasing order are [\"3\",\"6\",\"7\",\"10\"]. The 4th largest integer in nums is \"3\". Example 2: Input: nums = [\"2\",\"21\",\"12\",\"1\"], k = 3 Output: \"2\" Explanation: The numbers in nums sorted in non-decreasing order are [\"1\",\"2\",\"12\",\"21\"]. The 3rd largest integer in nums is \"2\". Example 3: Input: nums = [\"0\",\"0\"], k = 2 Output: \"0\" Explanation: The numbers in nums sorted in non-decreasing order are [\"0\",\"0\"]. The 2nd largest integer in nums is \"0\". Constraints: 1 <= k <= nums.length <= 104 1 <= nums[i].length <= 100 nums[i] consists of only digits. nums[i] will not have any leading zeros."}, {"role": "assistant", "content": "class Solution:\\n    def kthLargestNumber(self, nums: List[str], k: int) -> str:\\n        nums = sorted(map(int, nums), reverse=True)\\n        return str(nums[k-1])\\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: There are n tasks assigned to you. The task times are represented as an integer array tasks of length n, where the ith task takes tasks[i] hours to finish. A work session is when you work for at most sessionTime consecutive hours and then take a break. You should finish the given tasks in a way that satisfies the following conditions: If you start a task in a work session, you must complete it in the same work session. You can start a new task immediately after finishing the previous one. You may complete the tasks in any order. Given tasks and sessionTime, return the minimum number of work sessions needed to finish all the tasks following the conditions above. The tests are generated such that sessionTime is greater than or equal to the maximum element in tasks[i]. Example 1: Input: tasks = [1,2,3], sessionTime = 3 Output: 2 Explanation: You can finish the tasks in two work sessions. - First work session: finish the first and the second tasks in 1 + 2 = 3 hours. - Second work session: finish the third task in 3 hours. Example 2: Input: tasks = [3,1,3,1,1], sessionTime = 8 Output: 2 Explanation: You can finish the tasks in two work sessions. - First work session: finish all the tasks except the last one in 3 + 1 + 3 + 1 = 8 hours. - Second work session: finish the last task in 1 hour. Example 3: Input: tasks = [1,2,3,4,5], sessionTime = 15 Output: 1 Explanation: You can finish all the tasks in one work session. Constraints: n == tasks.length 1 <= n <= 14 1 <= tasks[i] <= 10 max(tasks[i]) <= sessionTime <= 15"}, {"role": "assistant", "content": "class Solution:\\n    def minSessions(self, tasks: List[int], sessionTime: int) -> int:\\n        subsets = []\\n        self.ans = len(tasks)\\n        \\n        def func(idx):\\n            if len(subsets) >= self.ans:\\n                return\\n            \\n            if idx == len(tasks):\\n                self.ans = min(self.ans, len(subsets))\\n                return\\n            \\n            for i in range(len(subsets)):\\n                if subsets[i] + tasks[idx] <= sessionTime:\\n                    subsets[i] += tasks[idx]\\n                    func(idx + 1)\\n                    subsets[i] -= tasks[idx]\\n            \\n            subsets.append(tasks[idx])\\n            func(idx + 1)\\n            subsets.pop()\\n        \\n        func(0)\\n        return self.ans"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: You are playing a game that contains multiple characters, and each of the characters has two main properties: attack and defense. You are given a 2D integer array properties where properties[i] = [attacki, defensei] represents the properties of the ith character in the game. A character is said to be weak if any other character has both attack and defense levels strictly greater than this character's attack and defense levels. More formally, a character i is said to be weak if there exists another character j where attackj > attacki and defensej > defensei. Return the number of weak characters. Example 1: Input: properties = [[5,5],[6,3],[3,6]] Output: 0 Explanation: No character has strictly greater attack and defense than the other. Example 2: Input: properties = [[2,2],[3,3]] Output: 1 Explanation: The first character is weak because the second character has a strictly greater attack and defense. Example 3: Input: properties = [[1,5],[10,4],[4,3]] Output: 1 Explanation: The third character is weak because the second character has a strictly greater attack and defense. Constraints: 2 <= properties.length <= 105 properties[i].length == 2 1 <= attacki, defensei <= 105"}, {"role": "assistant", "content": "class Solution:\\n    def numberOfWeakCharacters(self, properties: List[List[int]]) -> int:\\n        \\n        properties.sort(key=lambda x: (-x[0],x[1]))\\n        \\n        ans = 0\\n        curr_max = 0\\n        \\n        for _, d in properties:\\n            if d < curr_max:\\n                ans += 1\\n            else:\\n                curr_max = d\\n        return ans\\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: There are n rooms you need to visit, labeled from 0 to n - 1. Each day is labeled, starting from 0. You will go in and visit one room a day. Initially on day 0, you visit room 0. The order you visit the rooms for the coming days is determined by the following rules and a given 0-indexed array nextVisit of length n: Assuming that on a day, you visit room i, if you have been in room i an odd number of times (including the current visit), on the next day you will visit a room with a lower or equal room number specified by nextVisit[i] where 0 <= nextVisit[i] <= i; if you have been in room i an even number of times (including the current visit), on the next day you will visit room (i + 1) mod n. Return the label of the first day where you have been in all the rooms. It can be shown that such a day exists. Since the answer may be very large, return it modulo 109 + 7. Example 1: Input: nextVisit = [0,0] Output: 2 Explanation: - On day 0, you visit room 0. The total times you have been in room 0 is 1, which is odd. On the next day you will visit room nextVisit[0] = 0 - On day 1, you visit room 0, The total times you have been in room 0 is 2, which is even. On the next day you will visit room (0 + 1) mod 2 = 1 - On day 2, you visit room 1. This is the first day where you have been in all the rooms. Example 2: Input: nextVisit = [0,0,2] Output: 6 Explanation: Your room visiting order for each day is: [0,0,1,0,0,1,2,...]. Day 6 is the first day where you have been in all the rooms. Example 3: Input: nextVisit = [0,1,2,0] Output: 6 Explanation: Your room visiting order for each day is: [0,0,1,1,2,2,3,...]. Day 6 is the first day where you have been in all the rooms. Constraints: n == nextVisit.length 2 <= n <= 105 0 <= nextVisit[i] <= i"}, {"role": "assistant", "content": "class Solution:\\n    def firstDayBeenInAllRooms(self, nextVisit: List[int]) -> int:\\n        odd = [0]\\n        even = [1]\\n        for i in range(1, len(nextVisit)): \\n            odd.append((even[-1] + 1) % 1_000_000_007)\\n            even.append((2*odd[-1] - odd[nextVisit[i]] + 1) % 1_000_000_007)\\n        return odd[-1] \\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: You are given n rectangles represented by a 0-indexed 2D integer array rectangles, where rectangles[i] = [widthi, heighti] denotes the width and height of the ith rectangle. Two rectangles i and j (i < j) are considered interchangeable if they have the same width-to-height ratio. More formally, two rectangles are interchangeable if widthi/heighti == widthj/heightj (using decimal division, not integer division). Return the number of pairs of interchangeable rectangles in rectangles. Example 1: Input: rectangles = [[4,8],[3,6],[10,20],[15,30]] Output: 6 Explanation: The following are the interchangeable pairs of rectangles by index (0-indexed): - Rectangle 0 with rectangle 1: 4/8 == 3/6. - Rectangle 0 with rectangle 2: 4/8 == 10/20. - Rectangle 0 with rectangle 3: 4/8 == 15/30. - Rectangle 1 with rectangle 2: 3/6 == 10/20. - Rectangle 1 with rectangle 3: 3/6 == 15/30. - Rectangle 2 with rectangle 3: 10/20 == 15/30. Example 2: Input: rectangles = [[4,5],[7,8]] Output: 0 Explanation: There are no interchangeable pairs of rectangles. Constraints: n == rectangles.length 1 <= n <= 105 rectangles[i].length == 2 1 <= widthi, heighti <= 105"}, {"role": "assistant", "content": "class Solution:\\n    def interchangeableRectangles(self, rectangles: List[List[int]]) -> int:\\n        c = collections.Counter()\\n        for x, y in rectangles:\\n            gcd = math.gcd(x, y)\\n            c[(x // gcd, y // gcd)] += 1\\n        \\n        res = 0\\n        for k, v in c.items():\\n            res += v * (v - 1) // 2\\n        return res\\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: Given a string s, find two disjoint palindromic subsequences of s such that the product of their lengths is maximized. The two subsequences are disjoint if they do not both pick a character at the same index. Return the maximum possible product of the lengths of the two palindromic subsequences. A subsequence is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters. A string is palindromic if it reads the same forward and backward. Example 1: Input: s = \"leetcodecom\" Output: 9 Explanation: An optimal solution is to choose \"ete\" for the 1st subsequence and \"cdc\" for the 2nd subsequence. The product of their lengths is: 3 * 3 = 9. Example 2: Input: s = \"bb\" Output: 1 Explanation: An optimal solution is to choose \"b\" (the first character) for the 1st subsequence and \"b\" (the second character) for the 2nd subsequence. The product of their lengths is: 1 * 1 = 1. Example 3: Input: s = \"accbcaxxcxx\" Output: 25 Explanation: An optimal solution is to choose \"accca\" for the 1st subsequence and \"xxcxx\" for the 2nd subsequence. The product of their lengths is: 5 * 5 = 25. Constraints: 2 <= s.length <= 12 s consists of lowercase English letters only."}, {"role": "assistant", "content": "class Solution:\\n    def maxProduct(self, s: str) -> int:\\n        n, pali = len(s), {} # bitmask : length\\n        for mask in range(1, 1 << n):\\n            subseq = \"\"\\n            for i in range(n):\\n                if mask & (1 << i):\\n                    subseq += s[i]\\n            if subseq == subseq[::-1]: # valid is palindromic\\n                pali[mask] = len(subseq)\\n        res = 0\\n        for mask1, length1 in pali.items():\\n            for mask2, length2 in pali.items():\\n                if mask1 & mask2 == 0: \\n                    res = max(res, length1 * length2)\\n        return res\\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: An integer array original is transformed into a doubled array changed by appending twice the value of every element in original, and then randomly shuffling the resulting array. Given an array changed, return original if changed is a doubled array. If changed is not a doubled array, return an empty array. The elements in original may be returned in any order. Example 1: Input: changed = [1,3,4,2,6,8] Output: [1,3,4] Explanation: One possible original array could be [1,3,4]: - Twice the value of 1 is 1 * 2 = 2. - Twice the value of 3 is 3 * 2 = 6. - Twice the value of 4 is 4 * 2 = 8. Other original arrays could be [4,3,1] or [3,1,4]. Example 2: Input: changed = [6,3,0,1] Output: [] Explanation: changed is not a doubled array. Example 3: Input: changed = [1] Output: [] Explanation: changed is not a doubled array. Constraints: 1 <= changed.length <= 105 0 <= changed[i] <= 105"}, {"role": "assistant", "content": "class Solution:\\n    def findOriginalArray(self, changed):\\n        # use Counter to count the frequency of each element in `changed`\\n        cnt, ans = Counter(changed), []\\n        # if the length of the input is odd, then return []\\n        # because doubled array must have even length\\n        if len(changed) % 2: return []\\n        # sort in ascending order\\n        for x in sorted(cnt.keys()):\\n            # if the number of cnt[x] is greater than than cnt[x * 2]\\n            # then there would be some cnt[x] left\\n            # therefore, return [] here as changed is not a doubled array\\n            if cnt[x] > cnt[x * 2]: return []\\n            # handle cases like [0,0,0,0]\\n            if x == 0:\\n                # similarly, odd length -> return []\\n                if cnt[x] % 2:\\n                    return []\\n                else: \\n                    # add `0` `cnt[x] // 2` times \\n                    ans += [0] * (cnt[x] // 2)\\n            else:\\n                # otherwise, we put the element `x` `cnt[x]` times to ans\\n                ans += [x] * cnt[x]\\n            cnt[2 * x] -= cnt[x]\\n        return ans\\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: There are n points on a road you are driving your taxi on. The n points on the road are labeled from 1 to n in the direction you are going, and you want to drive from point 1 to point n to make money by picking up passengers. You cannot change the direction of the taxi. The passengers are represented by a 0-indexed 2D integer array rides, where rides[i] = [starti, endi, tipi] denotes the ith passenger requesting a ride from point starti to point endi who is willing to give a tipi dollar tip. For each passenger i you pick up, you earn endi - starti + tipi dollars. You may only drive at most one passenger at a time. Given n and rides, return the maximum number of dollars you can earn by picking up the passengers optimally. Note: You may drop off a passenger and pick up a different passenger at the same point. Example 1: Input: n = 5, rides = [[2,5,4],[1,5,1]] Output: 7 Explanation: We can pick up passenger 0 to earn 5 - 2 + 4 = 7 dollars. Example 2: Input: n = 20, rides = [[1,6,1],[3,10,2],[10,12,3],[11,12,2],[12,15,2],[13,18,1]] Output: 20 Explanation: We will pick up the following passengers: - Drive passenger 1 from point 3 to point 10 for a profit of 10 - 3 + 2 = 9 dollars. - Drive passenger 2 from point 10 to point 12 for a profit of 12 - 10 + 3 = 5 dollars. - Drive passenger 5 from point 13 to point 18 for a profit of 18 - 13 + 1 = 6 dollars. We earn 9 + 5 + 6 = 20 dollars in total. Constraints: 1 <= n <= 105 1 <= rides.length <= 3 * 104 rides[i].length == 3 1 <= starti < endi <= n 1 <= tipi <= 105"}, {"role": "assistant", "content": "class Solution:\\n    def maxTaxiEarnings(self, n: int, rides: List[List[int]]) -> int:\\n        \\n        d = {}\\n        for start,end,tip in rides:\\n            if end not in d:\\n                d[end] =[[start,tip]]\\n            else:\\n                d[end].append([start,tip])\\n        \\n       \\n        dp = [0]*(n+1)\\n        dp[0] = 0\\n        \\n        for i in range(1,n+1):\\n            dp[i] = dp[i-1]\\n            if i in d:\\n                temp_profit = 0\\n                for start,tip in d[i]:\\n                    if (i-start)+tip+dp[start] > temp_profit:\\n                        temp_profit = i-start+tip+dp[start]\\n                dp[i] = max(dp[i],temp_profit)\\n                \\n                \\n        return dp[-1]\\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: You are given an m x n matrix board, representing the current state of a crossword puzzle. The crossword contains lowercase English letters (from solved words), ' ' to represent any empty cells, and '#' to represent any blocked cells. A word can be placed horizontally (left to right or right to left) or vertically (top to bottom or bottom to top) in the board if: It does not occupy a cell containing the character '#'. The cell each letter is placed in must either be ' ' (empty) or match the letter already on the board. There must not be any empty cells ' ' or other lowercase letters directly left or right of the word if the word was placed horizontally. There must not be any empty cells ' ' or other lowercase letters directly above or below the word if the word was placed vertically. Given a string word, return true if word can be placed in board, or false otherwise. Example 1: Input: board = [[\"#\", \" \", \"#\"], [\" \", \" \", \"#\"], [\"#\", \"c\", \" \"]], word = \"abc\" Output: true Explanation: The word \"abc\" can be placed as shown above (top to bottom). Example 2: Input: board = [[\" \", \"#\", \"a\"], [\" \", \"#\", \"c\"], [\" \", \"#\", \"a\"]], word = \"ac\" Output: false Explanation: It is impossible to place the word because there will always be a space/letter above or below it. Example 3: Input: board = [[\"#\", \" \", \"#\"], [\" \", \" \", \"#\"], [\"#\", \" \", \"c\"]], word = \"ca\" Output: true Explanation: The word \"ca\" can be placed as shown above (right to left). Constraints: m == board.length n == board[i].length 1 <= m * n <= 2 * 105 board[i][j] will be ' ', '#', or a lowercase English letter. 1 <= word.length <= max(m, n) word will contain only lowercase English letters."}, {"role": "assistant", "content": "class Solution:\\n    def placeWordInCrossword(self, board: List[List[str]], word: str) -> bool:\\n        for x in board, zip(*board): \\n            for row in x: \\n                for s in \"\".join(row).split(\"#\"): \\n                    for w in word, word[::-1]: \\n                        if len(s) == len(w) and all(ss in (\" \", ww) for ss, ww in zip(s, w)): return True \\n        return False\\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: Given an array of digit strings nums and a digit string target, return the number of pairs of indices (i, j) (where i != j) such that the concatenation of nums[i] + nums[j] equals target. Example 1: Input: nums = [\"777\",\"7\",\"77\",\"77\"], target = \"7777\" Output: 4 Explanation: Valid pairs are: - (0, 1): \"777\" + \"7\" - (1, 0): \"7\" + \"777\" - (2, 3): \"77\" + \"77\" - (3, 2): \"77\" + \"77\" Example 2: Input: nums = [\"123\",\"4\",\"12\",\"34\"], target = \"1234\" Output: 2 Explanation: Valid pairs are: - (0, 1): \"123\" + \"4\" - (2, 3): \"12\" + \"34\" Example 3: Input: nums = [\"1\",\"1\",\"1\"], target = \"11\" Output: 6 Explanation: Valid pairs are: - (0, 1): \"1\" + \"1\" - (1, 0): \"1\" + \"1\" - (0, 2): \"1\" + \"1\" - (2, 0): \"1\" + \"1\" - (1, 2): \"1\" + \"1\" - (2, 1): \"1\" + \"1\" Constraints: 2 <= nums.length <= 100 1 <= nums[i].length <= 100 2 <= target.length <= 100 nums[i] and target consist of digits. nums[i] and target do not have leading zeros."}, {"role": "assistant", "content": "class Solution:\\n    def numOfPairs(self, nums: List[str], target: str) -> int:\\n        freq = Counter(nums)\\n        ans = 0 \\n        for k, v in freq.items(): \\n            if target.startswith(k): \\n                suffix = target[len(k):]\\n                ans += v * freq[suffix]\\n                if k == suffix: ans -= freq[suffix]\\n        return ans \\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: You have observations of n + m 6-sided dice rolls with each face numbered from 1 to 6. n of the observations went missing, and you only have the observations of m rolls. Fortunately, you have also calculated the average value of the n + m rolls. You are given an integer array rolls of length m where rolls[i] is the value of the ith observation. You are also given the two integers mean and n. Return an array of length n containing the missing observations such that the average value of the n + m rolls is exactly mean. If there are multiple valid answers, return any of them. If no such array exists, return an empty array. The average value of a set of k numbers is the sum of the numbers divided by k. Note that mean is an integer, so the sum of the n + m rolls should be divisible by n + m. Example 1: Input: rolls = [3,2,4,3], mean = 4, n = 2 Output: [6,6] Explanation: The mean of all n + m rolls is (3 + 2 + 4 + 3 + 6 + 6) / 6 = 4. Example 2: Input: rolls = [1,5,6], mean = 3, n = 4 Output: [2,3,2,2] Explanation: The mean of all n + m rolls is (1 + 5 + 6 + 2 + 3 + 2 + 2) / 7 = 3. Example 3: Input: rolls = [1,2,3,4], mean = 6, n = 4 Output: [] Explanation: It is impossible for the mean to be 6 no matter what the 4 missing rolls are. Constraints: m == rolls.length 1 <= n, m <= 105 1 <= rolls[i], mean <= 6"}, {"role": "assistant", "content": "class Solution:\\n    def missingRolls(self, rolls: List[int], mean: int, n: int) -> List[int]:\\n        m = len(rolls)\\n        sums = mean * (m+n) - sum(rolls)\\n\\n        if sums < n or not ( 1 <= sums / n <= 6):\\n            return list()\\n        if sums % n == 0:\\n            return [sums // n] * n\\n        else:\\n            k = sums % n\\n            res = [sums//n] * n\\n            for i in range(k):\\n                res[i] += 1\\n            return res\\n        \\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: Alice and Bob continue their games with stones. There is a row of n stones, and each stone has an associated value. You are given an integer array stones, where stones[i] is the value of the ith stone. Alice and Bob take turns, with Alice starting first. On each turn, the player may remove any stone from stones. The player who removes a stone loses if the sum of the values of all removed stones is divisible by 3. Bob will win automatically if there are no remaining stones (even if it is Alice's turn). Assuming both players play optimally, return true if Alice wins and false if Bob wins. Example 1: Input: stones = [2,1] Output: true Explanation: The game will be played as follows: - Turn 1: Alice can remove either stone. - Turn 2: Bob removes the remaining stone. The sum of the removed stones is 1 + 2 = 3 and is divisible by 3. Therefore, Bob loses and Alice wins the game. Example 2: Input: stones = [2] Output: false Explanation: Alice will remove the only stone, and the sum of the values on the removed stones is 2. Since all the stones are removed and the sum of values is not divisible by 3, Bob wins the game. Example 3: Input: stones = [5,1,2,4,3] Output: false Explanation: Bob will always win. One possible way for Bob to win is shown below: - Turn 1: Alice can remove the second stone with value 1. Sum of removed stones = 1. - Turn 2: Bob removes the fifth stone with value 3. Sum of removed stones = 1 + 3 = 4. - Turn 3: Alices removes the fourth stone with value 4. Sum of removed stones = 1 + 3 + 4 = 8. - Turn 4: Bob removes the third stone with value 2. Sum of removed stones = 1 + 3 + 4 + 2 = 10. - Turn 5: Alice removes the first stone with value 5. Sum of removed stones = 1 + 3 + 4 + 2 + 5 = 15. Alice loses the game because the sum of the removed stones (15) is divisible by 3. Bob wins the game. Constraints: 1 <= stones.length <= 105 1 <= stones[i] <= 104"}, {"role": "assistant", "content": "class Solution:\\n    def stoneGameIX(self, stones: List[int]) -> bool:\\n        freq = defaultdict(int)\\n        for x in stones: freq[x % 3] += 1\\n        \\n        if freq[0]%2 == 0: return freq[1] and freq[2]\\n        return abs(freq[1] - freq[2]) >= 3\\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: You are given a 2D integer grid of size m x n and an integer x. In one operation, you can add x to or subtract x from any element in the grid. A uni-value grid is a grid where all the elements of it are equal. Return the minimum number of operations to make the grid uni-value. If it is not possible, return -1. Example 1: Input: grid = [[2,4],[6,8]], x = 2 Output: 4 Explanation: We can make every element equal to 4 by doing the following: - Add x to 2 once. - Subtract x from 6 once. - Subtract x from 8 twice. A total of 4 operations were used. Example 2: Input: grid = [[1,5],[2,3]], x = 1 Output: 5 Explanation: We can make every element equal to 3. Example 3: Input: grid = [[1,2],[3,4]], x = 2 Output: -1 Explanation: It is impossible to make every element equal. Constraints: m == grid.length n == grid[i].length 1 <= m, n <= 105 1 <= m * n <= 105 1 <= x, grid[i][j] <= 104"}, {"role": "assistant", "content": "class Solution:\\n    def minOperations(self, grid: List[List[int]], x: int) -> int:\\n        vals = [x for row in grid for x in row]\\n        if len(set(val%x for val in vals)) > 1: return -1 # impossible\\n        median = sorted(vals)[len(vals)//2] # O(N) possible via \"quick select\"\\n        return sum(abs(val - median)//x for val in vals)\\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: There are n pieces arranged in a line, and each piece is colored either by 'A' or by 'B'. You are given a string colors of length n where colors[i] is the color of the ith piece. Alice and Bob are playing a game where they take alternating turns removing pieces from the line. In this game, Alice moves first. Alice is only allowed to remove a piece colored 'A' if both its neighbors are also colored 'A'. She is not allowed to remove pieces that are colored 'B'. Bob is only allowed to remove a piece colored 'B' if both its neighbors are also colored 'B'. He is not allowed to remove pieces that are colored 'A'. Alice and Bob cannot remove pieces from the edge of the line. If a player cannot make a move on their turn, that player loses and the other player wins. Assuming Alice and Bob play optimally, return true if Alice wins, or return false if Bob wins. Example 1: Input: colors = \"AAABABB\" Output: true Explanation: AAABABB -> AABABB Alice moves first. She removes the second 'A' from the left since that is the only 'A' whose neighbors are both 'A'. Now it's Bob's turn. Bob cannot make a move on his turn since there are no 'B's whose neighbors are both 'B'. Thus, Alice wins, so return true. Example 2: Input: colors = \"AA\" Output: false Explanation: Alice has her turn first. There are only two 'A's and both are on the edge of the line, so she cannot move on her turn. Thus, Bob wins, so return false. Example 3: Input: colors = \"ABBBBBBBAAA\" Output: false Explanation: ABBBBBBBAAA -> ABBBBBBBAA Alice moves first. Her only option is to remove the second to last 'A' from the right. ABBBBBBBAA -> ABBBBBBAA Next is Bob's turn. He has many options for which 'B' piece to remove. He can pick any. On Alice's second turn, she has no more pieces that she can remove. Thus, Bob wins, so return false. Constraints: 1 <= colors.length <= 105 colors consists of only the letters 'A' and 'B'"}, {"role": "assistant", "content": "class Solution:\\n    def winnerOfGame(self, s: str) -> bool:\\n        \\n        a = b = 0\\n        \\n        for i in range(1,len(s)-1):\\n            if s[i-1] == s[i] == s[i+1]:\\n                if s[i] == \\'A\\':\\n                    a += 1\\n                else:\\n                    b += 1\\n                    \\n        return a>b\\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: There is a network of n servers, labeled from 0 to n - 1. You are given a 2D integer array edges, where edges[i] = [ui, vi] indicates there is a message channel between servers ui and vi, and they can pass any number of messages to each other directly in one second. You are also given a 0-indexed integer array patience of length n. All servers are connected, i.e., a message can be passed from one server to any other server(s) directly or indirectly through the message channels. The server labeled 0 is the master server. The rest are data servers. Each data server needs to send its message to the master server for processing and wait for a reply. Messages move between servers optimally, so every message takes the least amount of time to arrive at the master server. The master server will process all newly arrived messages instantly and send a reply to the originating server via the reversed path the message had gone through. At the beginning of second 0, each data server sends its message to be processed. Starting from second 1, at the beginning of every second, each data server will check if it has received a reply to the message it sent (including any newly arrived replies) from the master server: If it has not, it will resend the message periodically. The data server i will resend the message every patience[i] second(s), i.e., the data server i will resend the message if patience[i] second(s) have elapsed since the last time the message was sent from this server. Otherwise, no more resending will occur from this server. The network becomes idle when there are no messages passing between servers or arriving at servers. Return the earliest second starting from which the network becomes idle. Example 1: Input: edges = [[0,1],[1,2]], patience = [0,2,1] Output: 8 Explanation: At (the beginning of) second 0, - Data server 1 sends its message (denoted 1A) to the master server. - Data server 2 sends its message (denoted 2A) to the master server. At second 1, - Message 1A arrives at the master server. Master server processes message 1A instantly and sends a reply 1A back. - Server 1 has not received any reply. 1 second (1 < patience[1] = 2) elapsed since this server has sent the message, therefore it does not resend the message. - Server 2 has not received any reply. 1 second (1 == patience[2] = 1) elapsed since this server has sent the message, therefore it resends the message (denoted 2B). At second 2, - The reply 1A arrives at server 1. No more resending will occur from server 1. - Message 2A arrives at the master server. Master server processes message 2A instantly and sends a reply 2A back. - Server 2 resends the message (denoted 2C). ... At second 4, - The reply 2A arrives at server 2. No more resending will occur from server 2. ... At second 7, reply 2D arrives at server 2. Starting from the beginning of the second 8, there are no messages passing between servers or arriving at servers. This is the time when the network becomes idle. Example 2: Input: edges = [[0,1],[0,2],[1,2]], patience = [0,10,10] Output: 3 Explanation: Data servers 1 and 2 receive a reply back at the beginning of second 2. From the beginning of the second 3, the network becomes idle. Constraints: n == patience.length 2 <= n <= 105 patience[0] == 0 1 <= patience[i] <= 105 for 1 <= i < n 1 <= edges.length <= min(105, n * (n - 1) / 2) edges[i].length == 2 0 <= ui, vi < n ui != vi There are no duplicate edges. Each server can directly or indirectly reach another server."}, {"role": "assistant", "content": "class Solution:\\n    def networkBecomesIdle(self, edges: List[List[int]], patience: List[int]) -> int:\\n        graph = {}\\n        for u, v in edges: \\n            graph.setdefault(u, []).append(v)\\n            graph.setdefault(v, []).append(u)\\n        \\n        dist = [-1]*len(graph)\\n        dist[0] = 0 \\n        val = 0\\n        queue = [0]\\n        while queue: \\n            val += 2\\n            newq = []\\n            for u in queue: \\n                for v in graph[u]: \\n                    if dist[v] == -1: \\n                        dist[v] = val\\n                        newq.append(v)\\n            queue = newq\\n        \\n        ans = 0\\n        for d, p in zip(dist, patience): \\n            if p: \\n                k = d//p - int(d%p == 0)\\n                ans = max(ans, d + k*p)\\n        return ans + 1\\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: Given an integer array nums, find the maximum possible bitwise OR of a subset of nums and return the number of different non-empty subsets with the maximum bitwise OR. An array a is a subset of an array b if a can be obtained from b by deleting some (possibly zero) elements of b. Two subsets are considered different if the indices of the elements chosen are different. The bitwise OR of an array a is equal to a[0] OR a[1] OR ... OR a[a.length - 1] (0-indexed). Example 1: Input: nums = [3,1] Output: 2 Explanation: The maximum possible bitwise OR of a subset is 3. There are 2 subsets with a bitwise OR of 3: - [3] - [3,1] Example 2: Input: nums = [2,2,2] Output: 7 Explanation: All non-empty subsets of [2,2,2] have a bitwise OR of 2. There are 23 - 1 = 7 total subsets. Example 3: Input: nums = [3,2,1,5] Output: 6 Explanation: The maximum possible bitwise OR of a subset is 7. There are 6 subsets with a bitwise OR of 7: - [3,5] - [3,1,5] - [3,2,5] - [3,2,1,5] - [2,5] - [2,1,5] Constraints: 1 <= nums.length <= 16 1 <= nums[i] <= 105"}, {"role": "assistant", "content": "class Solution:\\n    def countMaxOrSubsets(self, nums: List[int]) -> int:\\n        target = reduce(or_, nums)\\n        \\n        @cache\\n        def fn(i, mask): \\n            \"\"\"Return number of subsets to get target.\"\"\"\\n            if mask == target: return 2**(len(nums)-i)\\n            if i == len(nums): return 0 \\n            return fn(i+1, mask | nums[i]) + fn(i+1, mask)\\n        \\n        return fn(0, 0)\\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: An integer x is numerically balanced if for every digit d in the number x, there are exactly d occurrences of that digit in x. Given an integer n, return the smallest numerically balanced number strictly greater than n. Example 1: Input: n = 1 Output: 22 Explanation: 22 is numerically balanced since: - The digit 2 occurs 2 times. It is also the smallest numerically balanced number strictly greater than 1. Example 2: Input: n = 1000 Output: 1333 Explanation: 1333 is numerically balanced since: - The digit 1 occurs 1 time. - The digit 3 occurs 3 times. It is also the smallest numerically balanced number strictly greater than 1000. Note that 1022 cannot be the answer because 0 appeared more than 0 times. Example 3: Input: n = 3000 Output: 3133 Explanation: 3133 is numerically balanced since: - The digit 1 occurs 1 time. - The digit 3 occurs 3 times. It is also the smallest numerically balanced number strictly greater than 3000. Constraints: 0 <= n <= 106"}, {"role": "assistant", "content": "class Solution:\\n    def nextBeautifulNumber(self, n: int) -> int:\\n        while True: \\n            n += 1\\n            nn = n \\n            freq = defaultdict(int)\\n            while nn: \\n                nn, d = divmod(nn, 10)\\n                freq[d] += 1\\n            if all(k == v for k, v in freq.items()): return n \\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: There is a binary tree rooted at 0 consisting of n nodes. The nodes are labeled from 0 to n - 1. You are given a 0-indexed integer array parents representing the tree, where parents[i] is the parent of node i. Since node 0 is the root, parents[0] == -1. Each node has a score. To find the score of a node, consider if the node and the edges connected to it were removed. The tree would become one or more non-empty subtrees. The size of a subtree is the number of the nodes in it. The score of the node is the product of the sizes of all those subtrees. Return the number of nodes that have the highest score. Example 1: Input: parents = [-1,2,0,2,0] Output: 3 Explanation: - The score of node 0 is: 3 * 1 = 3 - The score of node 1 is: 4 = 4 - The score of node 2 is: 1 * 1 * 2 = 2 - The score of node 3 is: 4 = 4 - The score of node 4 is: 4 = 4 The highest score is 4, and three nodes (node 1, node 3, and node 4) have the highest score. Example 2: Input: parents = [-1,2,0] Output: 2 Explanation: - The score of node 0 is: 2 = 2 - The score of node 1 is: 2 = 2 - The score of node 2 is: 1 * 1 = 1 The highest score is 2, and two nodes (node 0 and node 1) have the highest score. Constraints: n == parents.length 2 <= n <= 105 parents[0] == -1 0 <= parents[i] <= n - 1 for i != 0 parents represents a valid binary tree."}, {"role": "assistant", "content": "class Solution:\\n    def countHighestScoreNodes(self, parents: List[int]) -> int:\\n        graph = collections.defaultdict(list)\\n        for node, parent in enumerate(parents):  # build graph\\n            graph[parent].append(node)\\n        n = len(parents)                         # total number of nodes\\n        d = collections.Counter()\\n        def count_nodes(node):                   # number of children node + self\\n            p, s = 1, 0                          # p: product, s: sum\\n            for child in graph[node]:            # for each child (only 2 at maximum)\\n                res = count_nodes(child)         # get its nodes count\\n                p *= res                         # take the product\\n                s += res                         # take the sum\\n            p *= max(1, n - 1 - s)               # times up-branch (number of nodes other than left, right children ans itself)\\n            d[p] += 1                            # count the product\\n            return s + 1                         # return number of children node + 1 (self)\\n        count_nodes(0)                           # starting from root (0)\\n        return d[max(d.keys())]                  # return max count\\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: You are given a 0-indexed 2D integer array of events where events[i] = [startTimei, endTimei, valuei]. The ith event starts at startTimei and ends at endTimei, and if you attend this event, you will receive a value of valuei. You can choose at most two non-overlapping events to attend such that the sum of their values is maximized. Return this maximum sum. Note that the start time and end time is inclusive: that is, you cannot attend two events where one of them starts and the other ends at the same time. More specifically, if you attend an event with end time t, the next event must start at or after t + 1. Example 1: Input: events = [[1,3,2],[4,5,2],[2,4,3]] Output: 4 Explanation: Choose the green events, 0 and 1 for a sum of 2 + 2 = 4. Example 2: Input: events = [[1,3,2],[4,5,2],[1,5,5]] Output: 5 Explanation: Choose event 2 for a sum of 5. Example 3: Input: events = [[1,5,3],[1,5,1],[6,6,5]] Output: 8 Explanation: Choose events 0 and 2 for a sum of 3 + 5 = 8. Constraints: 2 <= events.length <= 105 events[i].length == 3 1 <= startTimei <= endTimei <= 109 1 <= valuei <= 106"}, {"role": "assistant", "content": "class Solution:\\n    def maxTwoEvents(self, events: List[List[int]]) -> int:\\n        time = []\\n        vals = []\\n        ans = prefix = 0\\n        for st, et, val in sorted(events, key=lambda x: x[1]): \\n            prefix = max(prefix, val)\\n            k = bisect_left(time, st)-1\\n            if k >= 0: val += vals[k]\\n            ans = max(ans, val)\\n            time.append(et)\\n            vals.append(prefix)\\n        return ans \\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: There is a long table with a line of plates and candles arranged on top of it. You are given a 0-indexed string s consisting of characters '*' and '|' only, where a '*' represents a plate and a '|' represents a candle. You are also given a 0-indexed 2D integer array queries where queries[i] = [lefti, righti] denotes the substring s[lefti...righti] (inclusive). For each query, you need to find the number of plates between candles that are in the substring. A plate is considered between candles if there is at least one candle to its left and at least one candle to its right in the substring. For example, s = \"||**||**|*\", and a query [3, 8] denotes the substring \"*||**|\". The number of plates between candles in this substring is 2, as each of the two plates has at least one candle in the substring to its left and right. Return an integer array answer where answer[i] is the answer to the ith query. Example 1: Input: s = \"**|**|***|\", queries = [[2,5],[5,9]] Output: [2,3] Explanation: - queries[0] has two plates between candles. - queries[1] has three plates between candles. Example 2: Input: s = \"***|**|*****|**||**|*\", queries = [[1,17],[4,5],[14,17],[5,11],[15,16]] Output: [9,0,0,0,0] Explanation: - queries[0] has nine plates between candles. - The other queries have zero plates between candles. Constraints: 3 <= s.length <= 105 s consists of '*' and '|' characters. 1 <= queries.length <= 105 queries[i].length == 2 0 <= lefti <= righti < s.length"}, {"role": "assistant", "content": "class Solution:\\n    def platesBetweenCandles(self, s: str, qs: List[List[int]]) -> List[int]:\\n        n=len(s)\\n        prefcandle=[-1]*n #this stores the position of closest candle from current towards left\\n        suffcandle=[0]*n #this stores the position of closest candle from current towards right\\n        \\n        pref=[0]*n #stores the number of plates  till ith position from 0 - for i = 0 -> n \\n        \\n        ind=-1\\n        c=0\\n        #The following method calculates number of plates(*) till ith position from 0 - for i = 0 -> n \\n        for i in range(n):\\n            if ind!=-1 and s[i]==\\'*\\':\\n                c+=1\\n            elif s[i]==\\'|\\':\\n                ind=i\\n            pref[i]=c\\n              \\n        #this method calculates the left nearest candle to a point\\n        #intial is -1 as to left of leftmost element no candle can be present\\n        ind =-1\\n        for i in range(n):\\n            if s[i] == \\'|\\':\\n                ind=i\\n            prefcandle[i]=ind\\n            \\n        #this method calculates the right nearest candle to a point\\n        #intial is infinity as to right of rightmost element no candle can be present\\n        ind = float(\\'inf\\')       \\n        for i in range(n-1, -1, -1):\\n            if s[i]==\\'|\\':\\n                ind=i\\n            suffcandle[i]=ind\\n\\n        #m = no of queries\\n        m=len(qs)\\n        ans=[0]*m\\n\\n        for i in range(m):\\n            c=0\\n            l=qs[i][0]\\n            r=qs[i][1]\\n            \\n            #check if left nearest candle of right boundary is after left boundary\\n            #check if right nearest candle of left boundary is before right boundary\\n            # to summarise - here we find if there is a pair of candle present within the given range or not\\n            if prefcandle[r]<l or suffcandle[l]>r:\\n                continue\\n            \\n            #desired answer is no of pplates(*) only inside 2 candles (|) inside the given boundary area\\n            ans[i]=pref[prefcandle[r]]-pref[suffcandle[l]]\\n        return ans\\n        \\n"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: A critical point in a linked list is defined as either a local maxima or a local minima. A node is a local maxima if the current node has a value strictly greater than the previous node and the next node. A node is a local minima if the current node has a value strictly smaller than the previous node and the next node. Note that a node can only be a local maxima/minima if there exists both a previous node and a next node. Given a linked list head, return an array of length 2 containing [minDistance, maxDistance] where minDistance is the minimum distance between any two distinct critical points and maxDistance is the maximum distance between any two distinct critical points. If there are fewer than two critical points, return [-1, -1]. Example 1: Input: head = [3,1] Output: [-1,-1] Explanation: There are no critical points in [3,1]. Example 2: Input: head = [5,3,1,2,5,1,2] Output: [1,3] Explanation: There are three critical points: - [5,3,1,2,5,1,2]: The third node is a local minima because 1 is less than 3 and 2. - [5,3,1,2,5,1,2]: The fifth node is a local maxima because 5 is greater than 2 and 1. - [5,3,1,2,5,1,2]: The sixth node is a local minima because 1 is less than 5 and 2. The minimum distance is between the fifth and the sixth node. minDistance = 6 - 5 = 1. The maximum distance is between the third and the sixth node. maxDistance = 6 - 3 = 3. Example 3: Input: head = [1,3,2,2,3,2,2,2,7] Output: [3,3] Explanation: There are two critical points: - [1,3,2,2,3,2,2,2,7]: The second node is a local maxima because 3 is greater than 1 and 2. - [1,3,2,2,3,2,2,2,7]: The fifth node is a local maxima because 3 is greater than 2 and 2. Both the minimum and maximum distances are between the second and the fifth node. Thus, minDistance and maxDistance is 5 - 2 = 3. Note that the last node is not considered a local maxima because it does not have a next node. Constraints: The number of nodes in the list is in the range [2, 105]. 1 <= Node.val <= 105"}, {"role": "assistant", "content": "class Solution:\\n\\t\\n\\tdef nodesBetweenCriticalPoints(self, head: Optional[ListNode]) -> List[int]:\\n        \\n        prev = None\\n        temp = head\\n        \\n        mini, maxi = 10 ** 5, 0\\n        count = 1\\n        \\n        diff = 10 ** 5\\n        while temp.next.next != None:\\n            prev = temp\\n            temp = temp.next\\n            count += 1\\n            \\n            if prev.val > temp.val < temp.next.val or prev.val < temp.val > temp.next.val:\\n            \\n                if maxi != 0:\\n                    mini = min(mini, count - maxi)\\n                diff = min(diff, count)\\n                maxi = count\\n        \\n        if diff == 10 ** 5 or mini == 10 ** 5:\\n            return [-1, -1]\\n        return [mini, maxi - diff]\\n\\t\\t\\n# if you like the solution, Please upvote!!"}]}
{"messages": [{"role": "user", "content": "Write an optimized Python function to solve the following problem: You are given a 0-indexed integer array nums containing distinct numbers, an integer start, and an integer goal. There is an integer x that is initially set to start, and you want to perform operations on x such that it is converted to goal. You can perform the following operation repeatedly on the number x: If 0 <= x <= 1000, then for any index i in the array (0 <= i < nums.length), you can set x to any of the following: x + nums[i] x - nums[i] x ^ nums[i] (bitwise-XOR) Note that you can use each nums[i] any number of times in any order. Operations that set x to be out of the range 0 <= x <= 1000 are valid, but no more operations can be done afterward. Return the minimum number of operations needed to convert x = start into goal, and -1 if it is not possible. Example 1: Input: nums = [2,4,12], start = 2, goal = 12 Output: 2 Explanation: We can go from 2 \u2192 14 \u2192 12 with the following 2 operations. - 2 + 12 = 14 - 14 - 2 = 12 Example 2: Input: nums = [3,5,7], start = 0, goal = -4 Output: 2 Explanation: We can go from 0 \u2192 3 \u2192 -4 with the following 2 operations. - 0 + 3 = 3 - 3 - 7 = -4 Note that the last operation sets x out of the range 0 <= x <= 1000, which is valid. Example 3: Input: nums = [2,8,16], start = 0, goal = 1 Output: -1 Explanation: There is no way to convert 0 into 1. Constraints: 1 <= nums.length <= 1000 -109 <= nums[i], goal <= 109 0 <= start <= 1000 start != goal All the integers in nums are distinct."}, {"role": "assistant", "content": "class Solution:\\n    def minimumOperations(self, nums: List[int], start: int, goal: int) -> int:\\n        ans = 0\\n        seen = {start}\\n        queue = deque([start])\\n        while queue: \\n            for _ in range(len(queue)): \\n                val = queue.popleft()\\n                if val == goal: return ans \\n                if 0 <= val <= 1000: \\n                    for x in nums: \\n                        for op in (add, sub, xor): \\n                            if op(val, x) not in seen: \\n                                seen.add(op(val, x))\\n                                queue.append(op(val, x))\\n            ans += 1\\n        return -1 \\n"}]}